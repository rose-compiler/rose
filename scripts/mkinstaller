#!/usr/bin/perl
$Interpreter ||= "/usr/bin/perl";
#-------------------------------------------------------------------------------
#
#   Copyright 1985-99,2000-20 James Frederick Reus
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#-------------------------------------------------------------------------------

# MyUniqueFileId: 05bfd522-45a2-4dfa-ca27-420e6c630546

$mkinstaller_ver_major = "2";
$mkinstaller_ver_minor = "6";
$mkinstaller_ver_build = "3";
$mkinstaller_ver_patch = "3";
$mkinstaller_ver_name  = "2.6.3.3";
$mkinstaller_ver_time  = "17Jul2020,20:42:41z";
$mkinstaller_ver_id    = "@(#)mkinstaller 2.6.3.3 - 17Jul2020,20:42:41z";

# MyUniqueFileId: d34be5e4-1cfc-49b6-d988-25ab878c795f

$perl_library_ver_major = "2";
$perl_library_ver_minor = "0";
$perl_library_ver_build = "0";
$perl_library_ver_patch = "1";
$perl_library_ver_name  = "2.0.0.1";
$perl_library_ver_time  = " 5Jul2020,04:28:10z";
$perl_library_ver_id    = "@(#)perl_library 2.0.0.1 -  5Jul2020,04:28:10z";

#{------------------------------------------------------------------------------
#
#       tbg_extensions.pfrag
#
#       This file was generated by the configure script using simple
#       stubstitution at configuration time. It is meant to ease the
#       importation of a filename extension discovered at configuration
#       time to be used at build-time.
#
#-------------------------------------------------------------------------------

#---------------------------------------
#
#       Filename extensions...
#
#---------------------------------------

$TBG_A_EXT      = ".a";
$TBG_AXX_EXT    = ".a";
$TBG_CSH_EXT    = "";
$TBG_HTML_EXT   = ".html";
$TBG_KSH_EXT    = "";
$TBG_O_EXT      = ".o";
$TBG_PERL_EXT   = "";
$TBG_PYTHON_EXT = "";
$TBG_SH_EXT     = "";
$TBG_X_EXT      = "";

#---------------------------------------
#
#       The prefix to a library filename
#       (a UNIX-ism, is an empty string
#       on Windows-like systems)...
#
#---------------------------------------

$TBG_LIB_PFX    = "lib";

#}------------------------------------------------------------------------------

@defaultCopyrightOwners
  = ( "Copyright 1985-99,2000-20 James Frederick Reus\n"
    );

@defaultCopyrightStatement
  = ( "Licensed under the Apache License, Version 2.0 (the \"License\");\n"
    , "you may not use this file except in compliance with the License.\n"
    , "You may obtain a copy of the License at\n"
    , "\n"
    , "    http://www.apache.org/licenses/LICENSE-2.0\n"
    , "\n"
    , "Unless required by applicable law or agreed to in writing, software\n"
    , "distributed under the License is distributed on an \"AS IS\" BASIS,\n"
    , "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
    , "See the License for the specific language governing permissions and\n"
    , "limitations under the License.\n"
    );

# MyUniqueFileId: 8428f7ce-97e8-4d57-c29f-84c52fae80f1
$rawCommand  = $0;
$theCommand  = pKit_nativePathname($rawCommand);
$foundInDir  = "";

#-------------------------------------------------------------------------------
#
#  The DEBUG_mkinstaller (or DEBUG) environment variable is used to control the
#  production of debugging output.
#
#     not set
#
#         Don't produce debugging output.
#
#     0
#
#         Don't produce debugging output.
#
#     non-zero integer
#
#         Send debugging output to <stderr>
#
#     pathname
#
#         Send debugging output to the given pathname.
#
#-------------------------------------------------------------------------------

$debugging          = 0;
$dbgOutToPathname   = "";

my $valueOfDebugVar = "";
if ( exists $ENV{"DEBUG_mkinstaller"}) {
   $valueOfDebugVar = $ENV{"DEBUG_mkinstaller"};
}
elsif ( exists $ENV{"DEBUG"}) {
   $valueOfDebugVar = $ENV{"DEBUG"};
}
else {
   $valueOfDebugVar = "";
}
if ($valueOfDebugVar ne "") {
   my $pathname  = $valueOfDebugVar;
   if ($pathname eq "") {
      $debugging        = 0;
      $dbgOutToPathname = "";
   }
   elsif ($pathname =~ /^\s*0\s*$/) {
      $debugging        = 0;
      $dbgOutToPathname = "";
   }
   elsif ($pathname =~ /^\s*(\d+)\s*$/) {
      $debugging        = 1;
      *DBGOUT           = STDERR;
      $dbgOutToPathname = "";
   }
   else {
      if ( ! open(DBGOUT,"> $pathname")) {
         print STDERR "mkinstaller: error: can't send debugging output to \"".pKit_nativePathname($pathname)."\"\n"; # can't send to DBGOUT
         exit 1;
      }
      $debugging        = 1;
      $dbgOutToPathname = $pathname;
   }
}

#$debugging        = 1;
#*DBGOUT           = STDERR;
#$dbgOutToPathname = "";
#
#-------------------------------------------------------------------------------
#
#  Initialization...
#
#-------------------------------------------------------------------------------

{
   #------------------------------------
   #
   #  Locals...
   #
   #------------------------------------

   print DBGOUT "mkinstaller: initialization...\n" if $debugging;

   my $TstartOverall                   = time();

   my $Contact                         = "";
   my %check_prog_isSupported          = ( );
   my %check_prog_pathname             = ( );

#  my $CC_basename                     = ""; # start off as undefined
#  my $CC_optionGiven                  = ""; #   :
#  my $CC_options                      = "";
#  my $CC_pathname                     = "";
   my $CC_version                      = "";
   my $CC_libc_pathname                = "";
   my $CC_libc_version                 = "";
   my @CC_libc_verList                 = ( );
   my $CC_libc_XversionX               = "";

#  my $CXX_basename                    = ""; # start off as undefined
#  my $CXX_optionGiven                 = ""; #   :
#  my $CXX_options                     = "";
#  my $CXX_pathname                    = "";
   my $CXX_version                     = "";
   my $CXX_stdcxxlib_pathname          = "";
   my @CXX_stdcxxlib_verList           = ( );
   my $CXX_stdcxxlib_version           = "";
   my @CXX_stdcxxlib_abiVerList        = ( );
   my $CXX_stdcxxlib_abiVersion        = "";
   my $CXX_stdcxxlib_libcVersion       = "";
   my @CXX_stdcxxlib_libcVerList       = ( );

   my %adjustedStuff                   = ( );
   my $defaultPrefix                   = "";
   my $devNull                         = pKit_nullPathname();
   my %dirBasenames                    = ( );
   my @dirBasenames                    = ( );
   my %dirPathnames                    = ( );
   my @dirPathnames                    = ( );
   my $dirPathnameCount                = 0;
   my %exclusions                      = ( );
   my @exclusions                      = ( );
   my %fileBasenames                   = ( );
   my @fileBasenames                   = ( );
   my $fileBasenameCount               = 0;
   my %filePathnames                   = ( );
   my @filePathnames                   = ( );
   my $filePathnameCount               = 0;
   my $fillMode                        = -1; # Will be set to 0 or 1
   my $followSymlinks                  = 0;
   my $ForProject                      = "";
   my $genSHA                          = 0;
   my $GenTime                         = "";
   my $givenNonStdNames                = 0;
   my %givenPathnames                  = ( );
   my @givenPathnames                  = ( );
   my $givenStdNames                   = 0;
   my $haveExclusions                  = 0;
   my $here                            = pKit_getWorkingDirectory();
   my $HWname                          = "";
   my $intermediateName                = "";
   my $isCompressed                    = "";
   my $keep                            = 0;
   my $keepOpt                         = "";
   my $libDirBasename                  = "";
   my $NadjustedStuff                  = 0;
   my $oldOSname                       = ""; # Only for backwards compatibility
   my $OSname                          = lc $^O;
   my $OSversion                       = "";
   my $postInstallBasename             = "";
   my $postInstallPathname             = "";
   my $postInstallStyle                = "";
   my $preInstallBasename              = "";
   my $preInstallPathname              = "";
   my $preInstallStyle                 = "";
   my $ProjectName                     = "";
   my $ProjectVer                      = "";  # Set by --project-version option
   my $ProjectVerMajor                 = "";
   my $ProjectVerMinor                 = "";
   my $ProjectVerBuild                 = "";
   my $ProjectVerPatch                 = "";
   my $ProjectVerSuffix                = "";
   my $scriptName                      = "";
   my $scriptNameU                     = "";
   my $SCRIPTNAME                      = "";
   my $SCRIPTNAME_TMPDIR               = "";
   my $slash                           = "";
   my $stdMode                         = 0;
   my $tarIsGNUtar                     = -1;
   my $theCommandLine                  = "";
   my @theCommandLine                  = ( );
   my @theNotice                       = ( );
   my $somethingGiven                  = 0;
   my $titleLine                       = "";
   my $TmpDir                          = "";
   my $TmpDirA                         = "";
   my $TmpDirF                         = "";
   my $TmpDirI                         = "";
   my $TmpDirT                         = "";
   my $TmpDirW                         = "";
   my $TmpFile                         = "";
   my $TmpFileE                        = "";
   my %toldSharedDirBasename           = ( );
   my $use_cp                          = "";
   my $use_gzcat                       = "";
   my $use_gzip                        = "";
   my $use_hasher                      = "";
   my $use_hasherOpt                   = "";
   my $use_hasher                      = "";
   my $use_ls                          = "";
   my $use_makensis                    = "";
   my $use_mkinstaller                 = "";
   my $use_pshaw                       = "";
   my $use_shaNNNsum                   = "";
   my $use_tar                         = "";
   my $use_uname                       = "";
   my $verbosityLevel                  = 0;
   my %withFileBasenames               = ( );
   my @withFileBasenames               = ( );
   my %withFilePathnames               = ( );
   my @withFilePathnames               = ( );
   my $withFilePathnameCount           = 0;
   my $withFiles                       = 0;
   my $withNotice                      = "";
   my $withPayload                     = 1;

   my $OSclass                         = pKit_getOSclass();
   my $myPATH                          = pKit_getTheSearchPATH();
   my @myPATH                          = pKit_splitTheSearchPATH($myPATH,$OSclass);

   if ( exists $ENV{"INEFFECTIVE_mkinstaller"}) {
      $withPayload                     = 0;
   }

   if ($OSclass eq "UNIX-like") {
      $slash                           = "/";
   }
   elsif ($OSclass eq "Windows-like") {
      $slash                           = "\\";
   }
   else {
      print STDERR "mkinstaller: fatal: host doesn't appear either UNIX-like nor Windows-like\n";
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
      close DBGOUT if $dbgOutToPathname ne "";
      exit 1;
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #---------------------------------------
   #
   #  If the command has a directory
   #  component, add it to PATH. Under
   #  special conditions we'll skip this
   #  work (paying for it later).
   #
   #---------------------------------------

   if (pKit_suffix($theCommand) ne ".perl") {
      print DBGOUT "mkinstaller: locate [$theCommand]...\n" if $debugging;
      if (pKit_basename($theCommand) ne $theCommand) {
         $foundInDir = pKit_dirname($theCommand);
         if ($foundInDir eq "") {
            print STDERR "mkinstaller: can't determine where \"$theCommand\" is located, can't isolate directory\n";
            errorExit();
         }
         if ( exists $ENV{'PATH'} ) {
            if ( ! pKit_alreadyOnSearchPATH($foundInDir,\@myPATH)) {
               @myPATH      = pKit_prependToSearchPATH($foundInDir,\@myPATH);
               $myPATH      = pKit_joinTheSearchPATH(\@myPATH);
               $ENV{'PATH'} = $myPATH;
            }
         }
         else {
            $ENV{'PATH'} = $foundInDir;
         }
         $use_mkinstaller = $theCommand;
      }
      else {
         if ( ! exists $ENV{'PATH'} ) {
            print STDERR "mkinstaller: can't determine where \"$theCommand\" is located, PATH not set\n";
            errorExit();
         }
         my $lookingFor;
         if ($OSclass eq "UNIX-like") {
            $lookingFor   = "mkinstaller".$TBG_PERL_EXT;
         }
         elsif ($OSclass eq "Windows-like") {
            $lookingFor   = "mkinstaller".$TBG_X_EXT;
         }
         $use_mkinstaller = pKit_lookForExecutable($lookingFor,\@myPATH,$osClass);
         if ($use_mkinstaller ne "") {
            $foundInDir = pKit_dirname($use_mkinstaller);
         }
         if ( ! $foundInDir) {
            print STDERR "mkinstaller: can't determine where \"$theCommand\" is located, is on PATH\n";
            errorExit();
         }
      }
      print DBGOUT "mkinstaller: ...found in [$foundInDir]...\n" if $debugging;
   }

   #----------------------------------------------------------------------------
   #
   #  Now that we've found where this command is located, and if we're on a
   #  SunOS or Solaris system we can add /usr/xpg6/bin and /usr/xpg4/bin to
   #  the command search path (if they exist of course). Of course we may have
   #  to re-form both $myPATH and @mypath.
   #
   #  Solaris/SunOS systems are of course UNIX-like hosts.
   #
   #----------------------------------------------------------------------------

   {
      print DBGOUT "mkinstaller: adjust PATH if necessary\n" if $debugging;
      my $os = lc $^O;
      if (($os =~ /^sunos/) || ($os =~ /^solaris/)) {
         print DBGOUT "mkinstaller: ...is SunOS or Solaris\n" if $debugging;
         my $changed = 0;
         if ( exists $ENV{'PATH'} ) {
            $myPATH      = $ENV{'PATH'};
            my $tryPath  = "/usr/xpg4/bin";
            if ( -d $tryPath) {
               print DBGOUT "mkinstaller:    prepend \"$tryPath\"\n" if $debugging;
               $myPATH   = $tryPath.":".$myPATH;
               $changed  = 1;
            }
            $tryPath     = "/usr/xpg6/bin";
            if ( -d $tryPath) {
               print DBGOUT "mkinstaller:    prepend \"$tryPath\"\n" if $debugging;
               $myPATH   = $tryPath.":".$myPATH;
               $changed  = 1;
            }
            if ($changed) {
               @myPATH     = split /:/, $myPATH;
               if ($debugging) {
                  print DBGOUT "mkinstaller: ...PATH is now:\n" if $debugging;
                  my $i;
                  for ($i=0; $i<=$#myPATH; $i+=1) {
                     my $dir = $myPATH[$i];
                     print DBGOUT "mkinstaller:    \"".$dir."\"\n" if $debugging;
                  }
               }
               $ENV{'PATH'} = $myPATH;
            }
         }
      }
   }

   #----------------------------------------------------------------------------
   #
   #  Process command line...
   #
   #  First take stuff from OPTS_mkinstaller
   #  environment variable and put it at the
   #  start of the command line...
   #
   #----------------------------------------------------------------------------

   if ( exists $ENV{'OPTS_mkinstaller'} ) {
      print DBGOUT "mkinstaller: deal with OPTS_mkinstaller...\n" if $debugging;
      my $tmp = $ENV{'OPTS_mkinstaller'};
      if ($tmp ne "") {
         my @tmp = split /\s/, $tmp;
         my $i;
         for ($i=$#tmp; 0<=$i; $i-=1) {
            unshift @ARGV, $tmp[$i];
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
   }

   #---------------------------------------
   #
   #  Then step through the command line...
   #
   #---------------------------------------

   {
      print DBGOUT "mkinstaller: process command line...\n" if $debugging;
      my $cmdIdx               = 0;
      $theCommandLine[$cmdIdx] = pKit_nativePathname($rawCommand);
      my $i;
      for ($i=0; $i<=$#ARGV; $i+=1) {
         my $opt                   = $ARGV[$i];
         print DBGOUT "mkinstaller: ...found \"$opt\"\n" if $debugging;
         $cmdIdx                  += 1;
         $theCommandLine[$cmdIdx]  = $opt;
         $_      = $opt;
         parseArgs: {
                       #---------------------------------------
                       #
                       #  Standard options...
                       #
                       #---------------------------------------

                       /^--help$/

                          && do {
                             help();
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 0;
                          };

                       /^--html$/

                          && do {
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: error: missing argument to $opt option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $given                = $ARGV[$i];
                             print DBGOUT "mkinstaller:    with \"".pKit_nativePathname($given)."\"\n" if $debugging;
                             $theCommandLine[$cmdIdx] = $theCommandLine[$cmdIdx]." ".pKit_quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: empty argument to $opt option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             html($given);
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 0;
                          };

                       /^--vernum$/

                          && do {
                             print STDOUT "$mkinstaller_ver_name\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 0;
                          };

                       /^--version$/

                          && do {
                             print STDOUT "mkinstaller: version $mkinstaller_ver_name rev. $mkinstaller_ver_time\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 0;
                          };

                       /^--copyright$/

                          && do {
                             copyright();
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 0;
                          };

                       #---------------------------------------
                       #
                       #  Non-standard options...
                       #
                       #---------------------------------------

                       /^-c$/

                          && do {
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: error: missing argument to $opt option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $given                = $ARGV[$i];
                             print DBGOUT "mkinstaller:    with \"".pKit_nativePathname($given)."\"\n" if $debugging;
                             $theCommandLine[$cmdIdx] = $theCommandLine[$cmdIdx]." ".pKit_quoteIfReqd($given);
                             my $bn                   = pKit_basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to ".$opt." option\n";
                                print STDERR "mkinstaller: ..script name must be simple; without directory components\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($scriptName ne "") {
                                print STDERR "mkinstaller: error: unexpected $opt \"".$given."\"\n";
                                print STDERR "mkinstaller: ...already specified name of generated script as \"".$scriptName."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = pKit_suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error: invalid argument(=\"".$given."\" to ".$opt." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                             }
                             $scriptName = $given;
                             print DBGOUT "mkinstaller:    ...script name is \"".pKit_nativePathname($scriptName)."\"\n" if $debugging;
                             last parseArgs;
                          };

                       #
                       #  The --cc[=<name>] option has been deprecated.
                       #

                       /^--cc$/

                          && do {
                             print STDERR "mkinstaller: error: the --cc=... option has been obsoleted. Use the\n";
                             print STDERR "mkinstaller:    CC=... and CC-options=... instead.\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--cc)=(.*)$/

                          && do {
                             print STDERR "mkinstaller: error: the --cc=... option has been obsoleted. Use the\n";
                             print STDERR "mkinstaller:    CC=... and CC-options=... instead.\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^--contact$/

                          && do {
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--contact)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    aka. $optName option\n" if $debugging;
                             print DBGOUT "mkinstaller:    with [$given]\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($Contact ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $Contact = $given;
                             print DBGOUT "mkinstaller:    ...contact [$Contact]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--create$/

                          && do {
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--create)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    aka. $optName option\n" if $debugging;
                             print DBGOUT "mkinstaller:    with [$given]\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $bn      = pKit_basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\" to ".$opt." option\n";
                                print STDERR "mkinstaller: ..script name must be simple\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($scriptName ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = pKit_suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to ".$opt." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                             }
                             $scriptName = $given;
                             print DBGOUT "mkinstaller:       script name is \"$scriptName\"\n" if $debugging;
                             last parseArgs;
                          };

                       #
                       #  The --cxx[=<name>] option has been deprecated.
                       #

                       /^--cxx$/

                          && do {
                             print STDERR "mkinstaller: error: the --cxx=... option has been obsoleted. Use the\n";
                             print STDERR "mkinstaller:    CXX=... and CXX-options=... instead.\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--cxx)=(.*)$/

                          && do {
                             print STDERR "mkinstaller: error: the --cxx=... option has been obsoleted. Use the\n";
                             print STDERR "mkinstaller:    CXX=... and CXX-options=... instead.\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^--debug$/

                          && do {
                             if ( ! $debugging) {
                                $debugging        = 1;
                                *DBGOUT           = STDERR;
                                $dbgOutToPathname = "";
                             }
                             last parseArgs;
                          };

                       /^(--debug)=$/

                          && do {
                             my $optName = $1;
                             print STDERR "mkinstaller: error: missing pathname argument to $optName option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--debug)=(.+)$/

                          && do {
                             my $optName     = $1;
                             my $pathname    = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    aka. $optName option\n" if $debugging;
                             print DBGOUT "mkinstaller:    with [$pathname]\n" if $debugging;
                             if ( ! $debugging) {
                                if ( ! open(DBGOUT,"> $pathname")) {
                                   print STDERR "mkinstaller: error: can't send debugging output to \"".pKit_nativePathname($pathname)."\"\n"; # can't send to DBGOUT
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                $debugging        = 1;
                                $dbgOutToPathname = $pathname;
                             }
                             last parseArgs;
                          };

                       /^(--default-prefix)$/

                          && do {
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: error: missing argument to $opt option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $given      = $ARGV[$i];
                             print DBGOUT "mkinstaller:    with \"".pKit_nativePathname($given)."\"\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length pathname argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $defaultPrefix = $given;
                             last parseArgs;
                          };

                       /^(--default-prefix)=$/

                          && do {
                             my $optName     = $1;
                             print STDERR "mkinstaller: error: missing or zero-length pathname argument to $optName option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--default-prefix)=(.+)$/

                          && do {
                             my $optName    = $1;
                             my $pathname   = pKit_unquote($2);
                             if ($pathname eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length pathname argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $defaultPrefix = $pathname;
                             last parseArgs;
                          };

                       /^--follow$/

                          && do {
                             $followSymlinks = 1;
                             last parseArgs;
                          };

                       /^--exclude=?$/

                          && do {
                             my $optName = $1;
                             print STDERR "mkinstaller: error: missing argument to $optName option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--exclude)=(.+)$/

                          && do {
                             my $optName     = $1;
                             my $given       = $2;
                             my $globPattern = pKit_unquote($given);
                             print DBGOUT "mkinstaller:    aka. $optName option\n" if $debugging;
                             print DBGOUT "mkinstaller:    with [$globPattern]\n" if $debugging;
                             if ($globPattern eq "") {
                                print STDERR "mkinstaller: error: empty argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $bn          = pKit_basename($globPattern);
                             if ($globPattern ne $bn) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$globPattern."\") to ".$optName." option\n";
                                print STDERR "mkinstaller: ...pattern must be simple; without directory components\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $pattern     = pKit_translateGlobPatternToRegExp($globPattern);
                             if ($pattern eq "") {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$globPattern."\") to ".$optName." option\n";
                                print STDERR "mkinstaller: ...\"".$globPattern."\" is not a valid globbing pattern\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ( ! exists $exclusions{$pattern}) {
                                my $idx               = $#exclusions + 1;
                                $exclusions[$idx]     = $pattern;
                                $exclusions{$pattern} = $idx;
                                $haveExclusions       = 1;
                             }
                             else {
                                print STDERR "mkinstaller: note: redundant ".$optName."=".$given." is ignored\n";
                             }
                             last parseArgs;
                          };

                       /^--fill$/

                          && do {
                             if ($fillMode != 1) {
                                $fillMode    = 1;
                                if ($OSclass eq "UNIX-like") {
                                   print STDERR "mkinstaller: note: the $opt option is not required on UNIX-like systems\n";
                                }
                             }
                             last parseArgs;
                          };

                       /^((-hw)|(--hwtype))=?$/

                          && do {
                             my $optName = $1;
                             print STDERR "mkinstaller: error: missing argument to $optName option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^((-hw)|(--hwtype))=(.+)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($3);
                             print DBGOUT "mkinstaller:    aka. $optName option\n" if $debugging;
                             print DBGOUT "mkinstaller:    with [$given]\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: empty argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($HWtype ne "") {
                                print STDERR "mkinstaller: error: already specified $optName=".pKit_quoteIfReqd($HWtype)."\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $HWtype = $given;
                             last parseArgs;
                          };

                       /^((-k)|(--keep))$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $keep           = 1;
                             $keepOpt        = $opt;
                             last parseArgs;
                          };

                       #- - - - - - - - - - - - - - - - - - - -
                       #
                       #  Note: The --intermediate-dir option is almost
                       #        identical to the --version-dir option
                       #        option, the only actual difference is
                       #        in the error and debugging messages.
                       #

                       /^(--intermediate-dir)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $bn          = pKit_basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to ".$optName." option\n";
                                print STDERR "mkinstaller: ...intermediate directory name must be simple; without directory components\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($intermediateName ne "") {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                print STDERR "mkinstaller: ...already specified name of intermediate directory name as \"".$intermediateName."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = pKit_suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to ".$optName." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                             }
                             $intermediateName = $given;
                             print DBGOUT "mkinstaller:       version directory name is \"$intermediateName\"\n" if $debugging;
                             last parseArgs;
                          };

                       /^--is-gnu-tar$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $tarIsGNUtar    = 1;
                             last parseArgs;
                          };

                       /^--nofill$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($fillMode != 0) {
                                $fillMode    = 0;
                             }
                             last parseArgs;
                          };

                       /^--nofollow$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $followSymlinks = 0;
                             last parseArgs;
                          };

                       /^--nokeep$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $keep           = 0;
                             $keepOpt        = $opt;
                             last parseArgs;
                          };

                       /^--nosha$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $genSHA         = 0;
                             last parseArgs;
                          };

                       /^--nonstd$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $stdMode        = 0;
                             last parseArgs;
                          };

                       /^--not-gnu-tar$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $tarIsGNUtar    = 0;
                             last parseArgs;
                          };

                       /^--os$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine[$cmdIdx] = $theCommandLine[$cmdIdx]." ".pKit_quoteIfReqd($given);
                             print STDERR "mkinstaller: note: the --os option is obsolete and is ignored\n";
                             if ($oldOSname ne "") {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $oldOSname = "unknown";
                             if ($OSname ne "") {
                                print STDERR "mkinstaller: ...the OS has been automatically detected as: \"$OSname\"\n";
                             }
                             last parseArgs;
                          };

                       /^(--os)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($oldOSname ne "") {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $oldOSname = $given;
                             print DBGOUT "mkinstaller:    ...OS name [$oldOSname]\n" if $debugging;
                             print STDERR "mkinstaller: note: the --os=... option is obsolete and is ignored\n";
                             if ($OSname ne "") {
                                print STDERR "mkinstaller: ...the OS has been automatically detected as: \"$OSname\"\n";
                             }
                             last parseArgs;
                          };

                       /^--postinstall-bin$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--postinstall-bin)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = pKit_basename($postInstallPathname);
                             $postInstallStyle    = "binary";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($postInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...binary post-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--postinstall-perl$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--postinstall-perl)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = pKit_basename($postInstallPathname);
                             $postInstallStyle    = "perl";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($postInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...perl post-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--postinstall-python$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--postinstall-python)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = pKit_basename($postInstallPathname);
                             $postInstallStyle    = "python";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($postInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...python post-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--postinstall-sh$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--postinstall-sh)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = pKit_basename($postInstallPathname);
                             $postInstallStyle    = "sh";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($postInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...shell post-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-bin$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--preinstall-bin)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = pKit_basename($preInstallPathname);
                             $preInstallStyle    = "binary";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($preInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...binary pre-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-perl$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--preinstall-perl)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = pKit_basename($preInstallPathname);
                             $preInstallStyle    = "perl";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($preInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...perl pre-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-python$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--preinstall-python)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = pKit_basename($preInstallPathname);
                             $preInstallStyle    = "python";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($preInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...python pre-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-sh$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--preinstall-sh)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = pKit_basename($preInstallPathname);
                             $preInstallStyle    = "sh";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error: can't extract basename of \"".pKit_nativePathname($preInstallPathname)."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             print DBGOUT "mkinstaller:    ...shell pre-install script\n" if $debugging;
                             print DBGOUT "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print DBGOUT "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print DBGOUT "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--(prjnam|project-name)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--(prjnam|project-name))=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($3);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($ProjectName ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $ProjectName = $given;
                             print DBGOUT "mkinstaller:    ...project name [$ProjectName]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--(prjver|project-version)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt option\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^(--(prjver|project-version))=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($3);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($ProjectVer ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"$given\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ( ! ($given =~ /^\d+(\.\d+(\.\d+(\.(\d+))?)?)?(\D\S*)?$/)) {
                                print STDERR "mkinstaller: error: invalid argument(=$given) to $optName option\n";
                                print STDERR "mkinstaller: ...expected something of the form:\n";
                                print STDERR "mkinstaller:\n";
                                print STDERR "mkinstaller:    $optName=A[.B[.C[.D]]][S]\n";
                                print STDERR "mkinstaller:\n";
                                print STDERR "mkinstaller:    where A, B, C, and D are sequences of 1 or more digits each (B,\n";
                                print STDERR "mkinstaller:    C, D are optional and S is an optional string which may not\n";
                                print STDERR "mkinstaller:    start with a digit and may not contain spaces and/or tabs.\n";
                                print STDERR "mkinstaller:\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $ProjectVerMajor  = $given; $ProjectVerMajor  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$1/;
                             $ProjectVerMinor  = $given; $ProjectVerMinor  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$2/;
                             $ProjectVerBuild  = $given; $ProjectVerBuild  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$3/;
                             $ProjectVerPatch  = $given; $ProjectVerPatch  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$5/;
                             $ProjectVerSuffix = $given; $ProjectVerSuffix =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$6/;
                             $ProjectVer       = $given;
                             print DBGOUT "mkinstaller:    ...project version [$ProjectVer]\n" if $debugging;
                             print DBGOUT "mkinstaller:              major is [$ProjectVerMajor]\n" if $debugging;
                             print DBGOUT "mkinstaller:              minor is [$ProjectVerMinor]\n" if $debugging;
                             print DBGOUT "mkinstaller:              build is [$ProjectVerBuild]\n" if $debugging;
                             print DBGOUT "mkinstaller:              patch is [$ProjectVerPatch]\n" if $debugging;
                             print DBGOUT "mkinstaller:             suffix is [$ProjectVerSuffix]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--sha-?([1-9][0-9]*)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $given       = $1;
                             my $oldGenSHA   = genSHA ;
                             if (($given eq "1") || ($given eq "160")) {
                                $genSHA = 1;
                             }
                             elsif ($given eq "256") {
                                $genSHA = 256;
                             }
                             elsif ($given eq "384") {
                                $genSHA = 384;
                             }
                             elsif ($given eq "512") {
                                $genSHA = 512;
                             }
                             else {
                                print STDERR "mkinstaller: error: unknown option \"".$opt."\"\n";
                                print STDERR "mkinstaller: ...did you mean: --sha-1, --sha-160, --sha-256, --sha-384, or --sha-512?\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($oldGenSHA != 0) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             last parseArgs;
                          };

                       /^--std$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $stdMode        = 1;
                             last parseArgs;
                          };

                       #- - - - - - - - - - - - - - - - - - - -
                       #
                       #  Note: The --version-dir option is almost
                       #        identical to the --intermediate-dir
                       #        option, the only actual difference is
                       #        in the error and debugging messages.
                       #

                       /^(--version-dir)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: missing or zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $bn          = pKit_basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to ".$optName." option\n";
                                print STDERR "mkinstaller: ...version directory name must be simple; without directory components\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($intermediateName ne "") {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                print STDERR "mkinstaller: ...already specified name of version directory name as \"".$intermediateName."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = pKit_suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to ".$optName." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                             }
                             $intermediateName = $given;
                             print DBGOUT "mkinstaller:       version directory name is \"".pKit_nativePathname($intermediateName)."\"\n" if $debugging;
                             last parseArgs;
                          };

                       /^-w$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: error: missing argument to $opt option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             my $given                = $ARGV[$i];
                             $theCommandLine[$cmdIdx] = $theCommandLine[$cmdIdx]." ".pKit_quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: zero-length argument to $opt option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($withNotice ne "") {
                                print STDERR "mkinstaller: error: unexpected $opt \"".$given."\"\n";
                                print STDERR "mkinstaller: ...already file containing payload copyright notice as \"".$withNotice."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ( ! -f $given) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to $opt option\n";
                                if ( -e $given) {
                                   print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a file\n";
                                }
                                else {
                                   print STDERR "mkinstaller: ...can't find/read \"".$given."\"\n";
                                }
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 0;
                             }
                             if ( ! -T $given) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to $opt option\n";
                                print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a textfile\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $withNotice = $given;
                             @theNotice  = pKit_slurpPathnameIntoArray($withNotice,"mkinstaller");
                             last parseArgs;
                          };

                       /^(--with-notice)=(.+)$/

                          && do {
                             my $optName     = $1;
                             my $given       = pKit_unquote($2);
                             $given          = pKit_absoluteOf($given);
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error: zero-length argument to $optName option\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($withNotice ne "") {
                                print STDERR "mkinstaller: error: unexpected $optName=\"".$given."\"\n";
                                print STDERR "mkinstaller: ...already file containing payload copyright notice as \"".$withNotice."\"\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ( ! -f $given) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to $optName option\n";
                                if ( -e $given) {
                                   print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a file\n";
                                }
                                else {
                                   print STDERR "mkinstaller: ...can't find/read \"".$given."\"\n";
                                }
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 0;
                             }
                             if ( ! -T $given) {
                                print STDERR "mkinstaller: error: invalid argument(=\"".$given."\") to $optName option\n";
                                print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a textfile\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $withNotice = $given;
                             @theNotice  = pKit_slurpPathnameIntoArray($withNotice,"mkinstaller");
                             last parseArgs;
                          };

                       /^--with-payload$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $withPayload    = 1;
                             last parseArgs;
                          };

                       /^--(with-([^-]+)-file)=(.+)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $bn          = $2;
                             my $given       = $3;
                             my $absname     = pKit_absoluteOf($given);
                             my $adjusted;
                             if ( -l $absname) {
                                if ( ! -e $absname) {
                                   print STDERR "mkinstaller: error: \"$given\" is a broken symbolic-link\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                $adjusted    = pKit_realpath($absname);
                                print STDERR "mkinstaller: note: \"$given\" is a symbolic-link, followed to \"$adjusted\"\n";
                             }
                             else {
                                $adjusted    = $absname;
                             }
                             print DBGOUT "mkinstaller:    ...dirname  = \"".pKit_nativePathname($bn)."\"\n" if $debugging;
                             print DBGOUT "mkinstaller:    ...pathname = \"".pKit_nativePathname($adjusted)."\"\n" if $debugging;
                             if ( -f $adjusted) {
                                if ( exists $withFilePathnames{$adjusted}) {
                                   print STDERR "mkinstaller: error: unexpected $opt\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                print DBGOUT "mkinstaller:    ...a file\n" if $debugging;
                                if ($bn =~ /[\s\/\\]/) {
                                   print STDERR "mkinstaller: error: $optName= contains spaces, tabs, and/or slashes\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                $withFilePathnames{$adjusted} = $bn;
                                if ( ! exists $withFileBasenames{$bn}) {
                                   print DBGOUT "mkinstaller:       new basename \"$bn\"\n" if $debugging;
                                   my $jdx                              = $#withFileBasenames + 1;
                                   $withFileBasenames[$jdx]             = $bn;
                                   $withFileBasenames{$bn}{"pathnames"} = [ ];
                                   $withFileBasenames{$bn}{"indices"}   = [ ];
                                   $withFileBasenames{$bn}{"which"}     = $jdx;
                                   $withFileBasenames{$bn}{"count"}     = 0;
                                }
                                else {
                                   print DBGOUT "mkinstaller:       known (file) basename \"$bn\"\n" if $debugging;
                                }
                                my $idx               = $#withFilePathnames + 1;
                                $withFilePathnames[$idx]          = $adjusted;
                                $withFilePathnameCount           += 1;
                                push @{ $withFileBasenames{$bn}{"pathnames"} }, $adjusted;
                                push @{ $withFileBasenames{$bn}{"indices"} },   $idx;
                                $withFileBasenames{$bn}{"count"} += 1;
                                $withFiles                        = 1;
                             }
                             else {
                                if ( -e $adjusted) {
                                   print STDERR "mkinstaller: error: \"".pKit_nativePathname($adjusted)."\" is not a file\n";
                                }
                                else {
                                   print STDERR "mkinstaller: error: can't find/read \"".pKit_nativePathname($adjusted)."\"\n";
                                }
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ( ! $adjustedStuff{$adjusted}) {
                                $adjustedStuff{$adjusted}  = "file";
                                $NadjustedStuff           += 1;
                             }
                             $somethingGiven = 1;
                             last parseArgs;
                          };

                       /^--without-payload$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $withPayload    = 0;
                             last parseArgs;
                          };

                       #---------------------------------------
                       #
                       #  "Semi-standard" options...
                       #
                       #---------------------------------------

                       /^-v$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $verbosityLevel += 1;
                             print DBGOUT "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^-v0$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $verbosityLevel  = 0;
                             print DBGOUT "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^-v([1-9][0-9]*)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $verbosityLevel += $1;
                             print DBGOUT "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^--verbose$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $verbosityLevel += 1;
                             print DBGOUT "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^--verbose0$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $verbosityLevel  = 0;
                             print DBGOUT "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^--verbose([1-9][0-9]*)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             $verbosityLevel += $1;
                             print DBGOUT "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       #---------------------------------------
                       #
                       #  Hybrid options/parameters...
                       #
                       #  NOTE: C/C++ compiler names and
                       #        options are specified as
                       #        parameters of a sort. The
                       #        leading dashes are optional.
                       #        Also that the compiler names
                       #        are required. The C/C++
                       #        compiler options are indeed
                       #        optional
                       #
                       #---------------------------------------

                       /^(--)?CC=?$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt\n";
                             print STDERR "mkinstaller: ...expected C compiler basename\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^((--)?CC=)(.+)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $optName = $1;
                             my $given   = pKit_unquote($3);
                             if ( defined $CC_pathname) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($given =~ /^\s*\[\s*([^,]+)\s*,\s*([^,]+)\s*\]\s*$/) {
                                print DBGOUT "mkinstaller:    ...pair form\n" if $debugging;
                                $CC_pathname = pKit_unquote($1);
                                $CC_basename = pKit_unquote($2);
                                my $bn       = pKit_basename($CC_basename);
                                if ($CC_basename ne $bn) {
                                   print STDERR "mkinstaller: error: improper argument(=\"$given\") to $optName\n";
                                   print STDERR "mkinstaller: ...C compiler name(=$CC_basename) should be simple; without directory components\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                print DBGOUT "mkinstaller:       pathname is \"$CC_pathname\"\n" if $debugging;
                                print DBGOUT "mkinstaller:       basename is \"$CC_basename\"\n" if $debugging;
                             }
                             else {
                                print DBGOUT "mkinstaller:    ...simple form\n" if $debugging;
                                if (pKit_isSimple($given)) {
                                   print DBGOUT "mkinstaller:       with a simple name\n" if $debugging;
                                   $CC_basename = $given;
                                   print DBGOUT "mkinstaller:       ...locate \"$CC_basename\"\n" if $debugging;
                                   $CC_pathname = pKit_lookForExecutable($CC_basename,\@myPATH,$OSclass);
                                   if ($CC_pathname eq "") {
                                      print STDERR "mkinstaller: error: can't locate executable \"$CC_basename\"\n";
                                      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                      close DBGOUT if $dbgOutToPathname ne "";
                                      exit 1;
                                   }
                                }
                                else {
                                   print DBGOUT "mkinstaller:       with a complex name\n" if $debugging;
                                   $CC_pathname = $given;
                                   $CC_basename = pKit_basename($CC_pathname);
                                }
                                print DBGOUT "mkinstaller:       ...pathname is \"$CC_pathname\"\n" if $debugging;
                                print DBGOUT "mkinstaller:       ...basename is \"$CC_basename\"\n" if $debugging;
                             }
                             last parseArgs;
                          };

                       /^((--)?CC-option(s)?=)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ( defined $CC_options) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $CC_options      = "";
                             print DBGOUT "mkinstaller:    using no C compiler options\n" if $debugging;
                             last parseArgs;
                          };

                       /^((--)?CC-option(s)?=)(.+)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $given       = pKit_unquote($4);
                             if ( defined $CC_options) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $CC_options     = $given;
                             $CC_optionGiven = $opt;
                             print DBGOUT "mkinstaller:    using \"$CC_options\" for C compiler options\n" if $debugging;
                             last parseArgs;
                          };

                       /^(--)?CXX=?$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error: missing or zero-length argument to $opt\n";
                             print STDERR "mkinstaller: ...expected C++ compiler basename\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^((--)?CXX=)(.+)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $optName = $1;
                             my $given   = pKit_unquote($3);
                             if ( defined $CXX_pathname) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ($given =~ /^\s*\[\s*([^,]+)\s*,\s*([^,]+)\s*\]\s*$/) {
                                $CXX_pathname = pKit_unquote($1);
                                $CXX_basename = pKit_unquote($2);
                                my $bn        = pKit_basename($CXX_basename);
                                if ($CXX_basename ne $bn) {
                                   print STDERR "mkinstaller: error: improper argument(=\"$given\") to $optName\n";
                                   print STDERR "mkinstaller: ...C++ compiler name(=$CXX_basename) should be simple; without directory components\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                print STDERR "mkinstaller: warning: new \"treat as\" feature isn't well supported yet\n";
                                print STDERR "mkinstaller: ...given \"$CXX_pathname\"\n";
                                print STDERR "mkinstaller:    treated as \"$CXX_basename\"\n";
                             }
                             else {
                                if (pKit_isSimple($given)) {
                                   $CXX_basename = $given;
                                   $CXX_pathname = pKit_lookForExecutable($CXX_basename,\@myPATH,$OSclass);
                                   if ($CXX_pathname eq "") {
                                      print STDERR "mkinstaller: error: can't locate executable \"$CXX_basename\"\n";
                                      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                      close DBGOUT if $dbgOutToPathname ne "";
                                      exit 1;
                                   }
                                }
                                else {
                                   $CXX_pathname = $given;
                                   $CXX_basename = pKit_basename($CXX_pathname);
                                }
                                print DBGOUT "mkinstaller:    using \"$CXX_pathname\" as the C++ compiler\n" if $debugging;
                                print DBGOUT "mkinstaller:    ...treating it as \"$CXX_basename\"\n" if $debugging;
                             }
                             last parseArgs;
                          };

                       /^((--)?CXX-option(s)?=)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             if ( defined $CXX_options) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $CXX_options     = "";
                             print DBGOUT "mkinstaller:    using no C++ compiler options\n" if $debugging;
                             last parseArgs;
                          };

                       /^((--)?CXX-option(s)?=)(.+)$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $given       = pKit_unquote($4);
                             if ( defined $CXX_options) {
                                print STDERR "mkinstaller: error: unexpected $opt\n";
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             $CXX_options     = $given;
                             $CXX_optionGiven = $opt;
                             print DBGOUT "mkinstaller:    using \"$CXX_options\" for C++ compiler options\n" if $debugging;
                             last parseArgs;
                          };

                       #---------------------------------------
                       #
                       #  Unknown options...
                       #
                       #---------------------------------------

                       /^--(.*)$/

                          && do {
                             print STDERR "mkinstaller: error: unknown option \"".$opt."\"\n";
                             my $optName = $1;
                             if (length($optName) == 1) {
                                print STDERR "mkinstaller: ...did you mean -".$optName." or \"./".$opt."\"\n";
                             }
                             elsif (1 <= length($opt)) {
                                print STDERR "mkinstaller: ...did you mean \"./".$opt."\"\n";
                             }
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       /^-(.*)$/

                          && do {
                             print STDERR "mkinstaller: error: unknown option \"".$opt."\"\n";
                             my $optName = $1;
                             if (2 <= length($optName)) {
                                print STDERR "mkinstaller: ...did you mean --".$optName." or \"./".$opt."\"\n";
                             }
                             elsif (1 <= length($opt)) {
                                print STDERR "mkinstaller: ...did you mean \"./".$opt."\"\n";
                             }
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };

                       #---------------------------------------
                       #
                       #  Parameters...
                       #
                       #---------------------------------------

                       /^.+$/

                          && do {
                             print DBGOUT "mkinstaller:    is $opt\n" if $debugging;
                             my $given                = pKit_unquote($opt);
                             $theCommandLine[$cmdIdx] = pKit_quoteIfReqd($given);
                             print DBGOUT "mkinstaller:    ...aka \"".$given."\"\n" if $debugging;
                             my $absname              = pKit_absoluteOf($given);
                             print DBGOUT "mkinstaller:    ...aka \"".$absname."\"\n" if $debugging;
                             my $adjusted;
                             if ( -l $absname) {
                                if ( ! -e $absname) {
                                   print STDERR "mkinstaller: error: \"$given\" is a broken symbolic-link\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                $adjusted             = pKit_realpath($absname);
                                print DBGOUT "mkinstaller:    ...aka \"".$adjusted."\"\n" if $debugging;
                                print STDERR "mkinstaller: note: \"$given\" is a symbolic-link, followed to \"$adjusted\"\n";
                             }
                             else {
                                $adjusted             = $absname;
                             }
                             my $bn                   = pKit_basename($adjusted);
                             if ($bn =~ /\s/) {
                                #---------------------------------------
                                #
                                #  No spaces in basename.
                                #
                                #---------------------------------------
                                if ($bn eq $adjusted) {
                                   print STDERR "mkinstaller: error: \"$adjusted\" contains spaces and/or tabs\n";
                                }
                                else {
                                   print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($adjusted)."\" contains spaces and/or tabs\n";
                                }
                                cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                close DBGOUT if $dbgOutToPathname ne "";
                                exit 1;
                             }
                             if ( -l "$adjusted") {
                                if ( -e "$adjusted") {
                                   print DBGOUT "mkinstaller:    ...a symbolic-link\n" if $debugging;
                                   print STDERR "mkinstaller: error: \"$adjusted\" is a symbolic-link\n";
                                   print STDERR "mkinstaller: ...could not be \"adjusted\" to a pathname without symbolic-links\n";
                                }
                                else {
                                   print DBGOUT "mkinstaller:    ...a broken symbolic-link\n" if $debugging;
                                   print STDERR "mkinstaller: error: \"$adjusted\" is a broken symbolic-link\n";
                                }
                                exit 1;
                             }
                             elsif ( -d "$adjusted") {
                                print DBGOUT "mkinstaller:    ...a directory\n" if $debugging;
                                if ( exists $fileBasenames{$bn}) {
                                   #---------------------------------------
                                   #
                                   #  Files and directories can't share
                                   #  basenames (they'd collide in the
                                   #  prefix directory).
                                   #
                                   #---------------------------------------
                                   print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($adjusted)."\" is known to be a file basename\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                if ( exists $dirPathnames{$adjusted}) {
                                   print STDERR "mkinstaller: warning: unexpected \"$adjusted\"\n";
                                   print STDERR "mkinstaller: ...already specified \"$adjusted\"\n";
                                }
                                else {
                                   if ( exists $dirBasenames{$bn}) {
                                      #---------------------------------------
                                      #
                                      #  Directories can share basenames since
                                      #  they'll merge.
                                      #
                                      #---------------------------------------
                                      if ( ! exists $toldSharedDirBasename{$bn}) {
                                         print STDERR "mkinstaller: note: \"".pKit_nativePathname($adjusted)."\" will be merged with other \"".$bn."\" directories\n";
                                         $toldSharedDirBasename{$bn} = $adjusted;
                                      }
                                   }
                                   if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
                                      print DBGOUT "mkinstaller:       has a standard basename(=$bn)\n" if $debugging;
                                      $adjustedStdNames     = 1;
                                      if ($bn =~ /^lib$/i) {
                                         $libDirBasename = "lib";
                                      }
                                      elsif ($bn =~ /^lib64$/i) {
                                         $libDirBasename = "lib64";
                                      }
                                   }
                                   else {
                                      print DBGOUT "mkinstaller:       has a non-standard basename(=$bn)\n" if $debugging;
                                      $adjustedNonStdNames  = 1;
                                   }
                                   $dirPathnames{$adjusted} = $bn;
                                   if ( ! exists $dirBasenames{$bn}) {
                                      print DBGOUT "mkinstaller:       new basename \"$bn\"\n" if $debugging;
                                      my $jdx                         = $#dirBasenames + 1;
                                      $dirBasenames[$jdx]             = $bn;
                                      $dirBasenames{$bn}{"pathnames"} = [ ];
                                      $dirBasenames{$bn}{"indices"}   = [ ];
                                      $dirBasenames{$bn}{"which"}     = $jdx;
                                      $dirBasenames{$bn}{"count"}     = 0;
                                   }
                                   else {
                                      print DBGOUT "mkinstaller:       known (dir) basename \"$bn\"\n" if $debugging;
                                   }
                                   my $idx                      = $#dirPathnames + 1;
                                   $dirPathnames[$idx]          = $adjusted;
                                   $dirPathnameCount           += 1;
                                   push @{ $dirBasenames{$bn}{"pathnames"} }, $adjusted;
                                   push @{ $dirBasenames{$bn}{"indices"} },   $idx;
                                   $dirBasenames{$bn}{"count"} += 1;
                                   if ( ! $adjustedStuff{$adjusted}) {
                                      $adjustedStuff{$adjusted}    = "directory";
                                      $NadjustedStuff          += 1;
                                   }
                                   $somethingGiven              = 1;
                                }
                             }
                             elsif ( -f "$adjusted") {
                                print DBGOUT "mkinstaller:    ...a file\n" if $debugging;
                                if ($OSclass eq "UNIX-like") {
                                   if ( exists $filePathnames{$adjusted}) {
                                      print STDERR "mkinstaller: warning: unexpected \"$adjusted\"\n";
                                      print STDERR "mkinstaller: ...already specified \"$adjusted\"\n";
                                   }
                                   elsif ( exists $dirBasename{$bn}) {
                                      #---------------------------------------
                                      #
                                      #  Directories and files can't share
                                      #  basenames (they'd collide in the
                                      #  prefix directory).
                                      #
                                      #---------------------------------------
                                      print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($adjusted)."\" is known to be a directory basename\n";
                                      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                      close DBGOUT if $dbgOutToPathname ne "";
                                      exit 1;
                                   }
                                   elsif ( exists $fileBasenames{$bn}) {
                                      #---------------------------------------
                                      #
                                      #  Files can't share basenames since
                                      #  they'd collide in the prefix directory.
                                      #  Remember that directories can share
                                      #  basenames since they'll merge in the
                                      #  prefix directory.
                                      #
                                      #---------------------------------------
                                      print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($adjusted)."\" collides with basename of \"".$fileBasenames{$bn}."\"\n";
                                      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                      close DBGOUT if $dbgOutToPathname ne "";
                                      exit 1;
                                   }
                                   else {
                                      print DBGOUT "mkinstaller:       new (file) basename \"$bn\"\n" if $debugging;
                                      my $idx                = $#fileBasenames + 1;
                                      $fileBasenames[$idx]   = $bn;
                                      $fileBasenames{$bn}    = $adjusted;
                                      my $jdx                = $#filePathnames + 1;
                                      $filePathnames[$jdx]   = $adjusted;
                                      $filePathnames{$adjusted} = $jdx;
                                      $fileBasenameCount    += 1;
                                      if ( ! $adjustedStuff{$adjusted}) {
                                         $adjustedStuff{$adjusted} = "file";
                                         $NadjustedStuff       += 1;
                                      }
                                      $somethingGiven        = 1;
                                   }
                                }
                                elsif ($OSclass eq "Windows-like") {
                                   print STDERR "mkinstaller: error: \"".pKit_nativePathname($adjusted)."\" is a file, this isn't supported on Windows-like hosts (yet)\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                                else {
                                   print STDERR "mkinstaller: error: host isn't UNIX- or Windows-like\n";
                                   cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                   close DBGOUT if $dbgOutToPathname ne "";
                                   exit 1;
                                }
                             }
                             last parseArgs;
                          };

                       /^$/

                          && do {
                             print STDERR "mkinstaller: error: zero-length parameter\n";
                             cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                             close DBGOUT if $dbgOutToPathname ne "";
                             exit 1;
                          };
                    }
      }
      if ($debugging) {
         print DBGOUT "mkinstaller: ...done, found: [".$theCommandLine[0]."]\n";
         my $i;
         for ($i=1; $i<=$#theCommandLine; $i+=1) {
            print DBGOUT "mkinstaller:                 [".$theCommandLine[$i]."]\n";
         }
      }
   }

   #----------------------------------------------------------------------------
   #
   #  Initial announcments...
   #
   #  We want this done as soon as possible, right after the command line has
   #  been processesed.
   #
   #----------------------------------------------------------------------------

   if (1 <= $verbosityLevel) {
      my $FancyStart = pKit_convertTimeToDateTime($TstartOverall,"std","local");
      print STDERR "mkinstaller: version ".$mkinstaller_ver_name." rev. ".$mkinstaller_ver_time."\n";
      print STDERR "mkinstaller: ...the host appears to be \"".pKit_getOSclass()."\" (Perl reported \"".$^O."\")\n";
      print STDERR "mkinstaller:    running \"".pKit_getOSname(3)."\"\n";
      print STDERR "mkinstaller: ...running at \"".$FancyStart."\"\n";
      print STDERR "mkinstaller: ...running within \"".$here."\"\n";
   }

   #---------------------------------------
   #
   #  Collect a scalar version of the command
   #  line.
   #
   #---------------------------------------

   {
      my $i;
      for ($i=0; $i<=$#theCommandLine; $i+=1) {
         my $chunk = $theCommandLine[$i];
         if ($i == 0) {
            $theCommandLine = $chunk;
         }
         else {
            $theCommandLine = $theCommandLine." ".$chunk;
         }
      }
   }

   #----------------------------------------------------------------------------
   #
   #  Before anything else, make sure the various temporary directories are
   #  in place. This will be necessary for converting the individual file
   #  installations in to "normal" directory installations.
   #
   #  Intents: TmpDir  -- The top-level temp directory as supplied by the
   #                      environment. This directory will not be deleted.
   #
   #           TmpDirT -- The top-level directory specific to this run of
   #                      the mkinstaller script. It will be deleted when
   #                      this run is completed (unless the --keep option is
   #                      specified).
   #
   #           TmpDirI -- Individual directories (such as bin/) are tar'd-up
   #                      from their given site into TmpDirI. Are sub-
   #                      directories of $TmpDirT
   #
   #           TmpDirA -- The tarball (bin.tar.gz) is then expanded from the
   #                      into the accumulator directory TmpDirA (overlaying
   #                      what may be there). The tarball in TmpDirI may then
   #                      be deleted. Is a sub-directory of $TmpDirT
   #
   #           TmpDirF -- A directory where artificial installation directories
   #                      containing the individual files to be installed are
   #                      kept. This is how the --with-<name>-file=<pathname>
   #                      option is implemented.
   #
   #           TmpDirW -- The directories (such as bin/) in the accumulator
   #                      directory TmpDirA are then tar'd up in to the wrapper
   #                      directory TmpDirW which is eventually tar'd up as the
   #                      collective payload (wrapper.tar). Is a sub-directory
   #                      of $TmpDirT
   #
   #           TmpFile -- The partially built installer script. To be joined
   #                      with the collective payload to form the installer
   #                      script.
   #
   #  ...and...
   #
   #           TmpFileE -- A temporary file used to capture errors.
   #
   #----------------------------------------------------------------------------

   print DBGOUT "mkinstaller: identify temp directory...\n" if $debugging;
   if ($TmpDir eq "") {
      if ( exists $ENV{'MKINSTALLER_TMPDIR'} ) {
         my $TryTmp = $ENV{'MKINSTALLER_TMPDIR'};
         print DBGOUT "mkinstaller: ...MKINSTALLER_TMPDIR gave \"".pKit_nativePathname($TmpDir)."\"\n" if $debugging;
         if ( -d "$TryTmp") {
            $TmpDir = $TryTmp;
         }
         else {
            print DBGOUT "mkinstaller:    which is not a valid directory\n" if $debugging;
         }
      }
   }
   if ($TmpDir eq "") {
      $TmpDir = pKit_findTempDir("MKINSTALLER_TMPDIR");
      if ($TmpDir eq "") {
         print STDERR "mkinstaller: error: can't decide on a location for a temp directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;
   $TmpDir   = pKit_absoluteOf($TmpDir);
   print DBGOUT "mkinstaller:    use: \"".pKit_nativePathname($TmpDir).$slash."\"\n"  if $debugging;
   $TmpDirT  = "$TmpDir/mki.$$";
   print DBGOUT "mkinstaller:         \"".pKit_nativePathname($TmpDirT).$slash."\"\n" if $debugging;
   $TmpDirA  = "$TmpDirT/accumulator";
   $TmpDirF  = "$TmpDirT/files";
   print DBGOUT "mkinstaller:         \"".pKit_nativePathname($TmpDirA).$slash."\"\n" if $debugging;
   $TmpDirI  = "$TmpDirT/initial";
   print DBGOUT "mkinstaller:         \"".pKit_nativePathname($TmpDirI).$slash."\"\n" if $debugging;
   $TmpDirW  = "$TmpDirT/wrapper";
   print DBGOUT "mkinstaller:         \"".pKit_nativePathname($TmpDirW).$slash."\"\n" if $debugging;
   $TmpFile  = "$TmpDirT/script.tmp";
   print DBGOUT "mkinstaller:         \"".pKit_nativePathname($TmpFile)."\"\n"  if $debugging;
   $TmpFileE = "$TmpDir/mki.$$.err";
   print DBGOUT "mkinstaller:    and: \"".pKit_nativePathname($TmpFileE)."\"\n" if $debugging;

   #---------------------------------------
   #
   #  Prepare temporary directories...
   #
   #---------------------------------------

   print DBGOUT "mkinstaller: prepare temporary directories...\n" if $debugging;
   {
      print DBGOUT "mkinstaller: ...check for \"".pKit_nativePathname($TmpDirT)."\"\n" if $debugging;
      if ( -l $TmpDirT) {
         print STDERR "mkinstaller: error: \"".pKit_nativePathname($TmpDirT)."\" already exists\n";
         if ( -e $TmpDirT) {
            print STDERR "mkinstaller: ...as a symbolic-link\n";
         }
         else {
            print STDERR "mkinstaller: ...as a broken symbolic-link\n";
         }
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      if ( -e $TmpDirT) {
         print STDERR "mkinstaller: error: \"".pKit_nativePathname($TmpDirT)."\" already exists\n";
         if ( -d "$TmpDirT") {
            print STDERR "mkinstaller: ...as a directory\n";
         }
         elsif ( -f $TmpDirT) {
            print STDERR "mkinstaller: ...as a file\n";
         }
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      print DBGOUT "mkinstaller: ...create \"".pKit_nativePathname($TmpDirT)."\"\n" if $debugging;
      if ( ! pKit_mkDirectory($TmpDirT,1)) {
         print STDERR "mkinstaller: error: can't create new \"".pKit_nativePathname($TmpDirT)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      if ( ! -d $TmpDirT) {
         print STDERR "mkinstaller: error: didn't create new \"".pKit_nativePathname($TmpDirT)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      else {
         print DBGOUT "mkinstaller:    now have directory \"".pKit_nativePathname($TmpDirT)."\"\n" if $debugging;
      }
      print DBGOUT "mkinstaller: ...create \"".pKit_nativePathname($TmpDirA)."\"\n" if $debugging;
      if ( ! pKit_mkDirectory($TmpDirA,1)) {
         print STDERR "mkinstaller: error: can't create new \"".pKit_nativePathname($TmpDirA)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      if ( ! -d $TmpDirA) {
         print STDERR "mkinstaller: error: didn't create new \"".pKit_nativePathname($TmpDirA)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      else {
         print DBGOUT "mkinstaller:    now have directory \"".pKit_nativePathname($TmpDirA)."\"\n" if $debugging;
      }
      print DBGOUT "mkinstaller: ...create \"".pKit_nativePathname($TmpDirF)."\"\n" if $debugging;
      if ( ! pKit_mkDirectory($TmpDirF,1)) {
         print STDERR "mkinstaller: error: can't create new \"".pKit_nativePathname($TmpDirF)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      if ( ! -d $TmpDirF) {
         print STDERR "mkinstaller: error: didn't create new \"".pKit_nativePathname($TmpDirF)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      else {
         print DBGOUT "mkinstaller:    now have directory \"".pKit_nativePathname($TmpDirF)."\"\n" if $debugging;
      }
      print DBGOUT "mkinstaller: ...create \"".pKit_nativePathname($TmpDirI)."\"\n" if $debugging;
      if ( ! pKit_mkDirectory($TmpDirI,1)) {
         print STDERR "mkinstaller: error: can't create new \"".pKit_nativePathname($TmpDirI)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      if ( ! -d $TmpDirI) {
         print STDERR "mkinstaller: error: didn't create new \"".pKit_nativePathname($TmpDirI)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      else {
         print DBGOUT "mkinstaller:    now have directory \"".pKit_nativePathname($TmpDirI)."\"\n" if $debugging;
      }
      print DBGOUT "mkinstaller: ...create \"".pKit_nativePathname($TmpDirW)."\"\n" if $debugging;
      if ( ! pKit_mkDirectory($TmpDirW,1)) {
         print STDERR "mkinstaller: error: can't create new \"".pKit_nativePathname($TmpDirW)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      if ( ! -d $TmpDirW) {
         print STDERR "mkinstaller: error: didn't create new \"".pKit_nativePathname($TmpDirW)."\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      else {
         print DBGOUT "mkinstaller:    now have directory \"".pKit_nativePathname($TmpDirW)."\"\n" if $debugging;
      }
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Now that the temporary directories are in place we'll try to determine
   #  just what sort of hardware we're running on.
   #
   #----------------------------------------------------------------------------

   if ($HWtype eq "") {
      if ($OSclass eq "UNIX-like") {
         $HWtype = pKit_idTheHardware();
         if ($HWtype eq "") {
            print STDERR "mkinstaller: error: can't properly identify the hardware\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      else {
         $HWtype = "x86_64";
      }
   }

   #----------------------------------------------------------------------------
   #
   #  More announcments...
   #
   #----------------------------------------------------------------------------

   if (1 <= $verbosityLevel) {
      print STDERR "mkinstaller: ...hardware appears to be \"".$HWtype."\"\n";
      print STDERR "mkinstaller: ...location for temporaries is \"".pKit_nativePathname($TmpDir)."\"\n";
      print STDERR "mkinstaller:       my top temp directory is \"".pKit_nativePathname($TmpDirT)."\"\n";
      if ($ProjectName ne "") {
         print STDERR "mkinstaller: ...project = \"".$ProjectName."\"\n";
         if ($ProjectVer ne "") {
            print STDERR "mkinstaller:    version = \"".$ProjectVer."\"\n";
         }
      }
   }

   #----------------------------------------------------------------------------
   #
   #  Then copy the individual files to be installed (if any) into appropriate
   #  temporary directories. Note that this process works very much like the
   #  way command-line parameters (directories to be installed) are handled
   #  during command line processing above. This effectively "converts" individual
   #  file installations to the expected directory installations.
   #
   #----------------------------------------------------------------------------

   if ($withFiles) {
      print DBGOUT "mkinstaller: copy files to temporary directories (to be installed)...\n" if $debugging;
      if ($use_cp eq "") {
         #---------------------------------------
         #
         #  Locate cp (is required)...
         #
         #---------------------------------------

         print DBGOUT "mkinstaller: ...locate required \"cp\" utility...\n" if $debugging;
         $use_cp = pKit_lookForExecutable("cp",\@myPATH,$OSclass);
         if ($use_cp eq "") {
            print STDERR "mkinstaller: error: can't locate required \"cp\" utility\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         print DBGOUT "mkinstaller:    found \"".pKit_nativePathname($use_cp)."\"\n" if $debugging;
      }
      my $count          = 0;
      my %filesInTmpDirs = ( );
      my $pathname;
      foreach $pathname (sort keys %withFilePathnames) {
         print DBGOUT "mkinstaller: ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
         my $bn = $withFilePathnames{$pathname};
         my $fn = pKit_basename($pathname);
         my $dn = "$TmpDirF/$bn";
         if ( ! -d "$dn") {
            print DBGOUT "mkinstaller:    create \"".pKit_nativePathname($dn)."\"\n" if $debugging;
            if ( ! pKit_mkDirectory($dn,1)) {
               print STDERR "mkinstaller: error: can't create new \"".pKit_nativePathname($dn)."\" directory\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
         }
         print DBGOUT "mkinstaller:    copy \"".pKit_nativePathname($pathname)."\" in to \"".pKit_nativePathname($dn)."/\"\n" if $debugging;
         my $cmd    = "\"".pKit_nativePathname($use_cp)."\" -p \"".pKit_nativePathname($pathname)."\" \"".pKit_nativePathname($dn."/")."\"";
         print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
         my $status = system "( $cmd ) >$devNull 2>&1";
         if ($status != 0) {
            print DBGOUT "mkinstaller:    failed, exit code $status\n" if $debugging;
            print STDERR "mkinstaller: error: can't copy file to temporary directory\n";
            print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
            print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($here)."\"\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         else {
            print DBGOUT "mkinstaller:    succeeded\n" if $debugging;
            if ( ! -f "$TmpDirF/$bn/$fn") {
               print STDERR "mkinstaller: error: didn't copy file to temporary directory\n";
               print STDERR "mkinstaller: ...[$cmd] failed\n";
               print STDERR "mkinstaller: ...can't find \"".pKit_nativePathname($TmpDirF."/".$bn."/".$fn)."\"\n";
               print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($here)."\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
         }
         if ( ! exists $filesInTmpDirs{$dn}) {
            $filesInTmpDirs{$dn} = $bn;
            $count              += 1;
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
      if (0 < $count) {
         print DBGOUT "mkinstaller: \"installing\" the temporary directories...\n" if $debugging;
         my $dn;
         foreach $dn (sort keys %filesInTmpDirs) {
            print DBGOUT "mkinstaller: ...\"".pKit_nativePathname($dn)."\"\n" if $debugging;
            if ( exists $dirPathnames{$dn}) {
               print STDERR "mkinstaller: error: unexpected \"".pKit_nativePathname($dn)."\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            my $bn = pKit_basename($dn);
            if ($bn =~ /\s/) {
               if ($bn eq $dn) {
                  print STDERR "mkinstaller: error: \"".pKit_nativePathname($dn)."\" contains spaces and/or tabs\n";
               }
               else {
                  print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($dn)."\" contains spaces and/or tabs\n";
               }
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
               print DBGOUT "mkinstaller:    has a standard basename(=$bn)\n" if $debugging;
               $givenStdNames     = 1;
               if ($bn =~ /^lib$/i) {
                  $libDirBasename = "lib";
               }
               elsif ($bn =~ /^lib64$/i) {
                  $libDirBasename = "lib64";
               }
            }
            else {
               print DBGOUT "mkinstaller:    has a non-standard basename(=$bn)\n" if $debugging;
               $givenNonStdNames  = 1;
            }
            $dirPathnames{$dn} = $bn;
            if ( ! exists $dirBasenames{$bn}) {
               print DBGOUT "mkinstaller:    ...new (dir) basename \"".pKit_nativePathname($bn)."\"\n" if $debugging;
               my $jdx                         = $#dirBasenames + 1;
               $dirBasenames[$jdx]             = $bn;
               $dirBasenames{$bn}{"pathnames"} = [ ];
               $dirBasenames{$bn}{"indices"}   = [ ];
               $dirBasenames{$bn}{"which"}     = $jdx;
               $dirBasenames{$bn}{"count"}     = 0;
            }
            else {
               print DBGOUT "mkinstaller:    ...known (dir) basename \"".pKit_nativePathname($bn)."\"\n" if $debugging;
            }
            my $idx               = $#dirPathnames + 1;
            $dirPathnames[$idx]   = $dn;
            $dirPathnameCount    += 1;
            push @{ $dirBasenames{$bn}{"pathnames"} }, $dn;
            push @{ $dirBasenames{$bn}{"indices"} },   $idx;
            $dirBasenames{$bn}{"count"} += 1;
         }
         print DBGOUT "mkinstaller: ...done\n" if $debugging;
      }
   }

   #----------------------------------------------------------------------------
   #
   #  The state (what is to be installed)...
   #
   #----------------------------------------------------------------------------

   if ($debugging) {
      print DBGOUT "mkinstaller: what is to be installed\n" if $debugging;
      if (0 <= $#dirPathnames) {
         print DBGOUT "mkinstaller: ...by directory pathnames:\n" if $debugging;
         my $i;
         for ($i=0; $i<=$#dirPathnames; $i+=1) {
            my $pathname = $dirPathnames[$i];
            print DBGOUT "mkinstaller:    \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
         }
      }
      {
         print DBGOUT "mkinstaller: ...by directory basenames:\n" if $debugging;
         my $bn;
         foreach $bn (sort keys %dirBasenames) {
            print DBGOUT "mkinstaller:    \"".pKit_nativePathname($bn)."\"\n" if $debugging;
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  $first = 0;
               }
               else {
                  print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
               }
               if ( -d $pathname) {
                  if (pKit_isDirEmpty($pathname)) {
                     print STDERR "mkinstaller: error: \"".pKit_nativePathname($pathname)."\" is an empty directory\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
               }
               else {
                  print STDERR "mkinstaller: error: \"".pKit_nativePathname($pathname)."\" is not a directory\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
            }
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
   }

   #----------------------------------------------------------------------------
   #
   #  Deal with defaults...
   #
   #----------------------------------------------------------------------------

   print DBGOUT "mkinstaller: deal with defaults...\n" if $debugging;
   {
      if (($fillMode != 0) && ($fillMode != 1)) {
         if ($OSclass eq "Windows-like") {
            if ( ! $fillMode) {
               print STDERR "mkinstaller: warning: it is advisable to use --fill option on Windows-like systems\n";
            }
         }
         $fillMode = 0;
      }
      if ($withPayload) {
         if ( ! $somethingGiven) {
            print STDERR "mkinstaller: error: expected at least 1 directory pathname\n";
            print STDERR "mkinstaller: ...and/or file pathname (via --with-<name>-file=<pathname> option)\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      else {
         if ($somethingGiven) {
            print STDERR "mkinstaller: error: the --without-payload option is incompatible with supplied directories and/or files\n";
            my $first = 1;
            my $given;
            foreach $given (sort keys %adjustedStuff) {
               my $style = $adjustedStuff{$given};
               if ($first) {
                  print STDERR "mkinstaller: ...\"$given\"\n";
                  $first = 0;
               }
               else {
                  print STDERR "mkinstaller:    \"$given\"\n";
               }
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      if ($OSclass eq "UNIX-like") {
#{= cut here ========================================================================================================== cut here ===
         #---------------------------------------
         #
         #  On a UNIX-like host the --CC=... and
         #  the --CXX=... options are required
         #  when bin or lib (or lib64) directories
         #  are installed.
         #
         #---------------------------------------
         print DBGOUT "mkinstaller: ...on a UNIX-like host\n" if $debugging;
         if ( defined $CC_options) {
            print DBGOUT "mkinstaller:    C compiler options were specified (=$CC_options)\n" if $debugging;
            if ( ! defined $CC_pathname) {
               print DBGOUT "mkinstaller:    ...but no C compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: warning: $CC_optionGiven was used but no C compiler was specified\n";
            }
         }
         if ( defined $CXX_options) {
            print DBGOUT "mkinstaller:    C++ compiler options were specified (=$CXX_options)\n" if $debugging;
            if ( ! defined $CXX_pathname) {
               print DBGOUT "mkinstaller:    ...but no C++ compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: warning: $CXX_optionGiven was used but no C++ compiler was specified\n";
            }
         }
         if (( exists $dirBasenames{"bin"}) || ( exists $dirBasenames{"lib"}) || ( exists $dirBasenames{"lib64"})) {
            print DBGOUT "mkinstaller: ...a \"bin\", \"lib\", or \"lib64\" directory was specified\n" if $debugging;
            my $told = 0;
            if ( ! defined $CC_pathname) {
               print DBGOUT "mkinstaller:    ...but no C compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: error - a \"bin\", \"lib\", or \"lib64\" directory was specified\n" if ( ! $told);
               $told = 1;
               print STDERR "mkinstaller: ...but no C compiler was specified\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ( ! defined $CXX_pathname) {
               print DBGOUT "mkinstaller:    ...but no C++ compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: warning - a \"bin\", \"lib\", or \"lib64\" directory was specified\n" if ( ! $told);
               $told = 1;
               print STDERR "mkinstaller: ...but no C++ compiler was specified\n";
            }
         }
         else {
            print DBGOUT "mkinstaller:    no \"bin\", \"lib\", or \"lib64\" directory was specified\n" if $debugging;
            if ( defined $CC_pathname) {
               print DBGOUT "mkinstaller:    ...but a C compiler was specified (as $CC_pathname)\n" if $debugging;
            }
            if ( defined $CXX_pathname) {
               print DBGOUT "mkinstaller:    ...but a C++ compiler was specified (as $CXX_pathname)\n" if $debugging;
            }
         }
         if ( defined $CC_pathname) {
            print DBGOUT "mkinstaller:    a C compiler was specified (as $CC_pathname)\n" if $debugging;
            if ( ! defined $CC_options) {
               print DBGOUT "mkinstaller:    ...but no C compiler options were specified\n" if $debugging;
               $CC_options = "";
            }
         }
         if ( defined $CXX_pathname) {
            print DBGOUT "mkinstaller:    a C++ compiler was specified (as $CXX_pathname)\n" if $debugging;
            if ( ! defined $CXX_options) {
               print DBGOUT "mkinstaller:    ...but no C++ compiler options were specified\n" if $debugging;
               $CXX_options = "";
            }
         }
#}= cut here ========================================================================================================== cut here ===
      }
      if ($ProjectVer ne "") {
         if ($ProjectName eq "") {
            print STDERR "mkinstaller: error: use of --project-version requires use of --project-name\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      if ($OSname eq "") {
         print DBGOUT "mkinstaller: ...identify host OS\n" if $debugging;
         if ($OSclass eq "UNIX-like") {
            print DBGOUT "mkinstaller:    is \"UNIX-like\"\n" if $debugging;
#{= cut here ========================================================================================================== cut here ===
            my $Sreturn = "";
            my $Rreturn = "";
            my $cmd     = "uname -s";
            print DBGOUT "mkinstaller:    run [$cmd]\n" if $debugging;
            my $gives   = `$cmd`;
            my $status  = $? >> 8; chomp $gives; $gives =~ s/\r$//;
            if ($status != 0) {
               print DBGOUT "mkinstaller:    ...failed, exit code $status\n" if $debugging;
               $Sreturn = "";
            }
            else {
               print DBGOUT "mkinstaller:    ...suceeded, giving \"$Sreturn\"\n" if $debugging;
               $Sreturn = $gives;
            }
            $cmd        = "uname -r";
            print DBGOUT "mkinstaller:    run [$cmd]\n" if $debugging;
            $gives      = `$cmd`;
            my $status  = $? >> 8; chomp $gives; $gives =~ s/\r$//;
            if ($status != 0) {
               print DBGOUT "mkinstaller:    ...failed, exit code $status\n" if $debugging;
               $Rreturn = "";
            }
            else {
               print DBGOUT "mkinstaller:    ...suceeded, giving \"$Sreturn\"\n" if $debugging;
               $Rreturn = $gives;
            }
            if ($Sreturn ne "") {
               if ($Rreturn ne "") {
                  $OSname = lc "$Sreturn $Rreturn";
                  print DBGOUT "mkinstaller:    host OS = \"$OSname\"\n" if $debugging;
               }
            }
#}= cut here ========================================================================================================== cut here ===
         }
         elsif ($OSclass eq "Windows-like") {
            print DBGOUT "mkinstaller:    is \"Windows-like\"\n" if $debugging;
            $OSname = lc "Windows";
         }
         else {
            print DBGOUT "mkinstaller:    is neither \"UNIX\" nor \"Windows\" like\n" if $debugging;
            print STDERR "mkinstaller: error: can't identify the class of host\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      if ($scriptName eq "") {
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
               $scriptName = $ProjectName."-".$ProjectVer."-installer";
            }
            else {
               $scriptName = $ProjectName."-installer";
            }
         }
         else {
            $scriptName = "installer";
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
      print DBGOUT "mkinstaller:    scriptName        = \"".pKit_nativePathname($scriptName)."\"\n" if $debugging;

      $scriptNameU       = $scriptName;
      $scriptNameU       =~ tr/\x20-\x7f//cd;
      $scriptNameU       =~ tr/a-zA-Z0-9_/_/c;
      $scriptNameU       =~ s/__+/_/;
      print DBGOUT "mkinstaller:    scriptNameU       = \"".pKit_nativePathname($scriptNameU)."\"\n" if $debugging;

      $SCRIPTNAME        = $scriptNameU;
      $SCRIPTNAME        =~ tr/a-z/A-Z/;
      print DBGOUT "mkinstaller:    SCRIPTNAME        = \"".pKit_nativePathname($SCRIPTNAME)."\"\n" if $debugging;
      $SCRIPTNAME_TMPDIR = $SCRIPTNAME."_TMPDIR";
      print DBGOUT "mkinstaller:    SCRIPTNAME_TMPDIR = \"".pKit_nativePathname($SCRIPTNAME_TMPDIR)."\"\n" if $debugging;
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   if ($genSHA) {
      #---------------------------------------
      #
      #  Locate appropriate hash tool (optional)...
      #
      #---------------------------------------

      print DBGOUT "mkinstaller: locate optional \"pshaw\" utility...\n" if $debugging;
      $use_pshaw = pKit_lookForExecutable("pshaw",\@myPATH,$OSclass);
      if ($use_pshaw eq "") {
         print STDERR "mkinstaller: warning: can't locate optional \"pshaw\" utility\n";
      }
      else {
         print DBGOUT "mkinstaller: ...\"".pKit_nativePathname($use_pshaw)."\"\n" if $debugging;
      }
      print DBGOUT "mkinstaller: locate optional \"shaNNNsum\" utility...\n" if $debugging;
      if ($genSHA == 1) {
         $use_shaNNNsum = pKit_lookForExecutable("sha1sum",\@myPATH,$OSclass);
      }
      elsif ($genSHA == 256) {
         $use_shaNNNsum = pKit_lookForExecutable("sha256sum",\@myPATH,$OSclass);
      }
      elsif ($genSHA == 384) {
         $use_shaNNNsum = pKit_lookForExecutable("sha384sum",\@myPATH,$OSclass);
      }
      elsif ($genSHA == 512) {
         $use_shaNNNsum = pKit_lookForExecutable("sha512sum",\@myPATH,$OSclass);
      }
      else {
         $use_shaNNNsum = ""
      }
      if ($use_shaNNNsum eq "") {
         print STDERR "mkinstaller: warning: can't locate optional \"sha".$genSHA."sum\" utility\n";
      }
      else {
         print DBGOUT "mkinstaller: ...\"".pKit_nativePathname($use_shaNNNsum)."\"\n" if $debugging;
      }
      if ($use_shaNNNsum ne "") {
         $use_hasher    = $use_shaNNNsum;
         $use_hasherOpt = "";
      }
      elsif ($use_pshaw ne "") {
         $use_hasher    = $use_pshaw;
         $use_hasherOpt = " -".$genSHA;
         $use_hasherOpt = "";
      }
      else {
         $use_hasher    = "";
         $use_hasherOpt = "";
         $genSHA        = 0;
         print STDERR "mkinstaller: warning: can't generate a hash file\n";
      }
      if ($use_hasher ne "") {
         print STDERR "mkinstaller: ...using \"".pKit_nativePathname($use_hasher)."\"\n" if (1 <= $verbosityLevel);
      }
   }

   #----------------------------------------------------------------------------
   #
   #  Check if we're running in an empty directory (a good idea but not
   #  required)...
   #
   #----------------------------------------------------------------------------

   print DBGOUT "mkinstaller: check the current directory...\n" if $debugging;
   {
      if (opendir(DIR,"$here")) {
         my $foundSomething = 0;
         while (defined($thisName = readdir(DIR))) {
            if (($thisName ne "" ) && ($thisName ne ".") && ($thisName ne "..")) {
               if ( ! ($thisName =~ /^.my.manifest$/i)) {
                  if ( ! $foundSomething) {
                     print STDERR "mkinstaller: warning: current directory \"".pKit_nativePathname($here)."\" is not empty\n";
                     print STDERR "mkinstaller: ...found: \"".$thisName."\"\n";
                     $foundSomething = 1;
                  }
                  else {
                     print STDERR "mkinstaller:           \"".$thisName."\"\n";
                  }
               }
            }
         }
         closedir(DIR);
      }
      else {
         print STDERR "mkinstaller: warning: can't read contents of \"".pKit_nativePathname($here)."\"\n";
      }
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  If operating in standard mode with no given pathnames with standard
   #  basenames then rebuild the directory hash and list.
   #
   #----------------------------------------------------------------------------

   print DBGOUT "mkinstaller: deal with (non)standard pathnames...\n" if $debugging;
   {
      if ($stdMode) {
         my $rebuilt = 0;
         print DBGOUT "mkinstaller: ...operating in standard mode\n" if $debugging;
         if ( ! $givenStdNames) {
            print DBGOUT "mkinstaller:    but given no pathnames with standard basenames\n" if $debugging;
            if (1 <= $verbosityLevel) {
               print STDERR "mkinstaller: operating in \"standard\" mode but no \"standard basenames\"\n";
               if (2 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...\"bin\", \"lib\", \"lib64\", or \"include\"\n";
               }
            }
            my @allPathnames = ( );
            my $first        = 1;
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
               my $i;
               for ($i=0; $i<=$#dirs; $i+=1) {
                  my $pathname = $dirs[$i];
                  if ($first) {
                     print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                     $first = 0;
                  }
                  else {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  my $idx             = $#allPathnames + 1;
                  $allPathnames[$idx] = $pathname;
               }
            }
            print DBGOUT "mkinstaller:    check each given directory pathname for subdirectories with standard basenames\n" if $debugging;
            my $changed       = 0;
            my $haveStdSubdir = 0;
            my @usePathnames  = ( );
            my $i;
            for ($i=0; $i<=$#allPathnames; $i+=1) {
               my $foundOne = 0;
               my $pathname = $allPathnames[$i];
               if ($i == 0) {
                  print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
               }
               else {
                  print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
               }
               if (opendir(DIR,"$pathname")) {
                  while (defined($tmpName1 = readdir(DIR))) {
                     if (($tmpName1 ne "" ) && ($tmpName1 ne ".") && ($tmpName1 ne "..")) {
                        if (($tmpName1 =~ /^bin$/i) || ($tmpName1 =~ /^lib$/i) || ($tmpName1 =~ /^lib64$/i) || ($tmpName1 =~ /^include$/i)) {
                           $foundOne          = 1;
                           if ($bn =~ /^lib$/i) {
                              $libDirBasename = "lib";
                           }
                           elsif ($bn =~ /^lib64$/i) {
                              $libDirBasename = "lib64";
                           }
                           last;
                        }
                     }
                  }
                  closedir(DIR);
               }
               if ($foundOne) {
                  print DBGOUT "mkinstaller:          has a subdir with a standard basename\n" if $debugging;
                  if (opendir(DIR,"$pathname")) {
                     while (defined($tmpName2 = readdir(DIR))) {
                        if (($tmpName2 ne "" ) && ($tmpName2 ne ".") && ($tmpName2 ne "..")) {
                           my $joinName = pKit_fixpath(pKit_joinpath($pathname,$tmpName2));
                           if ( ! $followSymlinks) {
                              if ( -l $joinName) {
                                 if ( -e $joinName) {
                                    print STDERR "mkinstaller: error: \"".pKit_nativePathname($joinName)."\" is a symbolic-link not a directory\n";
                                 }
                                 else {
                                    print STDERR "mkinstaller: error: \"".pKit_nativePathname($joinName)."\" is a broken symbolic-link not a directory\n";
                                 }
                                 cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                 close DBGOUT if $dbgOutToPathname ne "";
                                 exit 1;
                              }
                           }
                           if (-d $joinName) {
                              my $idx             = $#usePathnames + 1;
                              $usePathnames[$idx] = $joinName;
                              $changed            = 1;
                           }
                        }
                     }
                     closedir(DIR);
                  }
               }
               else {
                  print DBGOUT "mkinstaller:          has no subdirs with a standard basename\n" if $debugging;
                  my $idx             = $#usePathnames + 1;
                  $usePathnames[$idx] = $pathname;
               }
            }
            if ($changed) {
               if (1 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...rebuilding pathname list\n";
               }
               print DBGOUT "mkinstaller:    changed directory pathname list\n" if $debugging;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  else {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
               }
               print DBGOUT "mkinstaller:    rebuild directory pathname hash and list\n" if $debugging;
               $rebuilt          = 1;
               %dirBasenames     = ( );
               @dirBasenames     = ( );
               %dirPathnames     = ( );
               @dirPathnames     = ( );
               $dirPathnameCount = 0;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  else {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  my $bn       = pKit_basename($pathname);
                  if ($bn =~ /\s/) {
                     if ($bn eq $pathname) {
                        print STDERR "mkinstaller: error: \"".pKit_nativePathname($pathname)."\" contains spaces and/or tabs\n";
                     }
                     else {
                        print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($pathname)."\" contains spaces and/or tabs\n";
                     }
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
                     print DBGOUT "mkinstaller:       has a standard basename(=$bn)\n" if $debugging;
                     $givenStdNames     = 1;
                     if ($bn =~ /^lib$/i) {
                        $libDirBasename = "lib";
                     }
                     elsif ($bn =~ /^lib64$/i) {
                        $libDirBasename = "lib64";
                     }
                  }
                  else {
                     print DBGOUT "mkinstaller:       has a non-standard basename(=$bn)\n" if $debugging;
                     $givenNonStdNames = 1;
                  }
                  $dirPathnames{$pathname} = $bn;
                  if ( ! exists $dirBasenames{$bn}) {
                     print DBGOUT "mkinstaller:       new (directory) basename \"".pKit_nativePathname($bn)."\"\n" if $debugging;
                     my $jdx                         = $#dirBasenames + 1;
                     $dirBasenames[$jdx]             = $bn;
                     $dirBasenames{$bn}{"pathnames"} = [ ];
                     $dirBasenames{$bn}{"indices"}   = [ ];
                     $dirBasenames{$bn}{"which"}     = $jdx;
                     $dirBasenames{$bn}{"count"}     = 0;
                  }
                  else {
                     print DBGOUT "mkinstaller:       known (directory) basename \"".pKit_nativePathname($bn)."\"\n" if $debugging;
                  }
                  my $idx              = $#dirPathnames + 1;
                  $dirPathnames[$idx]  = $pathname;
                  $dirPathnameCount   += 1;
                  push @{ $dirBasenames{$bn}{"pathnames"} }, $pathname;
                  push @{ $dirBasenames{$bn}{"indices"} },   $idx;
                  $dirBasenames{$bn}{"count"} += 1;
               }
               if ($debugging) {
                  print DBGOUT "mkinstaller:    ...done, now have:\n";
                  my $bn;
                  foreach $bn (sort keys %dirBasenames) {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($bn)."\"\n";
                     my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                     my $i;
                     for ($i=0; $i<=$#dirs; $i+=1) {
                        my $pathname = $dirs[$i];
                        print DBGOUT "mkinstaller:       ...\"".pKit_nativePathname($pathname)."\"\n";
                     }
                  }
               }
               if (1 <= $verbosityLevel) {
                  if (2 <= $verbosityLevel) {
                     print STDERR "mkinstaller:    done, giving:\n";
                     my $bn;
                     foreach $bn (sort keys %dirBasenames) {
                        my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                        my $i;
                        for ($i=0; $i<=$#dirs; $i+=1) {
                           my $pathname = $dirs[$i];
                           if ($i == 0) {
                              print STDOUT "mkinstaller:       ...\"".pKit_nativePathname($pathname)."\"\n";
                           }
                           else {
                              print STDOUT "mkinstaller:          \"".pKit_nativePathname($pathname)."\"\n";
                           }
                        }
                     }
                  }
                  else {
                     print STDERR "mkinstaller:    done\n";
                  }
               }
            }
         }
         else {
            print DBGOUT "mkinstaller:    given pathnames with standard basenames\n" if $debugging;
            if ($givenNonStdNames) {
               print DBGOUT "mkinstaller:    ...and given pathnames with non-standard basenames\n" if $debugging;
            }
         }
      }
      else {
         print DBGOUT "mkinstaller: ...operating in nonstandard (explicit) mode\n" if $debugging;
      }
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Ready to go to work...
   #
   #----------------------------------------------------------------------------

   #------------------------------------
   #
   #  Deal with pre-install script...
   #
   #------------------------------------

   if ($preInstallPathname ne "") {
      print DBGOUT "mkinstaller: check the pre-install script\n" if $debugging;
      if ( ! -f $preInstallPathname) {
         print STDERR "mkinstaller: error: can't find pre-install script \"".pKit_nativePathname($preInstallPathname)."\"\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $ok = 0;
      if ($preInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error: invalid pre-install style(=\"$preInstallStyle\")\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $sbn = pKit_basename($preInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error: name of pre-install script \"".pKit_nativePathname($preInstallPathname)."\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"".pKit_nativePathname($pathname)."\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"".pKit_nativePathname($pathname)."\"\n";
               }
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print DBGOUT "mkinstaller: no pre-install script\n" if $debugging;
      $preInstallStyle = "";
   }

   #------------------------------------
   #
   #  Deal with post-install script...
   #
   #------------------------------------

   if ($postInstallPathname ne "") {
      print DBGOUT "mkinstaller: check the post-install script\n" if $debugging;
      if ( ! -f $postInstallPathname) {
         print STDERR "mkinstaller: error: can't find post-install script \"".pKit_nativePathname($postInstallPathname)."\"\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $ok = 0;
      if ($postInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error: invalid post-install style(=\"$postInstallStyle\")\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $sbn = pKit_basename($postInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error: name of post-install script \"".pKit_nativePathname($postInstallPathname)."\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"".pKit_nativePathname($pathname)."\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"".pKit_nativePathname($pathname)."\"\n";
               }
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print DBGOUT "mkinstaller: no post-install script\n" if $debugging;
      $postInstallStyle = "";
   }

   #---------------------------------------
   #
   #  Construct the title line used at the
   #  top of the --help output...
   #
   #---------------------------------------

   print DBGOUT "mkinstaller: prepare help title...\n" if $debugging;
   {
      my $gapString  = "   ";
      $titleLine     = $scriptName."(1x)".$gapString.$scriptName."(1x)";
      my $LtitleLine = length $titleLine;
      while ($LtitleLine < 80) {
         $gapString  = $gapString." ";
         $titleLine  = $scriptName."(1x)".$gapString.$scriptName."(1x)";
         $LtitleLine = length $titleLine;
      }
      print DBGOUT "mkinstaller:    [--------------------------------------------------------------------------------]\n" if $debugging;
      print DBGOUT "mkinstaller:    [".$titleLine."]\n" if $debugging;
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #---------------------------------------
   #
   #  Prepare a string with the project
   #  name an version used in the --help
   #  output...
   #
   #---------------------------------------

   print DBGOUT "mkinstaller: prepare project name version string for help...\n" if $debugging;
   {
      if ($ProjectName ne "") {
         print DBGOUT "mkinstaller: ...project name    = [$ProjectName]\n" if $debugging;
         if ($ProjectVer ne "") {
            print DBGOUT "mkinstaller: ...project version = [$ProjectVer]\n" if $debugging;
            $ForProject = " for ".$ProjectName." ver. ".$ProjectVer;
         }
         else {
            $ForProject = " for ".$ProjectName;
            print DBGOUT "mkinstaller: ...no project version\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mkinstaller: ...no project name\n" if $debugging;
         $ForProject = "";
      }
      print DBGOUT "mkinstaller:    [".$ForProject."]\n" if $debugging;
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #============================================================================

   if ($OSclass eq "UNIX-like") {
#{= cut here ========================================================================================================== cut here ===

      #-------------------------------------------------------------------------
      #
      #  On a UNIX-like host we will want to get version number for the C
      #  and C++ compilers.
      #
      #-------------------------------------------------------------------------

      {
         print DBGOUT "mkinstaller: Check C compiler version\n" if $debugging;
         my $tmp        = mki_checkForCompilerVersion($CC_pathname,$CC_basename);
         if ($tmp =~ /^\s*(\S+)\s+(\d+(\.\d+)*)([^.0-9].*)?$/) {
            my $part1   = $1;
            my $part2   = $2;
            my $part3   = $3;
            my $part4   = $4;
            print DBGOUT "mkinstaller:    part1 = [$part1]\n" if $debugging;
            print DBGOUT "mkinstaller:    part2 = [$part2]\n" if $debugging;
            print DBGOUT "mkinstaller:    part3 = [$part3]\n" if $debugging;
            print DBGOUT "mkinstaller:    part4 = [$part4]\n" if $debugging;
            $CC_version  = $part2;
            print DBGOUT "mkinstaller: ...gives $CC_version\n" if $debugging;
         }
         else {
            print DBGOUT "mkinstaller:    failed\n" if $debugging;
         }
         print DBGOUT "mkinstaller: Check C++ compiler version\n" if $debugging;
         my $tmp        = mki_checkForCompilerVersion($CXX_pathname);
         if ($tmp =~ /^\s*(\S+)\s+(\d+(\.\d+)*)([^.0-9].*)?$/) {
            my $part1   = $1;
            my $part2   = $2;
            my $part3   = $3;
            my $part4   = $4;
            print DBGOUT "mkinstaller:    part1 = [$part1]\n" if $debugging;
            print DBGOUT "mkinstaller:    part2 = [$part2]\n" if $debugging;
            print DBGOUT "mkinstaller:    part3 = [$part3]\n" if $debugging;
            print DBGOUT "mkinstaller:    part4 = [$part4]\n" if $debugging;
            $CXX_version = $part2;
            print DBGOUT "mkinstaller: ...gives $CXX_version\n" if $debugging;
         }
         else {
            print DBGOUT "mkinstaller:    failed\n" if $debugging;
         }
      }

      #-------------------------------------------------------------------------
      #
      #  On a UNIX-like host (Linux in particular) we will want to get version
      #  numbers for the C library, Standard C++ library, and C++ ABI.
      #
      #  Note that to identify the C library we need to use:
      #
      #     C compiler and linker
      #     fgrep
      #     ldd
      #     strings
      #
      #  Note that to identify the C++ standard library we need to use:
      #
      #     C++ compiler and linker
      #     fgrep
      #     ldd
      #     strings
      #
      #-------------------------------------------------------------------------

      print DBGOUT "mkinstaller: Check library versions\n" if $debugging;
      $CC_libc_version           = "";
      @CXX_stdcxxlib_verList     = ( );
      $CXX_stdcxxlib_version     = "";
      @CXX_stdcxxlib_abiVerList  = ( );
      $CXX_stdcxxlib_abiVersion  = "";
      @CXX_stdcxxlib_libcVerList = ( );
      $CXX_stdcxxlib_libcVersion = "";
      if ( defined $CC_pathname) {
         print DBGOUT "mkinstaller: ...for $CC_pathname\n" if $debugging;
         $CC_libc_XversionX = mki_libc_version();
         if (2 <= $verbosityLevel) {
            print STDERR "mkinstaller: $CC_pathname reports:\n";
            if ($CC_version ne "") {
               print STDERR "mkinstaller: ...$CC_pathname $CC_version\n";
            }
            if ($CC_libc_pathname ne "") {
               print STDERR "mkinstaller: ...C library is at \"".pKit_nativePathname($CC_libc_pathname)."\"\n";
            }
            else {
               print STDERR "mkinstaller: ...C library could not be found\n";
            }
            if ($CC_libc_XversionX ne "") {
               print STDERR "mkinstaller: ...C library version $CC_libc_XversionX in use\n";
            }
         }
      }
      else {
         print DBGOUT "mkinstaller: ...no C compiler, can't identify C library\n" if $debugging;
      }
      if ( defined $CXX_pathname) {
         print DBGOUT "mkinstaller: ...for $CXX_pathname\n" if $debugging;
         if (mki_stdcxxlib_version()) {
            print DBGOUT "mkinstaller: ...done\n" if $debugging;
            my $Nlibc      = $#CXX_stdcxxlib_libcVerList + 1;
            my $Nstdlibcxx = $#CXX_stdcxxlib_verList + 1;
            my $Nabi       = $#CXX_stdcxxlib_abiVerList + 1;
            if (1 <= $Nlibc) {
               $CXX_stdcxxlib_libcVersion = $CXX_stdcxxlib_libcVerList[0];
            }
            else {
               $CXX_stdcxxlib_libcVersion = "";
            }
            if (1 <= $Nstdlibcxx) {
               $CXX_stdcxxlib_version     = $CXX_stdcxxlib_verList[0];
            }
            else {
               $CXX_stdcxxlib_version     = "";
            }
            if (1 <= $Nabi) {
               $CXX_stdcxxlib_abiVersion = $CXX_stdcxxlib_abiVerList[0];
            }
            else {
               $CXX_stdcxxlib_abiVersion = "";
            }
            if (2 <= $verbosityLevel) {
               print STDERR "mkinstaller: $CXX_pathname reports:\n";
               if ($CC_version ne "") {
                  print STDERR "mkinstaller: ...$CXX_pathname $CXX_version\n";
               }
               if ($CXX_stdcxxlib_pathname ne "") {
                  print STDERR "mkinstaller: ...Standard C++ library is at \"".pKit_nativePathname($CXX_stdcxxlib_pathname)."\"\n";
               }
               else {
                  print STDERR "mkinstaller: ...Standard C++ library could not be found\n";
               }
               if ($CXX_stdcxxlib_version ne "") {
                  print STDERR "mkinstaller: ...Standard C++ library version number is $CXX_stdcxxlib_version\n";
               }
               else {
                  if ($CXX_stdcxxlib_pathname ne "") {
                     print STDERR "mkinstaller: ...didn't find a Standard C++ library library number in \"".pKit_nativePathname($CXX_stdcxxlib_pathname)."\"\n";
                  }
               }
               if ($CXX_stdcxxlib_abiVersion ne "") {
                  print STDERR "mkinstaller: ...C++ ABI version number is $CXX_stdcxxlib_abiVersion\n";
               }
               else {
                  if ($CXX_stdcxxlib_pathname ne "") {
                     print STDERR "mkinstaller: ...didn't find a C++ ABI library version number in \"".pKit_nativePathname($CXX_stdcxxlib_pathname)."\"\n";
                  }
               }
               if ($CXX_stdcxxlib_libcVersion ne "") {
                  print STDERR "mkinstaller: ...$CXX_pathname using C library version $CXX_stdcxxlib_libcVersion\n";
               }
               else {
                  if ($CXX_stdcxxlib_pathname ne "") {
                     print STDERR "mkinstaller: ...didn't find a C library version number in \"".pKit_nativePathname($CXX_stdcxxlib_pathname)."\"\n";
                  }
               }
            }
         }
      }
      else {
         print DBGOUT "mkinstaller: ...no C++ compiler, can't identify C++ standard library\n" if $debugging;
      }

      #-------------------------------------------------------------------------
      #
      #  On a UNIX-like host we will want to get version number for the
      #  operating system (aka. kernel on Linux).
      #
      #  Note that to identify the OS (kernel) version we need to use:
      #
      #     uname
      #
      #-------------------------------------------------------------------------

      print DBGOUT "mkinstaller: Check OS version\n" if $debugging;
      {
         my $versionNumber = mki_os_version();
         if ($versionNumber != "") {
            $OSversion = $versionNumber;
            print DBGOUT "mkinstaller: ...done, is $OSversion\n" if $debugging;
         }
         else {
            print DBGOUT "mkinstaller: ...failed\n" if $debugging;
         }
         if ($OSversion ne "") {
            print STDERR "mkinstaller: ...Operating System version number is $OSversion\n" if (1 <= verbosityLevel);
         }
         else {
            print STDERR "mkinstaller: warning: didn't find operating system version number\n";
         }
      }
#}= cut here ========================================================================================================== cut here ===
   }
   elsif ($OSclass eq "Windows-like") {
#{= cut here ========================================================================================================== cut here ===
      #-------------------------------------------------------------------------
      #
      #  On a Window-like host there isn't really a need for version numbers
      #  for the C++ ABI, Standard C++ library, and C library.
      #
      #-------------------------------------------------------------------------

      print DBGOUT "mkinstaller: Don't bother checking library versions\n" if $debugging;
#}= cut here ========================================================================================================== cut here ===
   }
   else {
      print STDERR "mkinstaller: error: can't identify the class of host\n";
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
      close DBGOUT if $dbgOutToPathname ne "";
      exit 1;
   }

   #----------------------------------------------------------------------------
   #
   #  If operating in standard mode with no given pathnames with standard
   #  basenames then rebuild the directory hash and list.
   #
   #----------------------------------------------------------------------------

   print DBGOUT "mkinstaller: deal with (non)standard pathnames...\n" if $debugging;
   {
      if ($stdMode) {
         my $rebuilt = 0;
         print DBGOUT "mkinstaller: ...operating in standard mode\n" if $debugging;
         if ( ! $givenStdNames) {
            print DBGOUT "mkinstaller:    but given no pathnames with standard basenames\n" if $debugging;
            if (1 <= $verbosityLevel) {
               print STDERR "mkinstaller: operating in \"standard\" mode but no \"standard basenames\"\n";
               if (2 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...\"bin\", \"lib\", \"lib64\", or \"include\"\n";
               }
            }
            my @allPathnames = ( );
            my $first        = 1;
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
               my $i;
               for ($i=0; $i<=$#dirs; $i+=1) {
                  my $pathname = $dirs[$i];
                  if ($first) {
                     print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                     $first = 0;
                  }
                  else {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  my $idx             = $#allPathnames + 1;
                  $allPathnames[$idx] = $pathname;
               }
            }
            print DBGOUT "mkinstaller:    check each given directory pathname for subdirectories with standard basenames\n" if $debugging;
            my $changed       = 0;
            my $haveStdSubdir = 0;
            my @usePathnames  = ( );
            my $i;
            for ($i=0; $i<=$#allPathnames; $i+=1) {
               my $foundOne = 0;
               my $pathname = $allPathnames[$i];
               if ($i == 0) {
                  print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
               }
               else {
                  print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
               }
               if (opendir(DIR,"$pathname")) {
                  while (defined($tmpName3 = readdir(DIR))) {
                     if (($tmpName3 ne "" ) && ($tmpName3 ne ".") && ($tmpName3 ne "..")) {
                        if (($tmpName3 =~ /^bin$/i) || ($tmpName3 =~ /^lib$/i) || ($tmpName3 =~ /^lib64$/i) || ($tmpName3 =~ /^include$/i)) {
                           $foundOne          = 1;
                           if ($bn =~ /^lib$/i) {
                              $libDirBasename = "lib";
                           }
                           elsif ($bn =~ /^lib64$/i) {
                              $libDirBasename = "lib64";
                           }
                           last;
                        }
                     }
                  }
                  closedir(DIR);
               }
               if ($foundOne) {
                  print DBGOUT "mkinstaller:          has a subdir with a standard basename\n" if $debugging;
                  if (opendir(DIR,"$pathname")) {
                     while (defined($tmpName4 = readdir(DIR))) {
                        if (($tmpName4 ne "" ) && ($tmpName4 ne ".") && ($tmpName4 ne "..")) {
                           my $joinName = pKit_fixpath(pKit_joinpath($pathname,$tmpName4));
                           if ( ! $followSymlinks) {
                              if ( -l $joinName) {
                                 if ( -e $joinName) {
                                    print STDERR "mkinstaller: error: \"".pKit_nativePathname($joinName)."\" is a symbolic-link not a directory\n";
                                 }
                                 else {
                                    print STDERR "mkinstaller: error: \"".pKit_nativePathname($joinName)."\" is a broken symbolic-link not a directory\n";
                                 }
                                 cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                 close DBGOUT if $dbgOutToPathname ne "";
                                 exit 1;
                              }
                           }
                           if (-d $joinName) {
                              my $idx             = $#usePathnames + 1;
                              $usePathnames[$idx] = $joinName;
                              $changed            = 1;
                           }
                        }
                     }
                     closedir(DIR);
                  }
               }
               else {
                  print DBGOUT "mkinstaller:          has no subdirs with a standard basename\n" if $debugging;
                  my $idx             = $#usePathnames + 1;
                  $usePathnames[$idx] = $pathname;
               }
            }
            if ($changed) {
               if (1 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...rebuilding pathname list\n";
               }
               print DBGOUT "mkinstaller:    changed directory pathname list\n" if $debugging;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  else {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
               }
               print DBGOUT "mkinstaller:    rebuild directory pathname hash and list\n" if $debugging;
               $rebuilt          = 1;
               %dirBasenames     = ( );
               @dirBasenames     = ( );
               %dirPathnames     = ( );
               @dirPathnames     = ( );
               $dirPathnameCount = 0;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print DBGOUT "mkinstaller:    ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  else {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                  }
                  my $bn       = pKit_basename($pathname);
                  if ($bn =~ /\s/) {
                     if ($bn eq $pathname) {
                        print STDERR "mkinstaller: error: \"".pKit_nativePathname($pathname)."\" contains spaces and/or tabs\n";
                     }
                     else {
                        print STDERR "mkinstaller: error: basename of \"".pKit_nativePathname($pathname)."\" contains spaces and/or tabs\n";
                     }
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
                     print DBGOUT "mkinstaller:       has a standard basename(=$bn)\n" if $debugging;
                     $givenStdNames     = 1;
                     if ($bn =~ /^lib$/i) {
                        $libDirBasename = "lib";
                     }
                     elsif ($bn =~ /^lib64$/i) {
                        $libDirBasename = "lib64";
                     }
                  }
                  else {
                     print DBGOUT "mkinstaller:       has a non-standard basename(=$bn)\n" if $debugging;
                     $givenNonStdNames = 1;
                  }
                  $dirPathnames{$pathname} = $bn;
                  if ( ! exists $dirBasenames{$bn}) {
                     print DBGOUT "mkinstaller:       new basename \"".pKit_nativePathname($bn)."\"\n" if $debugging;
                     my $jdx                         = $#dirBasenames + 1;
                     $dirBasenames[$jdx]             = $bn;
                     $dirBasenames{$bn}{"pathnames"} = [ ];
                     $dirBasenames{$bn}{"indices"}   = [ ];
                     $dirBasenames{$bn}{"which"}     = $jdx;
                     $dirBasenames{$bn}{"count"}     = 0;
                  }
                  else {
                     print DBGOUT "mkinstaller:       known (dir) basename \"".pKit_nativePathname($bn)."\"\n" if $debugging;
                  }
                  my $idx              = $#dirPathnames + 1;
                  $dirPathnames[$idx]  = $pathname;
                  $dirPathnameCount   += 1;
                  push @{ $dirBasenames{$bn}{"pathnames"} }, $pathname;
                  push @{ $dirBasenames{$bn}{"indices"} },   $idx;
                  $dirBasenames{$bn}{"count"} += 1;
               }
               if ($debugging) {
                  print DBGOUT "mkinstaller:    ...done, now have:\n";
                  my $bn;
                  foreach $bn (sort keys %dirBasenames) {
                     print DBGOUT "mkinstaller:       \"".pKit_nativePathname($bn)."\"\n";
                     my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                     my $i;
                     for ($i=0; $i<=$#dirs; $i+=1) {
                        my $pathname = $dirs[$i];
                        print DBGOUT "mkinstaller:       ...\"".pKit_nativePathname($pathname)."\"\n";
                     }
                  }
               }
               if (1 <= $verbosityLevel) {
                  if (2 <= $verbosityLevel) {
                     print STDERR "mkinstaller:    done, giving:\n";
                     my $bn;
                     foreach $bn (sort keys %dirBasenames) {
                        my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                        my $i;
                        for ($i=0; $i<=$#dirs; $i+=1) {
                           my $pathname = $dirs[$i];
                           if ($i == 0) {
                              print STDOUT "mkinstaller:       ...\"".pKit_nativePathname($pathname)."\"\n";
                           }
                           else {
                              print STDOUT "mkinstaller:          \"".pKit_nativePathname($pathname)."\"\n";
                           }
                        }
                     }
                  }
                  else {
                     print STDERR "mkinstaller:    done\n";
                  }
               }
            }
         }
         else {
            print DBGOUT "mkinstaller:    given pathnames with standard basenames\n" if $debugging;
            if ($givenNonStdNames) {
               print DBGOUT "mkinstaller:    ...and given pathnames with non-standard basenames\n" if $debugging;
            }
         }
      }
      else {
         print DBGOUT "mkinstaller: ...operating in nonstandard (explicit) mode\n" if $debugging;
      }
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Ready to go to work...
   #
   #----------------------------------------------------------------------------

   #------------------------------------
   #
   #  Deal with pre-install script...
   #
   #------------------------------------

   if ($preInstallPathname ne "") {
      print DBGOUT "mkinstaller: check the pre-install script\n" if $debugging;
      if ( ! -f $preInstallPathname) {
         print STDERR "mkinstaller: error: can't find pre-install script \"".pKit_nativePathname($preInstallPathname)."\"\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $ok = 0;
      if ($preInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error: invalid pre-install style(=\"$preInstallStyle\")\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $sbn = pKit_basename($preInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error: name of pre-install script \"".pKit_nativePathname($preInstallPathname)."\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"".pKit_nativePathname($pathname)."\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"".pKit_nativePathname($pathname)."\"\n";
               }
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print DBGOUT "mkinstaller: no pre-install script\n" if $debugging;
      $preInstallStyle = "";
   }

   #------------------------------------
   #
   #  Deal with post-install script...
   #
   #------------------------------------

   if ($postInstallPathname ne "") {
      print DBGOUT "mkinstaller: check the post-install script\n" if $debugging;
      if ( ! -f $postInstallPathname) {
         print STDERR "mkinstaller: error: can't find post-install script \"".pKit_nativePathname($postInstallPathname)."\"\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $ok = 0;
      if ($postInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error: invalid post-install style(=\"$postInstallStyle\")\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      my $sbn = pKit_basename($postInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error: name of post-install script \"".pKit_nativePathname($postInstallPathname)."\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"".pKit_nativePathname($pathname)."\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"".pKit_nativePathname($pathname)."\"\n";
               }
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print DBGOUT "mkinstaller: no post-install script\n" if $debugging;
      $postInstallStyle = "";
   }

   #---------------------------------------
   #
   #  Construct the title line used at the
   #  top of the --help output...
   #
   #---------------------------------------

   print DBGOUT "mkinstaller: prepare help title...\n" if $debugging;
   {
      my $gapString  = "   ";
      $titleLine     = $scriptName."(1x)".$gapString.$scriptName."(1x)";
      my $LtitleLine = length $titleLine;
      while ($LtitleLine < 80) {
         $gapString  = $gapString." ";
         $titleLine  = $scriptName."(1x)".$gapString.$scriptName."(1x)";
         $LtitleLine = length $titleLine;
      }
      print DBGOUT "mkinstaller:    [--------------------------------------------------------------------------------]\n" if $debugging;
      print DBGOUT "mkinstaller:    [".$titleLine."]\n" if $debugging;
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #---------------------------------------
   #
   #  Prepare a string with the project
   #  name an version used in the --help
   #  output...
   #
   #---------------------------------------

   print DBGOUT "mkinstaller: prepare project name version string for help...\n" if $debugging;
   {
      if ($ProjectName ne "") {
         print DBGOUT "mkinstaller: ...project name    = [$ProjectName]\n" if $debugging;
         if ($ProjectVer ne "") {
            print DBGOUT "mkinstaller: ...project version = [$ProjectVer]\n" if $debugging;
            $ForProject = " for ".$ProjectName." ver. ".$ProjectVer;
         }
         else {
            $ForProject = " for ".$ProjectName;
            print DBGOUT "mkinstaller: ...no project version\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mkinstaller: ...no project name\n" if $debugging;
         $ForProject = "";
      }
      print DBGOUT "mkinstaller:    [".$ForProject."]\n" if $debugging;
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   if ($OSclass eq "UNIX-like") {
#{= cut here ========================================================================================================== cut here ===

      #=========================================================================
      #
      #  This is a UNIX-like host
      #
      #  The installer script to be generated will be a self-extracting Bourne-
      #  shell script. The payload is a tar file containing one or more tarballs
      #  (compressed tar files) and an optional pre- and/or post-install scripts.
      #
      #  This section of the mkinstaller script is devoted to forming the
      #  tarballs and building the script (plus adding the tarball).
      #
      #=========================================================================

      print DBGOUT "mkinstaller: working on a \"$OSclass\" host\n" if $debugging;

      if ($withPayload) {
         #---------------------------------------
         #
         #  Locate tar (is required for payload)...
         #
         #---------------------------------------
         print DBGOUT "mkinstaller: locate required \"tar\" utility...\n" if $debugging;
         $use_tar = pKit_lookForExecutable("tar",\@myPATH,$OSclass);
         if ($use_tar eq "") {
            print STDERR "mkinstaller: error: can't locate required \"tar\" utility\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         print DBGOUT "mkinstaller: ...found \"".pKit_nativePathname($use_tar)."\"\n" if $debugging;
         print DBGOUT "mkinstaller: is it GNU tar or something else...\n" if $debugging;
         my $style = "";
         if ($tarIsGNUtar < 0) {
            print DBGOUT "mkinstaller: ...check\n" if $debugging;
            if (pKit_isGNUtar($use_tar)) {
               $tarIsGNUtar = 1;
               $style       = " (is GNU tar)";
               print DBGOUT "mkinstaller:    looks like GNU tar\n" if $debugging;
            }
            else {
               $tarIsGNUtar = 0;
               $style       = "";
               print DBGOUT "mkinstaller:    doesn't look like it's GNU tar\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mkinstaller: ...no need to check, was told\n" if $debugging;
            if ($tarIsGNUtar) {
               $tarIsGNUtar = 1;
               $style       = " (is GNU tar)";
               print DBGOUT "mkinstaller:    assume GNU tar\n" if $debugging;
            }
            else {
               $tarIsGNUtar = 0;
               $style       = "";
               print DBGOUT "mkinstaller:    assume it's not GNU tar\n" if $debugging;
            }
         }
         if ($isCompressed eq "") {
            $isCompressed   = "true"; # At this time we always compress
         }
         if ( ! $tarIsGNUtar) {
            #---------------------------------------
            #
            #  Locate gzcat (is required with non-GNU
            #  tar). Note that it sometimes is named
            #  just zcat.
            #
            #---------------------------------------
            print DBGOUT "mkinstaller: locate required \"gzcat\" utility...\n" if $debugging;
            $use_gzcat = pKit_lookForExecutable("gzcat",\@myPATH,$OSclass);
            if ($use_gzcat eq "") {
               print DBGOUT "mkinstaller: ...failed, try \"zcat\" utility...\n" if $debugging;
               $use_gzcat = pKit_lookForExecutable("zcat",\@myPATH,$OSclass);
               if ($use_gzcat eq "") {
                  print STDERR "mkinstaller: error: can't locate required \"gzcat\" utility\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
            }
            #---------------------------------------
            #
            #  Locate gzip (is required with non-GNU tar)...
            #
            #---------------------------------------
            print DBGOUT "mkinstaller: locate required \"gzip\" utility...\n" if $debugging;
            $use_gzip = pKit_lookForExecutable("gzip",\@myPATH,$OSclass);
            if ($use_gzip eq "") {
               print STDERR "mkinstaller: error: can't locate required \"gzip\" utility\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
         }
         if ($use_tar ne "") {
            print STDERR "mkinstaller: ...using \"".pKit_nativePathname($use_tar)."\"$style\n" if (2 <= $verbosityLevel);
         }
         if ($use_gzcat ne "") {
            print STDERR "mkinstaller: ...using \"".pKit_nativePathname($use_gzcat)."\"\n" if (2 <= $verbosityLevel);
         }
         if ($use_gzip ne "") {
            print STDERR "mkinstaller: ...using \"".pKit_nativePathname($use_gzip)."\"\n" if (2 <= $verbosityLevel);
         }
      }
      else {
         #---------------------------------------
         #
         #  Without a payload we don't really
         #  require tar, gzcat, or gzip, but
         #  look anyway...
         #
         #---------------------------------------
         print DBGOUT "mkinstaller: without a payload, don't require \"tar\" utility\n" if $debugging;
         print DBGOUT "mkinstaller: locate the \"tar\" utility...\n" if $debugging;
         if ($use_tar eq "") {
            print STDERR "mkinstaller: note: can't locate \"tar\" utility\n";
         }
         else {
            print DBGOUT "mkinstaller: ...found \"".pKit_nativePathname($use_tar)."\"\n" if $debugging;
            if (pKit_isGNUtar($use_tar)) {
               print DBGOUT "mkinstaller:    looks like GNU tar\n" if $debugging;
            }
            else {
               print DBGOUT "mkinstaller:    doesn't look like it's GNU tar\n" if $debugging;
               print DBGOUT "mkinstaller: locate the \"gzcat\" utility...\n" if $debugging;
               $use_gzcat = pKit_lookForExecutable("gzcat",\@myPATH,$OSclass);
               if ($use_gzcat eq "") {
                  print DBGOUT "mkinstaller: ...failed, try \"zcat\" utility...\n" if $debugging;
                  $use_gzcat = pKit_lookForExecutable("zcat",\@myPATH,$OSclass);
                  if ($use_gzcat eq "") {
                     print STDERR "mkinstaller: note: can't locate \"gzcat\" (or \"zcat\") utility\n";
                  }
                  else {
                     print DBGOUT "mkinstaller: ...found \"".pKit_nativePathname($use_gzcat)."\"\n" if $debugging;
                  }
               }
               else {
                  print DBGOUT "mkinstaller: ...found \"".pKit_nativePathname($use_gzcat)."\"\n" if $debugging;
               }
               print DBGOUT "mkinstaller: locate the \"gzip\" utility...\n" if $debugging;
               $use_gzip = pKit_lookForExecutable("gzip",\@myPATH,$OSclass);
               if ($use_gzip eq "") {
                  print STDERR "mkinstaller: note: can't locate \"gzip\" utility\n";
               }
               else {
                  print DBGOUT "mkinstaller: ...found \"".pKit_nativePathname($use_gzip)."\"\n" if $debugging;
               }
            }
         }
      }

      #---------------------------------------
      #
      #  Destroy existing script (if any)...
      #
      #---------------------------------------

      print DBGOUT "mkinstaller: cleanup existing script...\n" if $debugging;
      {
         my $Tstart = time();
         print STDERR "mkinstaller: initial cleanup\n" if (2 <= $verbosityLevel);
         if ( -l "$here/$scriptName") {
            if ( -e "$here/$scriptName") {
               print STDERR "mkinstaller: error: \"".pKit_nativePathname($here."/".$scriptName)."\" is a symbolic-link not a file\n";
            }
            else {
               print STDERR "mkinstaller: error: \"".pKit_nativePathname($here."/".$scriptName)."\" is a broken symbolic-link not a file\n";
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         elsif ( -f "$here/$scriptName") {
            print DBGOUT "mkinstaller: ...\"$here/$scriptName\"\n" if $debugging;
            print STDERR "mkinstaller: ...destroy existing \"".pKit_nativePathname($here."/".$scriptName)."\" script\n" if (2 <= $verbosityLevel);
            my $Ndeleted = unlink "$here/$scriptName";
            if ($Ndeleted < 1) {
               print STDERR "mkinstaller: error: can't destroy existing \"".pKit_nativePathname($here."/".$scriptName)."\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ( -f "$here/$scriptName") {
               print STDERR "mkinstaller: error: didn't destroy existing \"".pKit_nativePathname($here."/".$scriptName)."\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            print STDERR "mkinstaller:    done\n" if (3 <= $verbosityLevel);
         }
         elsif ( -e "$here/$scriptName") {
            print DBGOUT "mkinstaller: ...but \"$here/$scriptName\" isn't a file\n" if $debugging;
            print STDERR "mkinstaller: error: existing \"".pKit_nativePathname($here."/".$scriptName)."\" is not a file\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         my $Tend = time();
         my $dT   = $Tend - $Tstart;
         if (0 <= $dT) {
            if ($dT == 0) {
               print STDERR "mkinstaller: ...done (in <1 second)\n" if (2 <= $verbosityLevel);
            }
            elsif ($dT == 0) {
               print STDERR "mkinstaller: ...done (in $dT second)\n" if (2 <= $verbosityLevel);
            }
            else {
               print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (2 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller: ...done\n" if (2 <= $verbosityLevel);
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;

      #---------------------------------------
      #
      #  Tarup each of the individual directories
      #  from their given sites placing the
      #  individual tarballs into the wrapper
      #  directory TmpDirW.
      #
      #  Steps:
      #
      #     1) cd into the directory that contains the
      #        directory of interest (ie. into prefix
      #        directory containing "bin").
      #
      #     2) tarup the directory of interest (such as
      #        "bin") forming a tarball in the temporary
      #        "initial" directory.
      #
      #        The "initial" directory contains individual
      #        tarballs.
      #
      #     3) untar the tarball in the temporary "initial"
      #        directory. "bin") into the temporary
      #        "accumulator" directory. Note that this
      #        will overlay and existing directory to
      #        allow for directory merging (such as when
      #        multiple "bin" directories were specified).
      #
      #        The "accumulator" directory contains individual
      #        directories.
      #
      #  Note that these individual directory
      #  tarballs are normally compressed
      #  (.tar.gz files).
      #
      #---------------------------------------

      if ($withPayload) {
         print DBGOUT "mkinstaller: process given directories...\n" if $debugging;
         print DBGOUT "mkinstaller: ...first tarup to $TmpDirI directory...\n" if $debugging;
         print DBGOUT "mkinstaller:    then untar to $TmpDirA directory (to merge)\n" if $debugging;
         {
            print STDERR "mkinstaller: working the directories...\n" if (1 <= $verbosityLevel);
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $Tstart = time();
               print STDERR "mkinstaller: ...working \"$bn\"\n" if (1 <= $verbosityLevel);
               {
                  if ($debugging) {
                     my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                     print DBGOUT "mkinstaller: ...now in \"".pKit_nativePathname($imInDir)."\"\n" if $debugging;
                  }
                  my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                  my $i;
                  for ($i=0; $i<=$#dirs; $i+=1) {
                     my $pathname = $dirs[$i];
                     print DBGOUT "mkinstaller: ...directory \"".pKit_nativePathname($pathname)."\"\n" if $debugging;
                     print STDERR "mkinstaller:    \"".pKit_nativePathname($pathname)."\"\n" if (2 <= $verbosityLevel);
                     my $dn       = pKit_dirname($pathname);
                     my $bn       = pKit_basename($pathname);
                     if ( ! chdir($dn)) {
                        print STDERR "mkinstaller: error: can't cd into \"".pKit_nativePathname($dn)."\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        close DBGOUT if $dbgOutToPathname ne "";
                        exit 1;
                     }
                     {
                        if ($debugging) {
                           my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                           print DBGOUT "mkinstaller:    now in \"".pKit_nativePathname($imInDir)."\"\n" if $debugging;
                        }
                        #---------------------------------------
                        #
                        #  First tar up the directory in to the
                        #  individual ("initial") tarball directory
                        #  TmpDirI
                        #
                        print DBGOUT "mkinstaller:    tarup \"$dn/$bn\" to form \"$TmpDirI/$bn.tar.gz\"\n" if $debugging;
                        my $cmd;
                        if ($tarIsGNUtar) {
                           $cmd    = "\"$use_tar\" -czf \"$TmpDirI/$bn.tar.gz\" \"$bn\"";
                        }
                        else {
                           $cmd    = "\"$use_tar\" -cf - \"$bn\" | \"$use_gzip\" > \"$TmpDirI/$bn.tar.gz\"";
                        }
                        print DBGOUT "mkinstaller:    ...run [$cmd]\n" if $debugging;
                        my $status = system "( $cmd ) >$devNull 2>$TmpFileE";
                        if ($status != 0) {
                           print DBGOUT "mkinstaller:       failed, exit code $status\n" if $debugging;
                           print STDERR "mkinstaller: error: can't tarup \"$bn\"\n";
                           print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                           print STDERR "mkinstaller:    was done from in \"$dn\"\n";
                           if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                              pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                           }
                           unlink($TmpFileE);
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           close DBGOUT if $dbgOutToPathname ne "";
                           exit 1;
                        }
                        print DBGOUT "mkinstaller:       succeeded\n" if $debugging;
                        if ( ! -f "$TmpDirI/$bn.tar.gz") {
                           print STDERR "mkinstaller: error: didn't tarup \"$bn\"\n";
                           print STDERR "mkinstaller: ...[$cmd] failed\n";
                           print STDERR "mkinstaller:    was done from in \"$dn\"\n";
                           print STDERR "mkinstaller: ...can't find \"$TmpDirI/$bn.tar.gz\"\n";
                           if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                              pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                           }
                           unlink($TmpFileE);
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           close DBGOUT if $dbgOutToPathname ne "";
                           exit 1;
                        }
                        unlink($TmpFileE);
                        if ($debugging) {
                           #
                           #  Show what the "initial" directory
                           #  now contains...
                           #
                           my $back = `pwd`; chomp $back; $back =~ s/\r$//;
                           chdir($TmpDirI);
                              if (opendir(DIR,$TmpDirI)) {
                                 print DBGOUT "mkinstaller:    ...\"".$TmpDirI.$slash."\" now contains\n" if $debugging;
                                 while (defined($tmp = readdir(DIR))) {
                                    if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                                       print DBGOUT "mkinstaller:       \"".$tmp."\"\n" if $debugging;
                                    }
                                 }
                                 closedir(DIR);
                              }
                              else {
                                 print DBGOUT "mkinstaller:    ...can't see what \"".$TmpDirI.$slash."\" contains\n" if $debugging;
                              }
                           chdir($back);
                        }
                     }
                     if ( ! chdir($here)) {
                        print STDERR "mkinstaller: error: can't cd back to \"$here\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        close DBGOUT if $dbgOutToPathname ne "";
                        exit 1;
                     }
                     {
                        if ( ! chdir($TmpDirA)) {
                           print STDERR "mkinstaller: error: can't cd into \"$TmpDirA\"\n";
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           close DBGOUT if $dbgOutToPathname ne "";
                           exit 1;
                        }
                        #
                        #  Then untar the individual directory tarball over any
                        #  existing directory in to the accumulator directory
                        #  TmpDirA
                        #
                        if ($debugging) {
                           my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                           print DBGOUT "mkinstaller:    now in \"$imInDir\"\n" if $debugging;
                        }
                        my $cmd;
                        if ($tarIsGNUtar) {
                           $cmd    = "\"$use_tar\" -xzf \"$TmpDirI/$bn.tar.gz\"";
                        }
                        else {
                           $cmd    = "\"$use_gzcat\" \"$TmpDirI/$bn.tar.gz\" | \"$use_tar\" xf -";
                        }
                        print DBGOUT "mkinstaller:    run [$cmd]\n" if $debugging;
                        my $status = system "( $cmd ) >$devNull 2>$TmpFileE";
                        if ($status != 0) {
                           print DBGOUT "mkinstaller:    ...failed, exit code $status\n" if $debugging;
                           print STDERR "mkinstaller: error: can't tarup \"$bn\"\n";
                           print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                           print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                           if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                              pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                           }
                           unlink($TmpFileE);
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           close DBGOUT if $dbgOutToPathname ne "";
                           exit 1;
                        }
                        print DBGOUT "mkinstaller:    ...succeeded\n" if $debugging;
                        if ( ! -d "$TmpDirA/$bn") {
                           print STDERR "mkinstaller: error: didn't untar \"$bn\"\n";
                           print STDERR "mkinstaller: ...[$cmd] failed\n";
                           print STDERR "mkinstaller: ...can't find \"$TmpDirA/$bn\"\n";
                           print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                           if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                              pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                           }
                           unlink($TmpFileE);
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           close DBGOUT if $dbgOutToPathname ne "";
                           exit 1;
                        }
                        unlink($TmpFileE);
                        if ( -f "$TmpDirI/$bn.tar.gz") {
                           if ( ! unlink("$TmpDirI/$bn.tar.gz")) {
                              print STDERR "mkinstaller: error: can't delete \"$TmpDirI/$bn.tar.gz\"\n";
                              cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                              close DBGOUT if $dbgOutToPathname ne "";
                              exit 1;
                           }
                           if ( -f "$TmpDirI/$bn.tar.gz") {
                              print STDERR "mkinstaller: error: didn't delete \"$TmpDirI/$bn.tar.gz\"\n";
                              cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                              close DBGOUT if $dbgOutToPathname ne "";
                              exit 1;
                           }
                        }
                        if ($debugging) {
                           #
                           #  Show what the "accumulator" directory
                           #  now contains...
                           #
                           my $back = `pwd`; chomp $back; $back =~ s/\r$//;
                           chdir($TmpDirA);
                              if (opendir(DIR,$TmpDirA)) {
                                 print DBGOUT "mkinstaller:    ...\"".$TmpDirI.$slash."\" now contains\n" if $debugging;
                                 while (defined($tmp = readdir(DIR))) {
                                    if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                                       print DBGOUT "mkinstaller:       \"".$tmp."\"\n" if $debugging;
                                    }
                                 }
                                 closedir(DIR);
                              }
                              else {
                                 print DBGOUT "mkinstaller:    ...can't see what \"".$TmpDirA.$slash."\" contains\n" if $debugging;
                              }
                           chdir($back);
                        }
                     }
                  }
                  if ($debugging) {
                     my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                     print DBGOUT "mkinstaller:    still in \"$imInDir\"\n" if $debugging;
                  }
                  if ( ! chdir($here)) {
                     print STDERR "mkinstaller: error: can't cd back to \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  if ($debugging) {
                     my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                     print DBGOUT "mkinstaller: ...back in \"$imInDir\"\n" if $debugging;
                  }
               }
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }
            print STDERR "mkinstaller: ...done\n" if (1 <= $verbosityLevel);
            #-------------------------------------------------------------------
            #-------------------------------------------------------------------
            foreach $bn (sort keys %fileBasenames) {
               my $Tstart    = time();
               my $Spathname = $fileBasenames{$bn};
               my $Dpathname = pKit_joinpath($TmpDirA,$bn);
               print STDERR "mkinstaller: working \"$bn\"\n" if (1 <= $verbosityLevel);
               if ($use_cp eq "") {
                  #---------------------------------------
                  #
                  #  Locate cp (is required)...
                  #
                  #---------------------------------------

                  print DBGOUT "mkinstaller: ...locate required \"cp\" utility...\n" if $debugging;
                  $use_cp = pKit_lookForExecutable("cp",\@myPATH,$OSclass);
                  if ($use_cp eq "") {
                     print STDERR "mkinstaller: error: can't locate required \"cp\" utility\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  print DBGOUT "mkinstaller:    found \"".pKit_nativePathname($use_cp)."\"\n" if $debugging;
               }
               print DBGOUT "mkinstaller: ...copy \"".pKit_nativePathname($Spathname)."\" in to \"".pKit_nativePathname($Dpathname)."\"\n" if $debugging;
               my $cmd    = "\"".pKit_nativePathname($use_cp)."\" -p \"".pKit_nativePathname($Spathname)."\" \"".pKit_nativePathname($Dpathname)."\"";
               print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "( $cmd ) >$devNull 2>&1";
               if ($status != 0) {
                  print DBGOUT "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error: can't copy file \"".pKit_nativePathname($Spathname)."\" to temporary directory\"".$TmpDirA."\"\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($here)."\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               else {
                  print DBGOUT "mkinstaller:    succeeded\n" if $debugging;
                  if ( ! -f $Dpathname) {
                     print STDERR "mkinstaller: error: didn't copy file \"".pKit_nativePathname($Spathname)."\" to temporary directory\"".$TmpDirA."\"\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"".pKit_nativePathname($Dpathname)."\"\n";
                     print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($here)."\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
               }
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }

            if ($haveExclusions) {
               print DBGOUT "mkinstaller: ...have exclusions, we'll have to scan for files in the accumulator directory\n" if $debugging;
               #---------------------------------------
               #
               #  If there are exclusions then we'll
               #  have a bit more work to do on the
               #  payload. We'll scan over the files
               #  in the accumulator directory tree
               #  looking for matches with the patterns
               #  in the exclusions array. Files whose
               #  basenames match an exclusion pattern
               #  will be deleted from the accumulator
               #  directory tree.
               #
               #---------------------------------------

               my $wasInDir = `pwd`; chomp $wasInDir; $wasInDir =~ s/\r$//;
               if ($debugging) {
                  my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                  print DBGOUT "mkinstaller:    was in \"$imInDir\"\n" if $debugging;
               }
               if ( ! chdir($TmpDirA)) {
                  print STDERR "mkinstaller: error: can't cd into \"$TmpDirA\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               {
                  if ($debugging) {
                     my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                     print DBGOUT "mkinstaller:    now in \"$imInDir\"\n" if $debugging;
                  }
                  #---------------------------------------
                  #
                  #  Collect a list of pathnames forming
                  #  the directory tree rooted at the
                  #  currect directory. Note that symbolic-
                  #  links are NOT followed.
                  #
                  #---------------------------------------

                  my $theRoot            = `pwd`; chomp $theRoot; $theRoot =~ s/\r$//;
                  print DBGOUT "mkinstaller:    scan directory tree rooted at \"".$theRoot."\"\n" if $debugging;
                  my @theList            = ();
                  my $idx                = $#theList +1;
                  $theList[$idx]{"name"} = ".";
                  $theList[$idx]{"type"} = "unknown";
                  {
                     #  Form the list...

                     print DBGOUT "mkinstaller:    ...form the pathname list\n" if $debugging;
                     my $i;
                     for ($i=0; $i<=$#theList; ++$i) {
                        my $thePathname = $theList[$i]{"name"};
                        my $theType     = $theList[$i]{"type"};
                        my $theRealName = pKit_fixpath(pKit_joinpath($theRoot,$thePathname));
                        if ( -l "$theRealName" ) {
                           $theList[$i]{"type"} = "symbolic-link";
                        }
                        elsif ( -f "$theRealName" ) {
                           $theList[$i]{"type"} = "file";
                        }
                        elsif ( -d "$theRealName" ) {
                           $theList[$i]{"type"} = "directory";
                           if (opendir(DIR,"$theRealName")) {
                              while (defined($tmpName5 = readdir(DIR))) {
                                 if (($tmpName5 ne "" ) && ($tmpName5 ne ".") && ($tmpName5 ne "..")) {
                                    my $joinName         = pKit_fixpath(pKit_joinpath($thePathname,$tmpName5));
                                    my $j                = $#theList + 1;
                                    $theList[$j]{"name"} = $joinName;
                                    $theList[$j]{"type"} = "unknown";
                                 }
                              }
                              closedir(DIR);
                           }
                           else {
                              print STDERR "mkinstaller: error: can't read directory \"".pKit_nativePathname($theRealName)."\"\n";
                              print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($wasInDir)."\"\n";
                              cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                              close DBGOUT if $dbgOutToPathname ne "";
                              exit 1;
                           }
                        }
                        else {
                           $theList[$i]{"type"} = "other";
                        }
                     }

                     #  Scan the list...

                     print DBGOUT "mkinstaller:    ...scan the pathname list\n" if $debugging;
                     for ($i=0; $i<=$#theList; ++$i) {
                        my $thePathname = $theList[$i]{"name"};
                        my $theType     = $theList[$i]{"type"};
                        my $theRealName = pKit_fixpath(pKit_joinpath($theRoot,$thePathname));
                        if ($theType eq "directory") {
                           print DBGOUT "mkinstaller:       d \"".pKit_nativePathname($theRealName)."\"\n" if $debugging;
                        }
                        elsif ($theType eq "file") {
                           my $bn = pKit_basename($theRealName);
                           print DBGOUT "mkinstaller:       f \"".pKit_nativePathname($theRealName)."\" ($bn)\n" if $debugging;
                           my $matched = 0;
                           my $j;
                           for ($j=0; $j<=$#exclusions; ++$j) {
                              my $pattern = $exclusions[$j];
                              if ($bn =~ /$pattern/) {
                                 print DBGOUT "mkinstaller:         ...matched [$pattern]\n" if $debugging;
                                 $matched = 1;
                                 last;
                              }
                           }
                           if ($matched) {
                              print DBGOUT "mkinstaller:            delete \"".pKit_nativePathname($theRealName)."\"\n" if $debugging;
                              unlink($theRealName);
                              if ( -f $theRealName) {
                                 print DBGOUT "mkinstaller:            ...failed, \"".pKit_nativePathname($theRealName)."\" is still there\n" if $debugging;
                                 print STDERR "mkinstaller: error: can't delete file \"".pKit_nativePathname($theRealName)."\"\n";
                                 cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                                 close DBGOUT if $dbgOutToPathname ne "";
                                 exit 1;
                              }
                              else {
                                 print DBGOUT "mkinstaller:            ...done\n" if $debugging;
                                 print STDERR "mkinstaller: note: excluded \"$theRealName\"\n" if 1 <= $verbosityLevel;
                              }
                           }
                        }
                        elsif ($theType eq "symbolic-link") {
                           print DBGOUT "mkinstaller:       l \"".pKit_nativePathname($theRealName)."\"\n" if $debugging;
                        }
                        elsif ($theType eq "other") {
                           print DBGOUT "mkinstaller:       o \"".pKit_nativePathname($theRealName)."\"\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mkinstaller:       ? \"".pKit_nativePathname($theRealName)."\"\n" if $debugging;
                        }
                     }
                  }
               }
               if ( ! chdir($wasInDir)) {
                  print STDERR "mkinstaller: error: can't cd back to \"$wasInDir\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               if ($debugging) {
                  my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
                  print DBGOUT "mkinstaller:    back in \"$imInDir\"\n" if $debugging;
               }
            }

            #-------------------------------------------------------------------
            #
            #  The merging process is done, now tarup the merged individual
            #  directories from the accumulator directory in to the wrapper
            #  directory TmpDirW
            #
            #-------------------------------------------------------------------

            print DBGOUT "mkinstaller: ...tarup the individual directories into the wrapper directory\n" if $debugging;
            print DBGOUT "mkinstaller:    cd into \"$TmpDirA\"\n" if $debugging;
            if ( ! chdir($TmpDirA)) {
               my $fromWithin = `pwd`; chomp $fromWithin; $fromWithin =~ s/\r$//;
               print STDERR "mkinstaller: error: can't cd into \"$TmpDirA\"\n";
               print STDERR "mkinstaller: ...from within \"$fromWithin\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ($debugging) {
               my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
               print DBGOUT "mkinstaller:    now in \"$imInDir\"\n" if $debugging;
            }
            {
               if ($debugging) {
                  #
                  #  Show what the "wrapper" directory
                  #  now contains...
                  #
                  my $back = `pwd`; chomp $back; $back =~ s/\r$//;
                  print DBGOUT "mkinstaller:    cd into \"$TmpDirW\"\n" if $debugging;
                  if ( ! chdir($TmpDirW)) {
                     my $fromWithin = `pwd`; chomp $fromWithin; $fromWithin =~ s/\r$//;
                     print STDERR "mkinstaller: error: can't cd into \"$TmpDirW\"\n";
                     print STDERR "mkinstaller: ...from within \"$fromWithin\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  if (opendir(DIR,$TmpDirW)) {
                     my $count = 0;
                     print DBGOUT "mkinstaller:    ...\"".$TmpDirW.$slash."\" now contains\n" if $debugging;
                     while (defined($tmp = readdir(DIR))) {
                        if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                           print DBGOUT "mkinstaller:       \"".$tmp."\"\n" if $debugging;
                           $count += 1;
                        }
                     }
                     closedir(DIR);
                     if ($count <= 0) {
                        print DBGOUT "mkinstaller:       <nothing>\n" if $debugging;
                     }
                  }
                  else {
                     print DBGOUT "mkinstaller:    ...can't see what \"".$TmpDirW.$slash."\" contains\n" if $debugging;
                  }
                  print DBGOUT "mkinstaller:    cd back to \"$back\"\n" if $debugging;
                  if ( ! chdir($back)) {
                     my $fromWithin = `pwd`; chomp $fromWithin; $fromWithin =~ s/\r$//;
                     print STDERR "mkinstaller: error: can't cd back to \"$back\"\n";
                     print STDERR "mkinstaller: ...from within \"$fromWithin\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
               }
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  print DBGOUT "mkinstaller:    \"$bn\"\n" if $debugging;
                  if ( ! -d "$bn") {
                     print STDERR "mkinstaller: error: can't find \"$TmpDirA/$bn\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  my $cmd;
                  if ($tarIsGNUtar) {
                     $cmd    = "\"$use_tar\" -czf \"$TmpDirW/$bn.tar.gz\" \"$bn\"";
                  }
                  else {
                     $cmd    = "\"$use_tar\" -cf - \"$bn\" | \"$use_gzip\" > \"$TmpDirW/$bn.tar.gz\"";
                  }
                  print DBGOUT "mkinstaller:    ...run [$cmd]\n" if $debugging;
                  my $status = system "( $cmd ) >$devNull 2>$TmpFileE";
                  if ($status != 0) {
                     print DBGOUT "mkinstaller:       failed, exit code $status\n" if $debugging;
                     print STDERR "mkinstaller: error: can't tarup \"$bn\"\n";
                     print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                     print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                     if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                        pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                     }
                     unlink($TmpFileE);
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  print DBGOUT "mkinstaller:       succeeded\n" if $debugging;
                  if ( ! -f "$TmpDirW/$bn.tar.gz") {
                     print STDERR "mkinstaller: error: didn't tarup \"$bn\"\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"$TmpDirW/$bn.tar.gz\"\n";
                     print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                     if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                        pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                     }
                     unlink($TmpFileE);
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  unlink($TmpFileE);
                  if ($debugging) {
                     #
                     #  Show what the "wrapper" directory
                     #  now contains...
                     #
                     my $back = `pwd`; chomp $back; $back =~ s/\r$//;
                     print DBGOUT "mkinstaller:    cd into \"$TmpDirW\"\n" if $debugging;
                     print DBGOUT "mkinstaller:    ...from \"$back\"\n" if $debugging;
                     if ( ! chdir($TmpDirW)) {
                        my $fromWithin = `pwd`; chomp $fromWithin; $fromWithin =~ s/\r$//;
                        print STDERR "mkinstaller: error: can't cd into \"$TmpDirW\"\n";
                        print STDERR "mkinstaller: ...from within \"$fromWithin\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        close DBGOUT if $dbgOutToPathname ne "";
                        exit 1;
                     }
                     if (opendir(DIR,$TmpDirW)) {
                        my $count = 0;
                        print DBGOUT "mkinstaller:    ...\"".$TmpDirW.$slash."\" now contains\n" if $debugging;
                        while (defined($tmp = readdir(DIR))) {
                           if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                              print DBGOUT "mkinstaller:       \"".$tmp."\"\n" if $debugging;
                              $count += 1;
                           }
                        }
                        closedir(DIR);
                        if ($count <= 0) {
                           print DBGOUT "mkinstaller:       <nothing>\n" if $debugging;
                        }
                     }
                     else {
                        print DBGOUT "mkinstaller:    ...can't see what \"".$TmpDirW.$slash."\" contains\n" if $debugging;
                     }
                     print DBGOUT "mkinstaller:    cd back to \"$back\"\n" if $debugging;
                     if ( ! chdir($back)) {
                        my $fromWithin = `pwd`; chomp $fromWithin; $fromWithin =~ s/\r$//;
                        print STDERR "mkinstaller: error: can't cd back to \"$back\"\n";
                        print STDERR "mkinstaller: ...from within \"$fromWithin\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        close DBGOUT if $dbgOutToPathname ne "";
                        exit 1;
                     }
                  }
               }
            }
            print DBGOUT "mkinstaller:    cd back to \"$here\"\n" if $debugging;
            if ( ! chdir($here)) {
               my $fromWithin = `pwd`; chomp $fromWithin; $fromWithin =~ s/\r$//;
               print STDERR "mkinstaller: error: can't cd back to \"$here\"\n";
               print STDERR "mkinstaller: ...from within \"$fromWithin\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ($debugging) {
               my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
               print DBGOUT "mkinstaller:    back in \"$imInDir\"\n" if $debugging;
            }
            print DBGOUT "mkinstaller: ...copy the individual files into the wrapper directory\n" if $debugging;
            if ($debugging) {
               my $imInDir = `pwd`; chomp $imInDir; $imInDir =~ s/\r$//;
               print DBGOUT "mkinstaller:    now in \"$imInDir\"\n" if $debugging;
            }
            {
               my $bn;
               foreach $bn (sort keys %fileBasenames) {
                  print DBGOUT "mkinstaller:    \"$bn\"\n" if $debugging;
                  my $Spathname = pKit_joinpath($TmpDirA,$bn);
                  my $Dpathname = pKit_joinpath($TmpDirW,$bn);
                  if ( ! -f $Spathname) {
                     print STDERR "mkinstaller: error: can't find \"".pKit_nativePathname($Spathname)."\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  if ($use_cp eq "") {
                     #---------------------------------------
                     #
                     #  Locate cp (is required)...
                     #
                     #---------------------------------------

                     print DBGOUT "mkinstaller:    ...locate required \"cp\" utility...\n" if $debugging;
                     $use_cp = pKit_lookForExecutable("cp",\@myPATH,$OSclass);
                     if ($use_cp eq "") {
                        print STDERR "mkinstaller: error: can't locate required \"cp\" utility\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        close DBGOUT if $dbgOutToPathname ne "";
                        exit 1;
                     }
                     print DBGOUT "mkinstaller:       found \"".pKit_nativePathname($use_cp)."\"\n" if $debugging;
                  }
                  print DBGOUT "mkinstaller:    ...copy \"".pKit_nativePathname($Spathname)."\" in to \"".pKit_nativePathname($Dpathname)."\"\n" if $debugging;
                  my $cmd    = "\"".pKit_nativePathname($use_cp)."\" -p \"".pKit_nativePathname($Spathname)."\" \"".pKit_nativePathname($Dpathname)."\"";
                  print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
                  my $status = system "( $cmd ) >$devNull 2>&1";
                  if ($status != 0) {
                     print DBGOUT "mkinstaller:       failed, exit code $status\n" if $debugging;
                     print STDERR "mkinstaller: error: can't copy file \"".pKit_nativePathname($Spathname)."\" to temporary directory\"".$TmpDirW."\"\n";
                     print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                     print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($here)."\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
                  else {
                     print DBGOUT "mkinstaller:       succeeded\n" if $debugging;
                     if ( ! -f $Dpathname) {
                        print STDERR "mkinstaller: error: didn't copy file \"".pKit_nativePathname($Spathname)."\" to temporary directory\"".$TmpDirW."\"\n";
                        print STDERR "mkinstaller: ...[$cmd] failed\n";
                        print STDERR "mkinstaller: ...can't find \"".pKit_nativePathname($Dpathname)."\"\n";
                        print STDERR "mkinstaller:    was done from in \"".pKit_nativePathname($here)."\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        close DBGOUT if $dbgOutToPathname ne "";
                        exit 1;
                     }
                  }
               }
            }
            print DBGOUT "mkinstaller:    cd back to \"$here\"\n" if $debugging;
            if ( ! chdir($here)) {
               print STDERR "mkinstaller: error: can't cd back to \"$here\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
         }
         print DBGOUT "mkinstaller: ...done\n" if $debugging;

         #---------------------------------------
         #
         #  Add the given pre-install script (if
         #  any) to the wrapper directory.
         #
         #---------------------------------------

         if ($preInstallPathname ne "") {
            if ( -f $preInstallPathname) {
               my $Tstart = time();
               print STDERR "mkinstaller: working \"$preInstallPathname\" (a $preInstallStyle pre-install script)\n" if (1 <= $verbosityLevel);
               print DBGOUT "mkinstaller: add \"$preInstallPathname \" wrapper directory...\n" if $debugging;
               my $bn     = pKit_basename($preInstallPathname);
               my $cmd    = "cp -p \"$preInstallPathname\" \"$TmpDirW/$bn\"";
               print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "( $cmd ) >$devNull 2>&1";
               if ($status != 0) {
                  print DBGOUT "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error: can't add pre-install script to wrapper directory\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"$here\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               else {
                  print DBGOUT "mkinstaller:    succeeded\n" if $debugging;
                  if ( ! -f "$TmpDirW/$bn") {
                     print STDERR "mkinstaller: error: didn't add pre-install script to wrapper directory\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"$TmpDirW/$bn\"\n";
                     print STDERR "mkinstaller:    was done from in \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
               }
               print DBGOUT "mkinstaller: ...done\n" if $debugging;
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }
            else {
               print STDERR "mkinstaller: can't find \"$preInstallPathname\"\n" if (1 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller: no pre-install script\n" if (2 <= $verbosityLevel);
         }

         #---------------------------------------
         #
         #  Add the given post-install script (if
         #  any) to the wrapper directory.
         #
         #---------------------------------------

         if ($postInstallPathname ne "") {
            if ( -f $postInstallPathname) {
               my $Tstart = time();
               print STDERR "mkinstaller: working \"$postInstallPathname\" (a $postInstallStyle post-install script)\n" if (1 <= $verbosityLevel);
               print DBGOUT "mkinstaller: add \"$postInstallPathname \" wrapper directory...\n" if $debugging;
               my $bn     = pKit_basename($postInstallPathname);
               my $cmd    = "cp -p \"$postInstallPathname\" \"$TmpDirW/$bn\"";
               print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "( $cmd ) >$devNull 2>&1";
               if ($status != 0) {
                  print DBGOUT "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error: can't add post-install script to wrapper directory\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"$here\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               else {
                  print DBGOUT "mkinstaller:    succeeded\n" if $debugging;
                  if ( ! -f "$TmpDirW/$bn") {
                     print STDERR "mkinstaller: error: didn't add post-install script to wrapper directory\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"$TmpDirW/$bn\"\n";
                     print STDERR "mkinstaller:    was done from in \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     close DBGOUT if $dbgOutToPathname ne "";
                     exit 1;
                  }
               }
               print DBGOUT "mkinstaller: ...done\n" if $debugging;
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }
            else {
               print STDERR "mkinstaller: can't find \"$postInstallPathname\"\n" if (1 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller: no post-install script\n" if (2 <= $verbosityLevel);
         }

         #---------------------------------------
         #
         #  Finally tarup the temporary wrapper
         #  directory TmpDirW (carrying the individual
         #  tarballs).
         #
         #  Note that this wrapper tarball is NOT
         #  compressed (so giving a .tar file).
         #  Thus we don't care if it is GNU tar
         #  or not.
         #
         #---------------------------------------

         print DBGOUT "mkinstaller: tarup wrapper directory \"$TmpDirW\"...\n" if $debugging;
         {
            my $wasIn   = pKit_getWorkingDirectory(); # Should be same as $here
            my $under   = pKit_dirname($TmpDirW);
            my $wrapper = pKit_basename($TmpDirW);
            print DBGOUT "mkinstaller: ...under = \"$under\"\n" if $debugging;
            print DBGOUT "mkinstaller:     name = \"$wrapper\"\n" if $debugging;
            if ( ! chdir($under)) {
               print STDERR "mkinstaller: error: can't cd into \"$under\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            {
               print STDERR "mkinstaller: tarup wrapper directory \"$under/$wrapper\"\n" if (2 <= $verbosityLevel);
               my $Tstart = time();
               my $cmd    = "\"$use_tar\" -cf \"$wrapper.tar\" \"$wrapper\"";
               print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "( $cmd ) >$devNull 2>$TmpFileE";
               if ($status != 0) {
                  print DBGOUT "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error: can't tarup \"$under/$wrapper\"\n";
                  print STDERR "mkinstaller: ...[$cmd], failed returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"$under\"\n";
                  if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                     pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                  }
                  unlink($TmpFileE);
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               print DBGOUT "mkinstaller:    suceeded\n" if $debugging;
               if ( ! -f "$wrapper.tar") {
                  print STDERR "mkinstaller: error: didn't tarup \"$under/$wrapper\"\n";
                  print STDERR "mkinstaller: ...[$cmd], failed\n";
                  print STDERR "mkinstaller:    was done from in \"$under\"\n";
                  print STDERR "mkinstaller: ...can't find \"$under/$wrapper.tar\"\n";
                  if (( -f $TmpFileE) && ( -s $TmpFileE)) {
                     pKit_dumpTextfileToSTDERR($TmpFileE,"mkinstaller:    ");
                  }
                  unlink($TmpFileE);
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               unlink($TmpFileE);
               if ($debugging) {
                  print DBGOUT "mkinstaller: ...the tarball\n" if $debugging;
                  system "pwd";
                  system "/bin/ls -aldF \"$wrapper.tar\"";
                  system "pwd";
               }
               my $Tend   = time();
               my $dT     = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (2 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (2 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (2 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (2 <= $verbosityLevel);
               }
            }
            if ( ! chdir($wasIn)) {
               print STDERR "mkinstaller: error: can't cd back to \"$wasIn\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
         }
         print DBGOUT "mkinstaller: ...done\n" if $debugging;
      }

      #----------------------------------------------------------------------------
      #
      #  At this point the tarball (aka. the payload) is ready. It is now time to
      #  generate the installer script. Note that the generated installer script
      #  is a Bourne-Shell script. This is done using a "here document" technique
      #  the output being sent to a temporary textfile. While generation using a
      #  "here" document is typically simple, in this case the process is made
      #  complex due to the conditional generation involved. After the script
      #  generation is completed this temporary textfile and the tarball will be
      #  joined (using cat) to form the actual self-extracting installer script.
      #
      #----------------------------------------------------------------------------

      #---------------------------------------
      #
      #  If files to be placed in the PREFIX
      #  directory were supplied then the
      #  generated installer won't support
      #  individual prefix directories.
      #
      #---------------------------------------

      if (1 <= $fileBasenameCount) {
         print STDERR "mkinstaller:\n" if (1 <= $verbosityLevel);
         print STDERR "mkinstaller: note: The generated installer \"$scriptName\" will not\n";
         print STDERR "mkinstaller:         support individual prefix directories. The following\n";
         print STDERR "mkinstaller:         options will not be supported:\n";
         print STDERR "mkinstaller:\n";
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               print STDERR "mkinstaller:            --prefix-$bn=<pathname>\n";
            }
         }
         print STDERR "mkinstaller:\n";
         print STDERR "mkinstaller:         The --prefix=<pathname> will have to be used.\n";
         print STDERR "mkinstaller:\n" if (1 <= $verbosityLevel);
      }

      print DBGOUT "mkinstaller: form the Bourne-shell script...\n" if $debugging;
      {
         my $deletedOld = 0;
         print STDERR "mkinstaller: forming \"$scriptName\" Bourne-shell script\n" if (1 <= $verbosityLevel);
         if ( -f $TmpFile) {
            print STDERR "mkinstaller: ...delete old \"$scriptName\"\n" if (2 <= $verbosityLevel);
            if ( ! unlink $TmpFile) {
               print STDERR "mkinstaller: error: can't delete existing \"$scriptName\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ( -f $TmpFile) {
               print STDERR "mkinstaller: error: didn't delete existing \"$scriptName\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            $deletedOld = 1;
         }

         #---------------------------------------
         #
         #  Include the generation time in the
         #  script.
         #
         #---------------------------------------

         my $Tstart      = time();
         {
            local ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($Tstart);
            my @theMonth = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
            my $theYear  = $year + 1900;
            $GenTime     = $mday.$theMonth[$mon].$theYear."z";
         }
         if ($deletedOld) {
            print STDERR "mkinstaller: ...create new \"$scriptName\" script\n" if (2 <= $verbosityLevel);
         }
         if ( ! open(SCRIPT,"> $TmpFile")) {
            print STDERR "mkinstaller: error: can't create/write \"$scriptName\"\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         print SCRIPT "#!/bin/sh\n";
         if ($withNotice ne "") {
            print SCRIPT "#-------------------------------------------------------------------------------\n";
            print SCRIPT "#\n";
            my $i;
            for ($i=0; $i<=$#theNotice; $i+=1) {
               my $lineOfText = $theNotice[$i];
               if ($lineOfText ne "") {
                  print SCRIPT "#   $lineOfText\n";
               }
               else {
                  print SCRIPT "#\n";
               }
            }
            print SCRIPT "#\n";
            print SCRIPT "#-------------------------------------------------------------------------------\n";
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF01");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#   $scriptName
         |#
         |#   Generated by mkinstaller version $mkinstaller_ver_name rev. $mkinstaller_ver_time
         |#   on $GenTime
EOF01
         if ($theCommandLine ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF02");
         |#
         |#   The following command was used to generate this installer:
         |#
         |#       $theCommandLine
EOF02
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF03");
         |#
         |#-------------------------------------------------------------------------------
         |
         |commandPathname="\$0"
         |debugging=0         # Choose: 0 or 1
         |here="\`pwd\`"
EOF03
         if ($libDirBasename ne "") {
            print SCRIPT "LibDirBasename=\"$libDirBasename\"\n";
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF04");
         |
         |if [ "X\${DEBUG_$scriptNameU}" != "X" ]
         |then
         |   debugging=1
         |else
         |   if [ "X\${DEBUG}" != "X" ]
         |   then
         |      debugging=1
         |   fi
         |fi
         |
         |GeneratedBy="mkinstaller version $mkinstaller_ver_name rev. $mkinstaller_ver_time"
         |GeneratorVer="$mkinstaller_ver_name"
         |GeneratorCmd=
         |WasCompressed="$isCompressed"
         |
         |#---------------------------------------
         |#
         |#   This information is supplied at
         |#   run time with options or is simply
         |#   discovered by the script.
         |#
         |#---------------------------------------
         |
         |Enforce=            # Choose: true or false
         |HWtype=""
         |IntermediateName="$intermediateName"
         |IsGNUtar=           # Choose: true or false
         |IsGNUtarHow=""
         |JustQuery="false"   # Choose: true or false
         |keep="false"        # Choose: true or false
         |myPath=""
         |MyTmpDir=""
         |PerlOStype=""
         |showInfo=           # Choose: true or false
         |TheTimeNow=""
         |Use_awk=""          # These will be populated by
         |Use_expr=""         # searching the directories
         |Use_fgrep=""        # specified by PATH...
         |Use_grep=""
         |Use_gzcat=""
         |Use_gzip=""
         |Use_head=""
         |Use_ldd=""
         |Use_sed=""
         |Use_sort=""
         |Use_strings=""
         |Use_tail=""
         |Use_tar=""
         |Use_tr=""
         |Use_uname=""
         |
         |Use_cc=""
         |Use_cxx=""
         |
         |DefaultPrefix="$defaultPrefix"
         |PREFIX=""
EOF04

         my $bn;
         foreach $bn (sort keys %dirBasenames) {
            my $vn = $bn;
            $vn    =~ tr/a-zA-Z0-9_/_/c;
            print SCRIPT "PREFIX_$vn=\"\"\n";
         }

         if ($debugging) {
            if ($preInstallBasename ne "") {
               print DBGOUT "mkinstaller: ...has a $preInstallStyle pre-install script (\"$preInstallBasename\")\n" if $debugging;
            }
            else {
               print DBGOUT "mkinstaller: ...has NO pre-install script\n" if $debugging;
            }
            if ($postInstallBasename ne "") {
               print DBGOUT "mkinstaller: ...has a $postInstallStyle post-install script (\"$postInstallBasename\")\n" if $debugging;
            }
            else {
               print DBGOUT "mkinstaller: ...has NO post-install script\n" if $debugging;
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF05");
         |PreInstallScriptName="$preInstallBasename"
         |PreInstallScriptStyle="$preInstallStyle"
         |PostInstallScriptName="$postInstallBasename"
         |PostInstallScriptStyle="$postInstallStyle"
         |TmpDir=""
         |verbosityLevel=0
         |
         |#---------------------------------------
         |#
         |#  Support for wimpy VERBOSE_$scriptNameU
         |#  instead of the proper OPTS_$scriptNameU
         |#  environment variable...
         |#
         |#---------------------------------------
         |
         |if [ "X\${VERBOSE_$scriptNameU}" != "X" ]
         |then
         |   verbosityLevel=1
         |fi
EOF05

         my $NlibcList = $#CC_libc_verList + 1;
         my $CC_libc_verListString = "";
         if (1 <= $NlibcList) {
            my $i;
            for ($i=0; $i<$NlibcList; ++$i) {
               my $versionNum = $CC_libc_verList[$i];
               if ($i == 0) {
                  $CC_libc_verListString = $versionNum;
               }
               else {
                  $CC_libc_verListString = $CC_libc_verListString." ".$versionNum;
               }
            }
         }
         my $NabiList = $#CXX_stdcxxlib_abiVerList + 1;
         my $CXX_stdcxxlib_abiVerListString = "";
         if (1 <= $NabiList) {
            my $i;
            for ($i=0; $i<$NabiList; ++$i) {
               my $versionNum = $CXX_stdcxxlib_abiVerList[$i];
               if ($i == 0) {
                  $CXX_stdcxxlib_abiVerListString = $versionNum;
               }
               else {
                  $CXX_stdcxxlib_abiVerListString = $CXX_stdcxxlib_abiVerListString." ".$versionNum;
               }
            }
         }
         my $NstdlibcxxList              = $#CXX_stdcxxlib_verList + 1;
         my $CXX_stdcxxlib_verListString = "";
         if (1 <= $NstdlibcxxList) {
            my $i;
            for ($i=0; $i<$NstdlibcxxList; ++$i) {
               my $versionNum = $CXX_stdcxxlib_verList[$i];
               if ($i == 0) {
                  $CXX_stdcxxlib_verListString = $versionNum;
               }
               else {
                  $CXX_stdcxxlib_verListString = $CXX_stdcxxlib_verListString." ".$versionNum;
               }
            }
         }
         my $NlibcList = $#CXX_stdcxxlib_libcVerList + 1;
         my $CXX_stdcxxlib_libcVerListString = "";
         if (1 <= $NlibcList) {
            my $i;
            for ($i=0; $i<$NlibcList; ++$i) {
               my $versionNum = $CXX_stdcxxlib_libcVerList[$i];
               if ($i == 0) {
                  $CXX_stdcxxlib_libcVerListString = $versionNum;
               }
               else {
                  $CXX_stdcxxlib_libcVerListString = $CXX_stdcxxlib_libcVerListString." ".$versionNum;
               }
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF06");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#   Look for a number of tools:
         |#
         |#       awk
         |#       expr
         |#       fgrep
         |#       grep
         |#       gzcat (aka. zcat)
         |#       gzip
         |#       head
         |#       ldd
         |#       sed
         |#       strings
         |#       tail
         |#       tar
         |#       uname
         |#
         |#   Note that the PATH environment variable is translated in to a blank
         |#   separated value in our own local variable (myPath).
         |#
         |#   IMPORTANT: The method used doesn't work well with directories whose
         |#              names contains a space. There may be a method to get around
         |#              this problem by properly using IFS=: when scanning the PATH
         |#              but it isn't ready yet...
         |#
         |#   In deference to SunOS/Solaris we'll add /usr/xpg6/bin and /usr/xpg4/bin
         |#   to the front of the path (if they exist).
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: locate a number of utilities..." >&2
         |fi
         |if [ "X\${PATH}" = X ]
         |then
         |   echo "$scriptName: PATH is empty or not set" >&2
         |   exit 1
         |fi
         |if [ -d "/usr/xpg4/bin" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...include \\"/usr/xpg4/bin\\" " >&2
         |   fi
         |   PATH="/usr/xpg4/bin:\${PATH}"
         |fi
         |if [ -d "/usr/xpg6/bin" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...include \\"/usr/xpg6/bin\\" " >&2
         |   fi
         |   PATH="/usr/xpg6/bin:\${PATH}"
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: ...among the directories in PATH" >&2
         |   (  IFS=:
         |      for d in \${PATH}
         |      do
         |         echo "$scriptName:    \\"\${d}\\" " >&2
         |      done
         |   )
         |fi
         |
         |myPath=`echo \${PATH} | tr ":" " "`
         |if [ "X\${myPath}" = X ]
         |then
         |   echo "$scriptName: PATH could not be processed" >&2
         |   exit 1
         |fi
         |
         |if [ "X\${myPath}" != X ]
         |then
         |   #---------------------------------------
         |   #
         |   #  Look for awk
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/awk" ]
         |            then
         |               if [ -x "\${d}/awk" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_awk="\${d}/awk"
         |                         ;;
         |                     *)  Use_awk="\${here}/\${d}/awk"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for expr
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/expr" ]
         |            then
         |               if [ -x "\${d}/expr" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_expr="\${d}/expr"
         |                         ;;
         |                     *)  Use_expr="\${here}/\${d}/expr"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for fgrep
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/fgrep" ]
         |            then
         |               if [ -x "\${d}/fgrep" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_fgrep="\${d}/fgrep"
         |                         ;;
         |                     *)  Use_fgrep="\${here}/\${d}/fgrep"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for grep
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/grep" ]
         |            then
         |               if [ -x "\${d}/grep" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_grep="\${d}/grep"
         |                         ;;
         |                     *)  Use_grep="\${here}/\${d}/grep"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for gzcat
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/gzcat" ]
         |            then
         |               if [ -x "\${d}/gzcat" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_gzcat="\${d}/gzcat"
         |                         ;;
         |                     *)  Use_gzcat="\${here}/\${d}/gzcat"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   if [ "X\${Use_gzcat}" = "X" ]
         |   then
         |      #
         |      #  Note that gzcat is sometimes called zcat...
         |      #
         |      for d in \${myPath}
         |      do
         |         if [ X\${d} != X ]
         |         then
         |            if [ X\${d} != X. ]
         |            then
         |               if [ -f "\${d}/zcat" ]
         |               then
         |                  if [ -x "\${d}/zcat" ]
         |                  then
         |                     case "\${d}" in
         |                        /*) Use_gzcat="\${d}/zcat"
         |                            ;;
         |                        *)  Use_gzcat="\${here}/\${d}/zcat"
         |                            ;;
         |                     esac
         |                     break
         |                  fi
         |               fi
         |            fi
         |         fi
         |      done
         |   fi
         |   #---------------------------------------
         |   #
         |   #  Look for gzip
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/gzip" ]
         |            then
         |               if [ -x "\${d}/gzip" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_gzip="\${d}/gzip"
         |                         ;;
         |                     *)  Use_gzip="\${here}/\${d}/gzip"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for head
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/head" ]
         |            then
         |               if [ -x "\${d}/head" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_head="\${d}/head"
         |                         ;;
         |                     *)  Use_head="\${here}/\${d}/head"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for ldd
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/ldd" ]
         |            then
         |               if [ -x "\${d}/ldd" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_ldd="\${d}/ldd"
         |                         ;;
         |                     *)  Use_ldd="\${here}/\${d}/ldd"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for sed
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/sed" ]
         |            then
         |               if [ -x "\${d}/sed" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_sed="\${d}/sed"
         |                         ;;
         |                     *)  Use_sed="\${here}/\${d}/sed"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for sort
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/sort" ]
         |            then
         |               if [ -x "\${d}/sort" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_sort="\${d}/sort"
         |                         ;;
         |                     *)  Use_sort="\${here}/\${d}/sort"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for strings
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/strings" ]
         |            then
         |               if [ -x "\${d}/strings" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_strings="\${d}/strings"
         |                         ;;
         |                     *)  Use_strings="\${here}/\${d}/strings"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for tail
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/tail" ]
         |            then
         |               if [ -x "\${d}/tail" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_tail="\${d}/tail"
         |                         ;;
         |                     *)  Use_tail="\${here}/\${d}/tail"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for tar
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/tar" ]
         |            then
         |               if [ -x "\${d}/tar" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_tar="\${d}/tar"
         |                         ;;
         |                     *)  Use_tar="\${here}/\${d}/tar"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for tr
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/tr" ]
         |            then
         |               if [ -x "\${d}/tr" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_tr="\${d}/tr"
         |                         ;;
         |                     *)  Use_tr="\${here}/\${d}/tr"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |   #---------------------------------------
         |   #
         |   #  Look for uname
         |   #
         |   for d in \${myPath}
         |   do
         |      if [ X\${d} != X ]
         |      then
         |         if [ X\${d} != X. ]
         |         then
         |            if [ -f "\${d}/uname" ]
         |            then
         |               if [ -x "\${d}/uname" ]
         |               then
         |                  case "\${d}" in
         |                     /*) Use_uname="\${d}/uname"
         |                         ;;
         |                     *)  Use_uname="\${here}/\${d}/uname"
         |                         ;;
         |                  esac
         |                  break
         |               fi
         |            fi
         |         fi
         |      fi
         |   done
         |fi
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: ...using awk: [\${Use_awk}]" >&2
         |   echo "$scriptName:         expr: [\${Use_expr}]" >&2
         |   echo "$scriptName:        fgrep: [\${Use_fgrep}]" >&2
         |   echo "$scriptName:         grep: [\${Use_grep}]" >&2
         |   echo "$scriptName:        gzcat: [\${Use_gzcat}]" >&2
         |   echo "$scriptName:         gzip: [\${Use_gzip}]" >&2
         |   echo "$scriptName:         head: [\${Use_head}]" >&2
         |   echo "$scriptName:          ldd: [\${Use_ldd}]" >&2
         |   echo "$scriptName:          sed: [\${Use_sed}]" >&2
         |   echo "$scriptName:         sort: [\${Use_sort}]" >&2
         |   echo "$scriptName:      strings: [\${Use_strings}]" >&2
         |   echo "$scriptName:         tail: [\${Use_tail}]" >&2
         |   echo "$scriptName:        uname: [\${Use_uname}]" >&2
         |   echo "$scriptName:          tar: [\${Use_tar}]" >&2
         |   echo "$scriptName:           tr: [\${Use_tr}]" >&2
         |fi
         |
         |#---------------------------------------
         |#
         |#   Check if tar is GNU tar. The reason
         |#   we care is that GNU tar supports
         |#   decompression directly. If it isn't
         |#   the we'll have to use gzcat and/or
         |#   gzip to do the decompression work.
         |#
         |#---------------------------------------
         |
         |if [ "X\${IsGNUtar}" = "X" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: is \${Use_tar} GNU tar?..." >&2
         |      echo "$scriptName: ...run [( \${Use_tar} --version | \${Use_head} -n 1 | \${Use_grep} -q -w GNU ) 2>/dev/null && echo true || echo false]" >&2
         |   fi
         |   IsGNUtar=`( \${Use_tar} --version 2>/dev/null | \${Use_head} -n 1 | \${Use_grep} -q -w GNU ) && echo true || echo false`
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName:    done, gives [\${IsGNUtar}]" >&2
         |   fi
         |   if [ "X\${IsGNUtar}" = "Xtrue" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: ...\${Use_tar} looks like GNU tar" >&2
         |      fi
         |      IsGNUtarHow="checked"
         |   else
         |      if [ "X\${IsGNUtar}" = "Xfalse" ]
         |      then
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...\${Use_tar} doesn't look like GNU tar" >&2
         |         fi
         |         IsGNUtarHow="checked"
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...can't tell" >&2
         |         fi
         |         echo "$scriptName: warning: can't tell if tar is GNU tar or not, assume it is not" >&2
         |         exit 1
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#   This information was derived at
         |#   generation time on the source
         |#   system (where mkinstaller was
         |#   run).
         |#
         |#---------------------------------------
         |
         |Source_hw="$HWtype"
         |
         |Source_os="$OSname"
         |Source_os_version="$OSversion"
         |
         |Source_CC="$CC_basename"
         |Source_CC_pathname="$CC_pathname"
         |Source_CC_version="$CC_version"
         |Source_libc_pathname="$CC_libc_pathname"
         |Source_libc_verList="$CC_libc_verListString"
         |Source_libc_version="$CC_libc_version"
         |Source_libc_XversionX="$CC_libc_XversionX"
         |
         |Source_CXX="$CXX_basename"
         |Source_CXX_pathname="$CXX_pathname"
EOF06
         if ($CXX_basename ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF07");
         |Source_CXX_version="$CXX_version"
         |Source_stdcxxlib_pathname="$CXX_stdcxxlib_pathname"
         |Source_stdcxxlib_verList="$CXX_stdcxxlib_verListString"
         |Source_stdcxxlib_version="$CXX_stdcxxlib_version"
         |Source_stdcxxlib_abiVerList="$CXX_stdcxxlib_abiVerListString"
         |Source_stdcxxlib_abiVersion="$CXX_stdcxxlib_abiVersion"
         |Source_stdcxxlib_libcVerList="$CXX_stdcxxlib_libcVerListString"
         |Source_stdcxxlib_libcVersion="$CXX_stdcxxlib_libcVersion"
EOF07
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF08");
         |
         |#---------------------------------------
         |#
         |#   This information is derived at
         |#   installation time on the target
         |#   system (where the installer was
         |#   run).
         |#
         |#---------------------------------------
         |
         |Target_hw=""
         |
         |Target_os=""
         |Target_os_version=""
         |
         |Target_CC=""
         |Target_CC_pathname=""
         |Target_CC_version=""
         |Target_libc_pathname=""
         |Target_libc_verList=""
         |Target_libc_version=""
         |Target_libc_XversionX=""
         |
         |Target_CXX=""
         |Target_CXX_pathname=""
EOF08
         if ($CXX_basename ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF09");
         |Target_CXX_version=""
         |Target_stdcxxlib_pathname=""
         |Target_stdcxxlib_verList=""
         |Target_stdcxxlib_version=""
         |Target_stdcxxlib_abiVerList=""
         |Target_stdcxxlib_abiVersion=""
         |Target_stdcxxlib_libcVerList=""
         |Target_stdcxxlib_libcVersion=""
EOF09
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF10");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Get a reasonable type name for the hardware.
         |#
         |#  Collect, map, and return the hardware type. Mapping the string reported
         |#  by [uname -m] to something more reasonable. Note that the actual return
         |#  value is through the "global variable" HWtype (ugly but that is the way
         |#  that the Bourne-shell works).
         |#
         |#     UNIX-like (uses uname)
         |#
         |#        alpha    alpha
         |#        amd64    x86_64
         |#        armv7*   arm_32
         |#        armv8*   arm_64
         |#        BeBox    ppc_32
         |#        BeMac    ppc_32
         |#        BePC     x86_32
         |#        hp7??    hppa
         |#        hp8??    hppa
         |#        i?86     x86_32
         |#        i86*     x86_32
         |#        ia64     ia64
         |#        m68k     m68k
         |#        mips     mips_32
         |#        mips64   mips_64
         |#        Motorola mips_32
         |#        parisc   hppa
         |#        powerpc  ppc_32
         |#        ppc      ppc_32
         |#        ppc64    ppc_64
         |#        RISC*    m68k
         |#        sparc    sparc
         |#        sun3*    m68k
         |#        sun4*    sparc
         |#        tadpole* sparc
         |#        vax*     vax
         |#        x86_64   x86_64
         |#
         |#     Windows-like (look at %PROCESSOR_ARCHITECTURE%)
         |#
         |#        amd64    x86_64
         |#        x86      x86_32
         |#
         |#  see: totebag/src/sh-lib/idTheHardware.shfrag
         |#
         |#  Dated: 17Jan2019
         |#
         |#-------------------------------------------------------------------------------
         |
         |idTheHardware () {
         |   reported="\$1"
         |   HWtype=""
         |   if [ "X\${reported}" = "X" ]
         |   then
         |      reported=`\${Use_uname} -m 2>/dev/null`
         |   fi
         |   if [ "X\${reported}" != "X" ]
         |   then
         |      case "\${reported}" in
         |         9000/[34][0-9][0-9]*)  HWtype="m68k"
         |                                ;;
         |         9000/[678][0-9][0-9]*) HWtype="hppa"
         |                                ;;
         |         alpha*)                HWtype="x86_64"
         |                                ;;
         |         amd64*)                HWtype="x86_64"
         |                                ;;
         |         armv7*)                HWtype="arm_32"
         |                                ;;
         |         armv8*)                HWtype="arm_64"
         |                                ;;
         |         BeBox*)                HWtype="ppc_32"
         |                                ;;
         |         BeMac*)                HWtype="ppc_32"
         |                                ;;
         |         BePC*)                 HWtype="x86_32"
         |                                ;;
         |         hp[34][0-9][0-9]*)     HWtype="m68k"
         |                                ;;
         |         hp[678][0-9][0-9]*)    HWtype="hppa"
         |                                ;;
         |         i[0-9]86*)             HWtype="x86_32"
         |                                ;;
         |         i86*)                  HWtype="x86_32"
         |                                ;;
         |         ia64*)                 HWtype="ia64"
         |                                ;;
         |         m68k*)                 HWtype="m68k"
         |                                ;;
         |         mips32*)               HWtype="mips_32"
         |                                ;;
         |         mips64*)               HWtype="mips_64"
         |                                ;;
         |         mips*)                 HWtype="mips_32"
         |                                ;;
         |         Motorola*)             HWtype="mips_32"
         |                                ;;
         |         parisc*)               HWtype="hppa"
         |                                ;;
         |         powerpc*)              HWtype="ppc_32"
         |                                ;;
         |         ppc64*)                HWtype="ppc_64"
         |                                ;;
         |         ppc*)                  HWtype="ppc_32"
         |                                ;;
         |         RISC*)                 HWtype="m68k"
         |                                ;;
         |         sparc*)                HWtype="sparc"
         |                                ;;
         |         sun3*)                 HWtype="m68k"
         |                                ;;
         |         sun4*)                 HWtype="sparc"
         |                                ;;
         |         tadpole*)              HWtype="sparc"
         |                                ;;
         |         vax*)                  HWtype="vax"
         |                                ;;
         |         x86_64*)               HWtype="x86_64"
         |                                ;;
         |         *)                     HWtype="\${reported}"
         |                                ;;
         |      esac
         |   else
         |      HWtype=""
         |   fi
         |}
         |
         |# MyUniqueFileId: 41ebf5c3-9137-447f-8343-7952b43ad720
         |#-------------------------------------------------------------------------------
         |#
         |#  Map a uname string to the Perl equivalent.
         |#
         |#  Collect, map, and return the OS type. Mapping the string reported by [uname -s]
         |#  to something like what would be returned by Perl's special \$^O variable. Note
         |#  that the value is through the "global variable" OStype (ugly but that is the
         |#  way that the Bourne-shell works). In particular note how uname -s reports "SunOS"
         |#  but Perl reports "solaris".
         |#
         |#  return: The value is passed back through the global variable PerlOStype.
         |#
         |#  see: totebag/src/sh-lib/map_uname_s_to_perl.shfrag
         |#
         |#  Dated: 12Apr2019
         |#
         |#-------------------------------------------------------------------------------
         |
         |map_uname_s_to_perl () {
         |   reported="\$1"
         |   PerlOStype=""
         |   if [ "X\${reported}" = "X" ]
         |   then
         |      reported=`\${Use_uname} -s 2>/dev/null`
         |   fi
         |   if [ "X\${reported}" != "X" ]
         |   then
         |      reported=`echo \${reported} | \${Use_tr} '[:upper:]' '[:lower:]'`
         |      case "\${reported}" in
         |         aix*)                  PerlOStype="aix"
         |                                ;;
         |         bsd/os*)               PerlOStype="\${reported}"
         |                                ;;
         |         cygwin_nt-5.1*)        PerlOStype="\${reported}"
         |                                ;;
         |         darwin*)               PerlOStype="darwin"
         |                                ;;
         |         freebsd*)              PerlOStype="freebsd"
         |                                ;;
         |         gnu/kfreebsd*)         PerlOStype="\${reported}"
         |                                ;;
         |         hp/ux*)                PerlOStype="hpux"
         |                                ;;
         |         irix*)                 PerlOStype="irix"
         |                                ;;
         |         linux*)                PerlOStype="linux"
         |                                ;;
         |         netbsd*)               PerlOStype="\${reported}"
         |                                ;;
         |         openbsd*)              PerlOStype="\${reported}"
         |                                ;;
         |         osf1*)                 PerlOStype="dec_osf"
         |                                ;;
         |         sco_sv*)               PerlOStype="\${reported}"
         |                                ;;
         |         solaris*)              PerlOStype="solaris"
         |                                ;;
         |         sunos*)                PerlOStype="solaris"
         |                                ;;
         |         tru64*)                PerlOStype="dec_osf"
         |                                ;;
         |         ultrix*)               PerlOStype="\${reported}"
         |                                ;;
         |         unix_sv*)              PerlOStype="\${reported}"
         |                                ;;
         |         unixware*)             PerlOStype="\${reported}"
         |                                ;;
         |         xenix*)                PerlOStype="\${reported}"
         |                                ;;
         |         *)                     PerlOStype="\${reported}"
         |                                ;;
         |      esac
         |   else
         |      PerlOStype=""
         |   fi
         |}
         |
         |# MyUniqueFileId: 6c1d8e30-da00-4ed4-a51d-5e212a5528dd
         |#-------------------------------------------------------------------------------
         |#
         |#  Get the OS class.
         |#
         |#  This function is used to determine the OS class of of the host system.
         |#
         |#  Returns: Any of:
         |#
         |#              "UNIX-like"
         |#
         |#           The output is returned through output to <stdout>. The caller
         |#           is expected to backquote the call.
         |#
         |#  Note: This function always returns "UNIX-like" as this is a Bourne-shell
         |#        script which is only (reliably) supported on UNIX-like hosts. Yes
         |#        there are Bourne-shell implementations for Windows but we can't
         |#        rely on availability.
         |#
         |#  see: totebag/src/sh-lib/getOSclass.shfrag
         |#
         |#  Dated: 17Apr2019
         |#
         |#-------------------------------------------------------------------------------
         |
         |pKit_getOSclass () {
         |   echo "UNIX-like"
         |}
         |
         |# MyUniqueFileId: 9c8a5ab2-205b-45be-f8f0-5ea19ae45174
         |#-------------------------------------------------------------------------------
         |#
         |#  Get the OS name.
         |#
         |#  This function is used to determine the detailed OS name of of the host
         |#  system. It is recommended that this function be used rather than the
         |#  special scalar variable \$^O supplied by Perl as this is not particularly
         |#  accurate for example it doesn't distinguish SunOS from Solaris).
         |#
         |#  The first parameter is a "level of detail" (number), passing 0 returns
         |#  either "Unix-like" or "Windows-like" much like the pKit_getOSclass() function.
         |#  Passing 1 or more gives a more specific name. The value should be in the
         |#  range 0..3 The default is 1
         |#
         |#  The second parameter is a name such as returned by Perl's special \$^O
         |#  variable that is to be used. The default is to simply use the value of
         |#  Perl's special varable \$^O (this default is almost always what is wanted).
         |#
         |#  see: totebag/src/sh-lib/getOSname.shfrag
         |#
         |#  Dated: 01Sep2019
         |#
         |#  NOTE: This code has only been tested on FreeBSD, Linux, MacOS, and Solaris
         |#        Other other implementations has been known to work but haven't been
         |#        tested for years.
         |#
         |#-------------------------------------------------------------------------------
         |
         |getOSname () {
         |   levelOfDetail="\$1"
         |   given="\$2"
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "getOSname[ levelOfDetail=\\"\${levelOfDetail}\\", given=\\"\${given}\\"..." | "\${use_sendStdinTo}" \${debugOpt}
         |   fi
         |   gosnExitCode=0
         |   if [ "X\${levelOfDetail}" = "X" ]
         |   then
         |      levelOfDetail=1
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...assume levelOfDetail=\\"\${levelOfDetail}\\"..." | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |   fi
         |   if [ "X\${given}" = "X" ]
         |   then
         |      if [ "X\${Overide_caret_oh_with}" != "X" ]
         |      then
         |         given="\${Overide_caret_oh_with}"
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "getOSname: ...used override" | "\${use_sendStdinTo}" \${debugOpt}
         |         fi
         |      else
         |         given=`perl -e 'print \$^O."\\n"'`
         |      fi
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...assume given=\\"\${given}\\"..." | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |   fi
         |   given=`echo \${given} | tr '[:upper:]' '[:lower:]'`
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "getOSname: ...using given=\\"\${given}\\"..." | "\${use_sendStdinTo}" \${debugOpt}
         |   fi
         |   if [ "X\${given}" = "Xaix" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like IBM AIX" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      #
         |      #  NOTE: AIX detection hasn't been tested
         |      #
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ 3 -le \${levelOfDetail} ] && [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ]
         |               then
         |                  echo "AIX\${major}.\${minor}"
         |               else
         |                  echo "AIX\${major}"
         |               fi
         |            else
         |               echo "AIX"
         |            fi
         |         else
         |            echo "AIX"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "AIX"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xdarwin" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like MacOS" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if   [ "X\${major}" = "X18" ]
         |            then
         |               echo "MacOS X Mojave"
         |            elif [ "X\${major}" = "X17" ]
         |            then
         |               echo "MacOS X High Sierra"
         |            elif [ "X\${major}" = "X16" ]
         |            then
         |               echo "MacOS X Sierra"
         |            elif [ "X\${major}" = "X15" ]
         |            then
         |               echo "OS X El Capitan"
         |            elif [ "X\${major}" = "X14" ]
         |            then
         |               echo "OS X Yosemite"
         |            elif [ "X\${major}" = "X13" ]
         |            then
         |               echo "OS X Mavericks"
         |            elif [ "X\${major}" = "X12" ]
         |            then
         |               echo "OS X Mountain Lion"
         |            elif [ "X\${major}" = "X11" ]
         |            then
         |               echo "OS X Lion"
         |            elif [ "X\${major}" = "X10" ]
         |            then
         |               echo "OS X Snow Leopard"
         |            elif [ "X\${major}" = "X9" ]
         |            then
         |               echo "OS X Leopard"
         |            elif [ "X\${major}" = "X8" ]
         |            then
         |               echo "OS X Tiger"
         |            elif [ "X\${major}" = "X7" ]
         |            then
         |               echo "OS X Panther"
         |            elif [ "X\${major}" = "X6" ]
         |            then
         |               echo "OS X Jaguar"
         |            elif [ "X\${major}" = "X5" ] || { [ "X\${major}" = "X1" ] && [ "X\${minor}" = "X4" ] ; }
         |            then
         |               echo "OS X Puma"
         |            elif [ "X\${major}" = "X1" ] && [ "X\${minor}" = "X3" ]
         |            then
         |               echo "OS X Cheetah"
         |            elif [ "X\${major}" = "X1" ] && [ "X\${minor}" = "X2" ]
         |            then
         |               echo "OS X Kodiak"
         |            else
         |               echo "OS X"
         |            fi
         |         else
         |            echo "MacOS"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "MacOS"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xdec_osf" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like Tru64" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      #
         |      #  NOTE: Tru64/OSF detection hasn't been tested
         |      #
         |      if [ 1 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ \${major} -le 3 ]
         |               then
         |                  if [ 3 -le \${levelOfDetail} ] && { [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ] ; }
         |                  then
         |                     echo "OSF-\${major}.\${minor}"
         |                  elif [ 2 -le \${levelOfDetail} ]
         |                  then
         |                     echo "OSF-\${major}"
         |                  else
         |                     echo "OSF"
         |                  fi
         |               elif [ 4 -le \${major} ]
         |               then
         |                  if [ 3 -le \${levelOfDetail} ] && { [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ] ; }
         |                  then
         |                     echo "Tru64-\${major}.\${minor}"
         |                  elif [ 2 -le \${levelOfDetail} ]
         |                  then
         |                     echo "Tru64-\${major}"
         |                  else
         |                     echo "Tru64"
         |                  fi
         |               else
         |                  echo "Tru64"
         |               fi
         |            else
         |               echo "Tru64"
         |            fi
         |         else
         |            echo "Tru64"
         |         fi
         |      else
         |         echo "Unix-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xfreebsd" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like FreeBSD" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ 3 -le \${levelOfDetail} ] && { [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ] ; }
         |               then
         |                  echo "FreeBSD\${major}.\${minor}"
         |               else
         |                  echo "FreeBSD\${major}"
         |               fi
         |            else
         |               echo "FreeBSD"
         |            fi
         |         else
         |            echo "FreeBSD"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "FreeBSD"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xhaiku" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like Haiku" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      #
         |      #  NOTE: Haiku detection hasn't been tested
         |      #
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ 3 -le \${levelOfDetail} ] && { [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ] ; }
         |               then
         |                  echo "Haiku\${major}.\${minor}"
         |               else
         |                  echo "Haiku\${major}"
         |               fi
         |            else
         |               echo "Haiku"
         |            fi
         |         else
         |            echo "Haiku"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "Haiku"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xhpux" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like HPUX" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      #
         |      #  NOTE: HPUX detection hasn't been tested
         |      #
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*[AB]\\.\\([0-9][0-9]*\\)\\(\\.\\([0-9][0-9]*\\)\\)?.*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*[AB]\\.\\([0-9][0-9]*\\)\\(\\.\\([0-9][0-9]*\\)\\)?.*/\\3/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               echo "HP/UX-\${major}"
         |            else
         |               echo "HP/UX"
         |            fi
         |         else
         |            echo "HP/UX"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "HP/UX"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xirix" ] || [ "X\${given}" = "Xirix64" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like SGI Irix" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      #
         |      #  NOTE: IRIX detection hasn't been tested
         |      #
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ 3 -le \${levelOfDetail} ] && { [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ] ; }
         |               then
         |                  echo "Irix\${major}.\${minor}"
         |               else
         |                  echo "Irix\${major}"
         |               fi
         |            else
         |               echo "Irix"
         |            fi
         |         else
         |            echo "Irix"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "Irix"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xlinux" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like Linux" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ 3 -le \${levelOfDetail} ] && [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ]
         |               then
         |                  echo "Linux\${major}.\${minor}"
         |               else
         |                  echo "Linux\${major}"
         |               fi
         |            else
         |               echo "Linux"
         |            fi
         |         else
         |            echo "Linux"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         echo "Linux"
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xsolaris" ] || [ "X\${given}" = "Xsunos" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like Solaris or SunOS" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      if [ 2 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ "\${major}" -le 4 ]
         |               then
         |                  if [ 3 -le \${levelOfDetail} ] && { [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ] ; }
         |                  then
         |                     echo "SunOS\${major}.\${minor}"
         |                  else
         |                     echo "SunOS\${major}"
         |                  fi
         |               else
         |                  if [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ]
         |                  then
         |                     echo "Solaris\${minor}"
         |                  else
         |                     echo "Solaris"
         |                  fi
         |               fi
         |            else
         |               echo "Solaris"
         |            fi
         |         else
         |            echo "Solaris"
         |         fi
         |      elif [ 1 -le \${levelOfDetail} ]
         |      then
         |         if [ "X\${Overide_uname_r_with}" != "X" ]
         |         then
         |            gives="\${Overide_uname_r_with}"
         |         else
         |            gives=`uname -r 2>/dev/null`
         |         fi
         |         if [ "X\${gives}" != "X" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    version \\"\${gives}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            major=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1/'`
         |            minor=`echo \${gives} | sed -e 's/[ ]*\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\2/'`
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "getOSname:    major is \\"\${major}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |               echo "getOSname:    minor is \\"\${minor}\\" " | "\${use_sendStdinTo}" \${debugOpt}
         |            fi
         |            if [ "X\${major}" != "X" ] && [ "X\${major}" != "X\${gives}" ]
         |            then
         |               if [ "\${major}" -le 4 ]
         |               then
         |                  echo "SunOS\${major}"
         |               else
         |                  if [ "X\${minor}" != "X" ] && [ "X\${minor}" != "X\${gives}" ]
         |                  then
         |                     echo "Solaris\${minor}"
         |                  else
         |                     echo "Solaris"
         |                  fi
         |               fi
         |            else
         |               echo "Solaris"
         |            fi
         |         else
         |            echo "Solaris"
         |         fi
         |      else
         |         echo "UNIX-like"
         |      fi
         |      gosnExitCode=0
         |   elif [ "X\${given}" = "Xmswin32" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...looks like Windows (what?)" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      gosnExitCode=0
         |   else
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "getOSname: ...don't know what it looks like" | "\${use_sendStdinTo}" \${debugOpt}
         |      fi
         |      echo
         |      gosnExitCode=1
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "getOSname] ...done" | "\${use_sendStdinTo}" \${debugOpt}
         |   fi
         |   exit \${gosnExitCode}
         |}
         |
         |# MyUniqueFileId: b2a416c2-f30a-4413-f644-622628d205f4
         |#-------------------------------------------------------------------------------
         |#
         |#  This Bourne-shell function attempts to determine the compiler version by
         |#  invoking it with the appropriate option(s). The idea is to get it to report
         |#  the version number. Note that the version number is typically embedded in
         |#  a more complex message often including stuff like copyrights and such. The
         |#  real task here is matching and extracting the actual version number.
         |#
         |#  NOTE: A very plain vanilla version of sed that only supports very basic
         |#        regular expressions is assumed. The worst part is that the question
         |#        mark isn't supported (thus all to much repitiion).
         |#
         |#  04Jun2019
         |#
         |#-------------------------------------------------------------------------------
         |
         |Overide_caret_oh_with=
         |Overide_cc_v_with=
         |Overide_cxx_v_with=
         |Overide_f77_v_with=
         |Overide_uname_a_with=
         |Overide_uname_m_with=
         |Overide_uname_r_with=
         |Overide_uname_s_with=
         |Overide_ver_with=
         |
         |checkForCompilerVersion () {
         |   pathname=\$1
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "checkForCompilerVersion[ pathname=\${pathname}..." >&2
         |   fi
         |   theOSclass=`pKit_getOSclass`
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "checkForCompilerVersion: ...OSclass     = \\"\${theOSclass}\\" " >&2
         |   fi
         |   if [ "X\${Overide_caret_oh_with}" != "X" ]
         |   then
         |      theOSreported="\${Overide_caret_oh_with}"
         |      theOSreported=`echo \${theOSreported} | tr '[:upper:]' '[:lower:]'`
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "checkForCompilerVersion: ...OS reported = \\"\${theOSreported}\\" (assumed)" >&2
         |      fi
         |   else
         |      theOSreported=`perl -e 'print \$^O'`
         |      theOSreported=`echo \${theOSreported} | tr '[:upper:]' '[:lower:]'`
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "checkForCompilerVersion: ...OS reported = \\"\${theOSreported}\\" (actual)" >&2
         |      fi
         |   fi
         |   theOSname=`getOSname 3`
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "checkForCompilerVersion: ...OSname      = \\"\${theOSname}\\" " >&2
         |   fi
         |   theBasename=`basename \${pathname}`
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "checkForCompilerVersion: ...theBasename = \\"\${theBasename}\\" " >&2
         |   fi
         |   cfcvExitCode=0
         |   case "X\${theBasename}" in
         |      #---------------------------------------
         |      #
         |      #  HP C++ compiler naming...
         |      #
         |      #---------------------------------------
         |
         |      XaCC)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an HP C++ compiler" >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -V 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # CC: HP ANSI C++ B3910B B.03.14.06
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC: HP ANSI C++[ ][ ]*[^ ][^ ]*[ ][ ]*[A-Z]\\.\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      match=`echo \${match} | \${Use_sed} -e 's/^0*//'`
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC: HP ANSI C++[ ][ ]*[^ ][^ ]*[ ][ ]*[A-Z]\\.\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         Bcho "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      match=`echo \${match} | \${Use_sed} -e 's/^0*//'`
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  Microsoft compiler naming...
         |      #
         |      #     Note that this case should never
         |      #     arise as this is a Bourne-shell
         |      #     script and such script aren't
         |      #     supported on Windows.
         |      #
         |      #---------------------------------------
         |
         |      Xcl.exe|\\
         |      Xcl)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      if [ "X\${theOSclass}" = "XWindows-like" ]
         |                      then
         |                         echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a Microsoft C/C++ compiler on \\"Windows\\" " >&2
         |                      else
         |                         echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a Microsoft C/C++ compiler but not on \\"Windows\\" " >&2
         |                      fi
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  Clang C/C++ compiler...
         |      #
         |      #     Note that clang and clang++ are
         |      #     sometimes given funny names.
         |      #
         |      #---------------------------------------
         |
         |      Xbgclang-[0-9][0-9].[0-9][0-9]|\\
         |      Xbgclang-[0-9][0-9].[0-9]|\\
         |      Xbgclang-[0-9][0-9]|\\
         |      Xbgclang-[0-9].[0-9][0-9]|\\
         |      Xbgclang-[0-9].[0-9]|\\
         |      Xbgclang-[0-9]|\\
         |      Xbgclang|\\
         |      Xclang-[0-9][0-9].[0-9][0-9]|\\
         |      Xclang-[0-9][0-9].[0-9]|\\
         |      Xclang-[0-9][0-9]|\\
         |      Xclang-[0-9].[0-9][0-9]|\\
         |      Xclang-[0-9].[0-9]|\\
         |      Xclang-[0-9]|\\
         |      Xclang)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a clang C compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:       gives [\${response}]" >&2
         |                   fi
         |                   # Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn) Target: x86_64-apple-darwin13.4.0 Thread model: posix
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Apple[ ][ ]*LLVM[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (apple specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Apple[ ][ ]*LLVM[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (apple specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610 Target: x86_64-unknown-freebsd10.0 Thread model: posix" clang
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*FreeBSD[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (FreeBSD specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*FreeBSD[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (FreeBSD specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # Raspbian clang version 3.3 (tags/RELEASE_33/final 183502) 20130610 Target: x86_64-unknown-freebsd10.0 Thread model: posix" clang
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Raspbian[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (Raspbian specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Raspbian[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case F (Raspbian specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # Ubuntu clang version 3.4-1ubuntu3 (tags/RELEASE_34/final) (based on LLVM 3.4) Target: x86_64-pc-linux-gnu Thread model: posix
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Ubuntu[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case G (Ubuntu specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Ubuntu[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case H (Ubuntu specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case I (generic clang, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case J (generic clang, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([^ ][^ ]*\\)[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\3/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case K (generic clang, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([^ ][^ ]*\\)[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\3/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case L (generic clang, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case M (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xbgclang++-[0-9][0-9].[0-9][0-9]|\\
         |      Xbgclang++-[0-9][0-9].[0-9]|\\
         |      Xbgclang++-[0-9][0-9]|\\
         |      Xbgclang++-[0-9].[0-9][0-9]|\\
         |      Xbgclang++-[0-9].[0-9]|\\
         |      Xbgclang++-[0-9]|\\
         |      Xbgclang++|\\
         |      Xclang++-[0-9][0-9].[0-9][0-9]|\\
         |      Xclang++-[0-9][0-9].[0-9]|\\
         |      Xclang++-[0-9][0-9]|\\
         |      Xclang++-[0-9].[0-9][0-9]|\\
         |      Xclang++-[0-9].[0-9]|\\
         |      Xclang++-[0-9]|\\
         |      Xclang++)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a clang C++ compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # Apple LLVM version 6.0 ...
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Apple[ ][ ]*LLVM[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (Apple specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Apple[ ][ ]*LLVM[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (Apple specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # FreeBSD clang version 3.3 ...
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*FreeBSD[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (FreeBSD specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*FreeBSD[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (FreeBSD specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # Raspbian clang version 3.5.0-10+rpi1 ...
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Raspbian[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (Raspbian specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Raspbian[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case F (Raspbian specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # Ubuntu clang version 3.4-1ubuntu3 ...
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Ubuntu[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case G (Ubuntu specific, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Ubuntu[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case H (Ubuntu specific, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case I (generic clang++, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case J (generic clang++, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([^ ][^ ]*\\)[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\3/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case K (generic clang++, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([^ ][^ ]*\\)[ ][ ]*clang[ ][ ]*version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\3/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case L (generic clang++, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case M (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  Generic compiler naming...
         |      #
         |      #---------------------------------------
         |
         |      Xcc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a generic C compiler (cc) on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      if [ "X\${Overide_cc_v_with}" != "X" ]
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                         fi
         |                         response="\${Overide_cc_v_with}"
         |                         status=0
         |                      else
         |                         if [ "X\${theOSreported}" = "Xsunos" ] || [ "X\${theOSreported}" = "Xsolaris" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -V 2>&1]" >&2
         |                            fi
         |                            response=`"\${pathname}" -V 2>&1`
         |                            status=\$?
         |                         else
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -V 2>/dev/null]" >&2
         |                            fi
         |                            response=`"\${pathname}" -V 2>/dev/null`
         |                            status=\$?
         |                         fi
         |                      fi
         |                      response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                      response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                      response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:       gives [\${response}]" >&2
         |                      fi
         |                      # cc: Studio 12.6 Sun C 5.15 ...
         |                      if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun[ ][ ]*C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case D (Sun C compiler, 3-part and 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun[ ][ ]*C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case E (Sun C compiler, 2-part and 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun[ ][ ]*C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case F (Sun C compiler, 3-part and 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun[ ][ ]*C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case G (Sun C compiler, 2-part and 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      # cc: Sun C 5.8 2005/10/13 usage: cc [ options] files. Use cc -flags for details
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Sun[ ][ ]*C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case H (Sun C compiler, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Sun[ ][ ]*C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case I (Sun C compiler, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      # DEC C V1.2 ...
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*DEC C V\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case J (DEC C compiler on Tru64 or OSF/1, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*DEC C V\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case K (DEC C compiler on Tru64 or OSF/1, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      # Compaq C V6.5-011 on Compaq True64 UNIX V5.1B (Rev. 2650)
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Compaq C V\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case L (Compaq C compiler on Tru64 or OSF/1, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Compaq C V\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case M (Compaq C compiler on Tru64 or OSF/1, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case N (failure)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         cfcvExitCode=1
         |                      fi
         |                   fi
         |                   ;;
         |
         |      Xcxx)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a generic C++ compiler (cxx) on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (GNU gcc under the covers, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (GNU gcc under the covers, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      if [ "X\${Overide_cc_v_with}" != "X" ]
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                         fi
         |                         response="\${Overide_cc_v_with}"
         |                         status=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -V]" >&2
         |                         fi
         |                         response=`"\${pathname}" -V`
         |                         status=\$?
         |                      fi
         |                      response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                      response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                      response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                      # DEC C++ V1.2 ...
         |                      if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*DEC C++ V\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case D (DEC C++ compiler on Tru64 or OSF/1, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*DEC C++ V\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case E (DEC C++ compiler on Tru64 or OSF/1, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      # DEC C++ V6.5-011 on Compaq True64 UNIX V5.1B (Rev. 2650)
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Compaq C++ V\\([0-9][0-9]*\\.[0-9][0-9]*.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case F (Compaq C++ compiler on Tru64 or OSF/1, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*Compaq C++ V\\([0-9][0-9]*.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case G (Compaq C++ compiler on Tru64 or OSF/1, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case H (failure)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         cfcvExitCode=1
         |                      fi
         |                   fi
         |                   ;;
         |
         |      Xc++)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a generic C++ compiler (c++) on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      XCC)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a generic C++ compiler (CC) on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                      if [ "X\${status}" != 0 ]
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:       failed, exit code is \${status}" >&2
         |                         fi
         |                         if [ "X\${theOSreported}" = "Xsunos" ] || [ "X\${theOSreported}" = "Xsolaris" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -V 2>&1]" >&2
         |                            fi
         |                            response=`"\${pathname}" -V 2>&1`
         |                            status=\$?
         |                         else
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -V 2>/dev/null]" >&2
         |                            fi
         |                            response=`"\${pathname}" -V 2>/dev/null`
         |                            status=\$?
         |                         fi
         |                         if [ "X\${status}" != 0 ]
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:       failed, exit code is \${status}" >&2
         |                            fi
         |                         fi
         |                      fi
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   # CC: Studio 12.6 Sun C++ 5.15 SunOS_sparc 2017/05/30
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (Studio 3-part, Sun C++, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (Studio 3-part, Sun C++, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (Studio 2-part, Sun C++, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case F (Studio 2-part, Sun C++, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case G (Sun C++, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case H (Sun C++, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case I (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xf77)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a generic FORTRAN 77 compiler (f77) on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${theOSreported}" = "Xirix" ] || [ "X\${theOSreported}" = "Xirix64" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    on an SGI, probably native" >&2
         |                      fi
         |                      if [ "X\${Overide_f77_v_with}" != "X" ]
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                         fi
         |                         response="\${Overide_f77_v_with}"
         |                         status=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -version]" >&2
         |                         fi
         |                         response=`"\${pathname}" -version`
         |                         status=\$?
         |                      fi
         |                      response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                      response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                      response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                      if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*MIPSpro[ ][ ]*Compilers:[ ][ ]*Version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case A (SGI Irix3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*MIPSpro[ ][ ]*Compilers:[ ][ ]*Version[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case B (SGI Irix2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case C (SGI Irix failure)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         cfcvExitCode=1
         |                      fi
         |                   elif [ "X\${theOSreported}" = "Xsunos" ] || [ "X\${theOSreported}" = "Xsolaris" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    on an SUN, probably native" >&2
         |                      fi
         |                      if [ "X\${Overide_f77_v_with}" != "X" ]
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                         fi
         |                         response="\${Overide_f77_v_with}"
         |                         status=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -version]" >&2
         |                         fi
         |                         response=`"\${pathname}" -version 2>&1`
         |                         status=\$?
         |                      fi
         |                      response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                      response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                      response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                      if match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Sun[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case A (Sun specific, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Sun[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case B (Sun specific, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case C (Sun Studio specific, 3-part and 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case D (Sun Studio specific, 2-part and 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case E (Sun Studio specific, 3-part and 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case F (Sun Studio specific, 2-part and 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case G (failure)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         if [ "X\${Overide_f77_v_with}" != "X" ]
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                            fi
         |                            response="\${Overide_f77_v_with}"
         |                            status=0
         |                         else
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" -version]" >&2
         |                            fi
         |                            response=`"\${pathname}" -V 2>&1`
         |                            status=\$?
         |                         fi
         |                         response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                         response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                         response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                         if match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Sun[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case H (Sun specific, 3-part)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            echo "\${theBasename} \${match}"
         |                            cfcvExitCode=0
         |                         elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Sun[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case I (Sun specific, 2-part)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            echo "\${theBasename} \${match}"
         |                            cfcvExitCode=0
         |                         elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case J (Sun Studio specific, 3-part and 3-part)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            echo "\${theBasename} \${match}"
         |                            cfcvExitCode=0
         |                         elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case K (Sun Studio specific, 2-part and 3-part)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            echo "\${theBasename} \${match}"
         |                            cfcvExitCode=0
         |                         elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case L (Sun Studio specific, 3-part and 2-part)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            echo "\${theBasename} \${match}"
         |                            cfcvExitCode=0
         |                         elif match=`echo \${response} | \${Use_sed} -e 's/^..*[ ][ ]*-f77[ ][ ]*.*f90:[ ][ ]*Studio[ ][ ]*[0-9][0-9]*\\.[0-9][0-9]*[ ][ ]*Fortran[ ][ ]*95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                         then
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case M (Sun Studio specific, 2-part and 2-part)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            echo "\${theBasename} \${match}"
         |                            cfcvExitCode=0
         |                         else
         |                            if [ "X\${debugging}" != "X0" ]
         |                            then
         |                               echo "checkForCompilerVersion:    ...case N (failure)" >&2
         |                               echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                            fi
         |                            cfcvExitCode=1
         |                         fi
         |                      fi
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    not an SGI or SUN" >&2
         |                      fi
         |                      if [ "X\${Overide_f77_v_with}" != "X" ]
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                         fi
         |                         response="\${Overide_f77_v_with}"
         |                         status=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                         fi
         |                         response=`"\${pathname}" --version`
         |                         status=\$?
         |                      fi
         |                      response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                      response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                      response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                      if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case A (GNU Fortran specific, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case B (GNU Fortran specific, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case C (GNU Fortran specific, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case D (GNU Fortran specific, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case E (Sun specific, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case F (Sun specific, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case G (Sun specific, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case H (Sun specific, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      # NOTICE: Invoking /opt/SUNWspro/opt/developerstudio12.6/bin/f90 -f77 -ftrap=%none -V f90: Studio 12.6 Fortran 95 8.8 SunOS_i386 2017/05/30
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\4/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case I (Sun Studio specific, 3-part and 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\4/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case J (Sun Studio specific, 3-part and 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\4/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case K (Sun Studio specific, 2-part and 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Studio[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\)[ ][ ]*Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\4/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case L (Sun Studio specific, 2-part and 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case M (generic, 3-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                      then
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case N (generic, 2-part)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         echo "\${theBasename} \${match}"
         |                         cfcvExitCode=0
         |                      else
         |                         if [ "X\${debugging}" != "X0" ]
         |                         then
         |                            echo "checkForCompilerVersion:    ...case O (failure)" >&2
         |                            echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                         fi
         |                         cfcvExitCode=1
         |                      fi
         |                   fi
         |                   ;;
         |
         |      Xf90)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a generic FORTRAN 90 compiler (f90) on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  GNU compilers...
         |      #
         |      #---------------------------------------
         |
         |      Xg77-[0-9][0-9].[0-9][0-9]|\\
         |      Xg77-[0-9][0-9].[0-9]|\\
         |      Xg77-[0-9][0-9]|\\
         |      Xg77-[0-9].[0-9][0-9]|\\
         |      Xg77-[0-9].[0-9]|\\
         |      Xg77-[0-9]|\\
         |      Xg77)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an older GNU FORTRAN 77 compiler on \\"\${theOSname}\\" " >&2
         |                      cfcvExitCode=1
         |                   fi
         |                   if [ "X\${Overide_f77_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f77_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # GNU Fortran 0.5.26 20000731 (Red Hat Linux 7.2 2.96-128.7.2) ...
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU[ ][ ]*Fortran[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU[ ][ ]*Fortran[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU[ ][ ]*Fortran[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU[ ][ ]*Fortran[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU[ ][ ]*Fortran[ ][ ]*([^)]*([^)]*)[^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (3-aprt)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU[ ][ ]*Fortran[ ][ ]*([^)]*([^)]*)[^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case F (2-aprt)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case G (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xgcc-[0-9][0-9].[0-9][0-9]|\\
         |      Xgcc-[0-9][0-9].[0-9]|\\
         |      Xgcc-[0-9][0-9]|\\
         |      Xgcc-[0-9].[0-9][0-9]|\\
         |      Xgcc-[0-9].[0-9]|\\
         |      Xgcc-[0-9]|\\
         |      Xgcc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a GNU C compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # 2.96
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1x/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      match=`expr " \${match}" : ' \\(.*\\).'`
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (ancient GNU C compiler, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1x/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      match=`expr " \${match}" : ' \\(.*\\).'`
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (ancient GNU C compiler, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*egcs-\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (ancient EDG C compiler, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*egcs-\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (ancient EDG C compiler, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (typical GNU C compiler, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case F (typical GNU C compiler, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case G (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xgfortran-[0-9][0-9].[0-9][0-9]|\\
         |      Xgfortran-[0-9][0-9].[0-9]|\\
         |      Xgfortran-[0-9][0-9]|\\
         |      Xgfortran-[0-9].[0-9][0-9]|\\
         |      Xgfortran-[0-9].[0-9]|\\
         |      Xgfortran-[0-9]|\\
         |      Xgfortran)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a newer GNU FORTRAN 77 compiler on \\"\${theOSname}\\" " >&2
         |                      cfcvExitCode=1
         |                   fi
         |                   if [ "X\${Overide_f77_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f77_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran 95[ ][ ]*([^)]*) [ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran 95[ ][ ]*([^)]*) [ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ]*([^)]*) [ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ]*([^)]*) [ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xg++-[0-9][0-9].[0-9][0-9]|\\
         |      Xg++-[0-9][0-9].[0-9]|\\
         |      Xg++-[0-9].[0-9][0-9]|\\
         |      Xg++-[0-9].[0-9]|\\
         |      Xg++-[0-9][0-9]|\\
         |      Xg++-[0-9]|\\
         |      Xg++)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like GNU C++ compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if   match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1x/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      match=`expr " \${match}" : ' \\(.*\\).'`
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (ancient GNU C++ compiler, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1x/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      match=`expr " \${match}" : ' \\(.*\\).'`
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (ancient GNU C++ compiler, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*egcs-\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (ancient EDG C++ compiler, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*egcs-\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (ancient EDG C++ compiler, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (typical GNU C++ compiler, 3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (typical GNU C++ compiler, 2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  Intel compilers...
         |      #
         |      #---------------------------------------
         |
         |      Xicc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    looks like Intel C compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xicpc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    looks like Intel C++ compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xifort)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    looks like Intel FORTRAN compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_f77_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f77_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" --version`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  Microsoft linker naming...
         |      #
         |      #     Note that this case should never
         |      #     arise as this is a Bourne-shell
         |      #     script and such script aren't
         |      #     supported on Windows.
         |      #
         |      #---------------------------------------
         |
         |      Xlink.exe|\\
         |      Xlink)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a Microsoft C/C++ linker on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  MPI compiler wrappers...
         |      #
         |      #---------------------------------------
         |
         |      Xmpicc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a mpi-parallel C compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      if [ -x "\${pathname}" ]
         |                      then
         |                         response=`"\${pathname}" --version`
         |                         status=\$?
         |                      else
         |                         response=
         |                         status=1
         |                      fi
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      XmpiCC|\\
         |      Xmpicxx)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an mpi-parallel C++ compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      if [ -x "\${pathname}" ]
         |                      then
         |                         response=`"\${pathname}" --version`
         |                         status=\$?
         |                      else
         |                         response=
         |                         status=1
         |                      fi
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xmpif77)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an mpi-parallel FORTRAN 77 compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_f77_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f77_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      if [ -x "\${pathname}" ]
         |                      then
         |                         response=`"\${pathname}" --version`
         |                         status=\$?
         |                      else
         |                         response=
         |                         status=1
         |                      fi
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*GNU Fortran[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*ifort[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*ifort[ ][ ]*([^)]*)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case E (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  Portland Group compilers...
         |      #
         |      #---------------------------------------
         |
         |      Xpgcc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a PGI C compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      XpgCC)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a PGI C++ compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      Xpgf77)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a PGI FORTRAN 77 compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      Xpgf90)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a PGI FORTRAN 90 compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      Xpgf95)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a PGI FORTRAN 95 compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  SUN compilers...
         |      #
         |      #---------------------------------------
         |
         |      Xsuncc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a SunPRO C compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -V 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Sun C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*cc:[ ][ ]*Sun C[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      XsunCC)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a SunPRO C++ compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -V 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*CC:[ ][ ]*Sun C++[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xsunf77)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a SunPRO FORTRAN 77 compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_f77_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f77_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -V 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*NOTICE: Invoking \\(.*\\)f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\2/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case D (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xsunf90)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a SunPRO FORTRAN 90 compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_f90_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f90_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -V 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xsunf95)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like a SunPRO FORTRAN 95 compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_f95_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f95_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -V 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*f[0-9][0-9]:[ ][ ]*Sun Fortran 95[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  IBM compilers...
         |      #
         |      #---------------------------------------
         |
         |      Xxlc)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an IBM C compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cc_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cc_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -qversion 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # IBM XL C/C++ for Blue Gene, V12.1 Version: 12.01.0000.0014
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*IBM XL C\\/C++ for Blue Gene, V\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*IBM XL C\\/C++ for Blue Gene, V\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      XxlC)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an IBM C++ compiler on \\"\${theOSname}\\" " >&2
         |                   fi
         |                   if [ "X\${Overide_cxx_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_cxx_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -qversion 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # IBM XL C/C++ for Blue Gene, V12.1 Version: 12.01.0000.0014
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*IBM XL C\\/C++ for Blue Gene, V\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*IBM XL C\\/C++ for Blue Gene, V\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xxlf)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an IBM FORTRAN 77 compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   if [ "X\${Overide_f77_v_with}" != "X" ]
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...assume output of [\\"\${pathname}\\" ...]" >&2
         |                      fi
         |                      response="\${Overide_f77_v_with}"
         |                      status=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...run [\\"\${pathname}\\" --version]" >&2
         |                      fi
         |                      response=`"\${pathname}" -qversion 2>&1`
         |                      status=\$?
         |                   fi
         |                   response=`echo \${response} | tr -d '\\042\\047\\140' `
         |                   response=`echo \${response} | \${Use_sed} -e '\$ s/\\(.*\\)\\r?\\n\$/\\1/' | tr '[:space:]' ' '`
         |                   response=`echo \${response} | \${Use_sed} -e 's/^[ ]*\\([^ ].*[^ ]\\)[ ]*\$/\\1/'`
         |                   # IBM XL Fortran for Blue Gene, V14.1 Version: 14.01.0000.0014
         |                   if match=`echo \${response} | \${Use_sed} -e 's/^[ ]*IBM XL Fortran for Blue Gene, V\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case A (3-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   elif match=`echo \${response} | \${Use_sed} -e 's/^[ ]*IBM XL Fortran for Blue Gene, V\\([0-9][0-9]*\\.[0-9][0-9]*\\).*\$/\\1/'` ; [ "X\${match}" != "X\${response}" ] ;
         |                   then
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case B (2-part)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      echo "\${theBasename} \${match}"
         |                      cfcvExitCode=0
         |                   else
         |                      if [ "X\${debugging}" != "X0" ]
         |                      then
         |                         echo "checkForCompilerVersion:    ...case C (failure)" >&2
         |                         echo "checkForCompilerVersion:       match was [\${match}]" >&2
         |                      fi
         |                      cfcvExitCode=1
         |                   fi
         |                   ;;
         |
         |      Xxlf90)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an IBM FORTRAN 90 compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      Xxlf95)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    \\"\${pathname}\\" looks like an IBM FORTRAN 95 compiler on \\"\${theOSname}\\" " >&2
         |                      echo "checkForCompilerVersion:    ...\\"\${theBasename}\\" not implemented yet" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |
         |      #---------------------------------------
         |      #
         |      #  An unknown compiler...
         |      #
         |      #---------------------------------------
         |
         |      *)
         |                   if [ "X\${debugging}" != "X0" ]
         |                   then
         |                      echo "checkForCompilerVersion:    don't know what it looks like" >&2
         |                   fi
         |                   cfcvExitCode=1
         |                   ;;
         |   esac
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "checkForCompilerVersion] ...done(=\${cfcvExitCode})" >&2
         |   fi
         |   exit \${cfcvExitCode}
         |}
         |
         |#---------------------------------------
         |#
         |#   We will eventually need to know
         |#   where this script is actually
         |#   located.
         |#
         |#---------------------------------------
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: locate this script..." >&2
         |fi
         |bn=\`basename \${commandPathname}\`
         |if [ "X\${commandPathname}" = "X\${bn}" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...\\"\${commandPathname}\\" is simple" >&2
         |   fi
         |   if [ "X\${PATH}" != "X" ]
         |   then
         |      myPath=\`echo \${PATH} | \${Use_tr} ":" " "\`
         |   else
         |      echo "\${scriptName}: error: PATH is not set" >&2
         |      exit 1
         |   fi
         |   foundIn=
         |   for d in \${myPath}
         |   do
         |      if [ -d "\${d}" ]
         |      then
         |         case "X\${d}" in
         |            X/*)
         |                 ;;
         |            X*)  d="\${here}/\${d}"
         |                 ;;
         |         esac
         |         if [ -f "\${d}/$scriptName" ]
         |         then
         |            if [ -x "\${d}/$scriptName" ]
         |            then
         |               foundIn="\${d}"
         |               commandPathname="\${d}/$scriptName"
         |               break
         |            fi
         |         fi
         |      fi
         |   done
         |   if [ "X\${foundIn}" = "X" ]
         |   then
         |      echo "$scriptName: error: can't locate this script" >&2
         |      exit 1
         |   fi
         |else
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...\\"\${commandPathname}\\" is NOT simple" >&2
         |   fi
         |   dn=\`dirname \${commandPathname}\`
         |   bn=\`basename \${commandPathname}\`
         |   case "X\${dn}" in
         |      X/*)
         |           if [ "X\${debugging}" != "X0" ]
         |           then
         |              echo "$scriptName:    \\"\${commandPathname}\\" is absolute" >&2
         |           fi
         |           ;;
         |      X*)  if [ "X\${debugging}" != "X0" ]
         |           then
         |              echo "$scriptName:    \\"\${commandPathname}\\" is releative" >&2
         |           fi
         |           commandPathname="\`pwd\`/\${commandPathname}"
         |           if [ "X\${debugging}" != "X0" ]
         |           then
         |              echo "$scriptName:    ...consider \\"\${commandPathname}\\" " >&2
         |           fi
         |           dn=\`dirname "\${commandPathname}"\`
         |           bn=\`basename "\${commandPathname}"\`
         |           if [ "X\${debugging}" != "X0" ]
         |           then
         |              echo "$scriptName:       is in \\"\${dn}\\" " >&2
         |              echo "$scriptName:       is called \\"\${bn}\\" " >&2
         |           fi
         |           ;;
         |   esac
         |   foundIn="\${dn}"
         |   commandPathname="\${dn}/\${bn}"
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: ...in \\"\${foundIn}\\" " >&2
         |   echo "$scriptName:    as \\"\${commandPathname}\\" " >&2
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Deal with TMPDIR...
         |#
         |#  Note: It would be desirable to replace the next 183 lines with a call
         |#        to the pfindtmpd Perl script. However that does introduce an
         |#        outside dependency which we'd like to avoid in this script.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: identify temp directory..." >&2
         |fi
         |
         |if [ "X\${$SCRIPTNAME_TMPDIR}" != "X" ]
         |then
         |   if [ -d "\${$SCRIPTNAME_TMPDIR}" ]
         |   then
         |      if [ -w "\${$SCRIPTNAME_TMPDIR}" ]
         |      then
         |         TMPDIR="\${$SCRIPTNAME_TMPDIR}" ; export TMPDIR
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...from $SCRIPTNAME_TMPDIR" >&2
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was specified then
         |#  make sure its valid...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" != "X" ]
         |then
         |   if [ -d "\${TMPDIR}" ]
         |   then
         |      if [ -w "\${TMPDIR}" ]
         |      then
         |         true
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...from TMPDIR" >&2
         |         fi
         |      else
         |         TMPDIR="" ; export TMPDIR
         |      fi
         |   else
         |      TMPDIR="" ; export TMPDIR
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using TMP if it is defined and
         |#  is valid...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   if [ "X\${TMP}" != "X" ]
         |   then
         |      tryDir="\${TMP}"
         |      if [ -d "\${tryDir}" ]
         |      then
         |         if [ -w "\${tryDir}" ]
         |         then
         |            TMPDIR="\${tryDir}" ; export TMPDIR
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName: ...from TMP" >&2
         |            fi
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using TEMP if it is defined and
         |#  is valid...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   if [ "X\${TEMP}" != "X" ]
         |   then
         |      tryDir="\${TEMP}"
         |      if [ -d "\${tryDir}" ]
         |      then
         |         if [ -w "\${tryDir}" ]
         |         then
         |            TMPDIR="\${tryDir}" ; export TMPDIR
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName: ...from TEMP" >&2
         |            fi
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using tmp in the user's home
         |#  directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   if [ "X\${HOME}" != "X" ]
         |   then
         |      tryDir="\${HOME}/tmp"
         |      if [ -d "\${tryDir}" ]
         |      then
         |         if [ -w "\${tryDir}" ]
         |         then
         |            TMPDIR="\${tryDir}" ; export TMPDIR
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName: ...using HOME" >&2
         |            fi
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using /tmp directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   tryDir="/tmp"
         |   if [ -d "\${tryDir}" ]
         |   then
         |      if [ -w "\${tryDir}" ]
         |      then
         |         TMPDIR="\${tryDir}" ; export TMPDIR
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using /var/tmp directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   tryDir="/var/tmp"
         |   if [ -d "\${tryDir}" ]
         |   then
         |      if [ -w "\${tryDir}" ]
         |      then
         |         TMPDIR="\${tryDir}" ; export TMPDIR
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using the current directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   tryDir="."
         |   if [ -d "\${tryDir}" ]
         |   then
         |      if [ -w "\${tryDir}" ]
         |      then
         |         TMPDIR="\${tryDir}" ; export TMPDIR
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  Adjust the result so that it is an
         |#  absolute pathname...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   echo "$scriptName: error: can't decide on a location for a temp directory" >&2
         |   echo "$scriptName: ...set TMPDIR or $SCRIPTNAME_TMPDIR" >&2
         |   exit 1
         |else
         |   case "\${TMPDIR}" in
         |      /*)
         |          ;;
         |      *)
         |          TMPDIR="\`pwd\`/\${TMPDIR}" ; export TMPDIR
         |          ;;
         |   esac
         |fi
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: ...as \\"\${TMPDIR}\\" " >&2
         |fi
         |
         |#---------------------------------------
         |#
         |#  Use both pid and the time (number of
         |#  seconds since the epoch) to distinguish
         |#  the temporaries for this script...
         |#
         |#---------------------------------------
         |
         |TheTimeNow=`perl -e 'print time."\\n";'`
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   TheTimeNow=`date '+%s'`
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      TheTimeNow="999999999" # 2001-Sep-09,01:46:39z
         |   fi
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: ...time is \\"\${TheTimeNow}\\" " >&2
         |fi
         |
         |MyTmpDir="\${TMPDIR}/$scriptName.\$\$.\${TheTimeNow}.tmp"
         |
         |#---------------------------------------
         |#
         |#  We'll do everything from here on in
         |#  a temporary directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: create \\"\${MyTmpDir}\\" ">&2
         |fi
         |if [ -d "\${MyTmpDir}" ]
         |then
         |   echo "$scriptName: error: \\"\${MyTmpDir}\\" already exists" >&2
         |   exit 1
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: ...run [mkdir -p \\"\${MyTmpDir}\\" ]" >&2
         |fi
         |mkdir -p "\${MyTmpDir}" >/dev/null 2>&1
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: error: can't create directory \\"\${MyTmpDir}\\" " >&2
         |   exit 1
         |fi
         |
         |cd "\${MyTmpDir}"
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: error: can't cd to directory \\"\${MyTmpDir}\\" " >&2
         |   exit 1
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Command line processing...
         |#
         |#-------------------------------------------------------------------------------
         |
         |arg_process () {
         |   while [ \$# != 0 ]
         |   do
         |      opt="\$1"
         |      if [ "X\${opt}" != "X" ]
         |      then
         |         case "\${opt}" in
         |            #---------------------------------------
         |            #
         |            #  Standard options...
         |            #
         |            #---------------------------------------
         |
EOF10
         if ($withNotice ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF11");
         |            -copyright|--copyright)
         |                               echo
EOF11
            my $i;
            for ($i=0; $i<=$#theNotice; $i+=1) {
               my $lineOfText = $theNotice[$i];
               $lineOfText    =~ s/\\/\\\\/g;
               $lineOfText    =~ s/"/\\"/g;
               $lineOfText    =~ s/\$/\\\$/g;
#              $lineOfText    =~ s/@/\\@/g;
               print SCRIPT "                               echo \"$lineOfText\"\n";
            }
            print SCRIPT pKit_fixIndentStuff(<<"EOF12");
         |                               echo
         |                               exit 0
         |                               ;;
EOF12
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF13");
         |            -help|--help)
         |                               echo
         |                               echo "$titleLine"
         |                               echo
         |                               echo "NAME"
         |                               echo "    $scriptName -- Self-extracting installer script$ForProject."
         |                               echo
         |                               echo "USAGE"
EOF13
         if ($withNotice ne "") {
            print SCRIPT "                               echo \"    $scriptName --copyright\"\n";
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF14");
         |                               echo "    $scriptName --help"
EOF14
         if ($ProjectVer ne "") {
         print SCRIPT pKit_fixIndentStuff(<<"EOF15");
         |                               echo "    $scriptName --vernum"
EOF15
         }
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
         print SCRIPT pKit_fixIndentStuff(<<"EOF16");
         |                               echo "    $scriptName --version"
EOF16
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF17");
         |                               echo
EOF17
         my $exampleLine = $scriptName." [--keep] [--prefix=<pathname>]";
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               $exampleLine = $exampleLine." [--prefix-$bn=<pathname>]";
            }
         }
         $exampleLine    = $exampleLine." [-v[erbose][<digit>]]";
         print SCRIPT pKit_fixIndentStuff(<<"EOF18");
         |                               echo "    $exampleLine"
         |                               echo
         |                               echo "DESCRIPTION"
         |                               echo "    This script is a \\"self-extracting installer\\" script implemented as"
         |                               echo "    a Bourne-Shell script and carries a tarball as a payload. This generated"
         |                               echo "    installer script supports a number of options for specifying where"
         |                               echo "    the various directories are to be installed (prefix directory pathnames)."
         |                               echo
         |                               echo "    What this installer script does:"
         |                               echo
         |                               echo "       1) A suitable temp directory is determined. Much of the work done"
         |                               echo "          by the \\"$scriptName\\" script is done in a temp directory. Once"
         |                               echo "          an appropriate temporary directory has been arranged the"
         |                               echo "          $scriptName script will cd into this directory and work from"
         |                               echo "          there for much of the remaining work."
         |                               echo
         |                               echo "             NOTE: Is is generally best (but not required) to run the"
         |                               echo "                   \\"$scriptName\\" from within an empty directory."
         |                               echo
         |                               echo "       2) Using the command line options the this installer script will"
         |                               echo "          determine proper installation PREFIX directories for each of"
         |                               echo "          the directories to be installed. Note that each of the PREFIX"
         |                               echo "          directories will be created if necessary."
         |                               echo "       3) The \\"wrapper\\" tarball is extracted from this installer script"
         |                               echo "          landing in the temp directory."
         |                               echo "       4) The wrapper tarball is unwrapped using tar to form the \\"wrapper\\" "
         |                               echo "          directory in the temp directory. Note that this wrapper directory"
         |                               echo "          contains the individual tarballs of the directories to be installed."
         |                               echo "       5) For each of individual tarballs the script will cd to the appropriate"
         |                               echo "          prefix firectory and unwraps the individual tarball (found in the"
         |                               echo "          wrapper directory under the temp directory). This is the actual"
         |                               echo "          \\"install\\" step."
         |                               echo "       6) Cleanup if the --keep wasn't used."
         |                               echo
         |                               echo "OPTIONS"
         |                               echo "    \\"$scriptName\\" supports the following options:"
         |                               echo
         |                               echo "        --help"
         |                               echo
         |                               echo "            Output this man page to <stdout> and quit."
EOF18
         if ($ProjectVer ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF19");
         |                               echo
         |                               echo "        --vernum"
         |                               echo
         |                               echo "            Output version number of the payload to <stdout> and quit."
EOF19
         }
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
               print SCRIPT pKit_fixIndentStuff(<<"EOF20");
         |                               echo
         |                               echo "        --version"
         |                               echo
         |                               echo "            Output project name and version number of the payload to <stdout>"
         |                               echo "            and quit."
EOF20
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF21");
         |                               echo
         |                               echo "        --enforce-check"
         |                               echo
         |                               echo "            Enforce compatibility. If the source system C and C++"
         |                               echo "            library versions don't agree then report the problem and"
         |                               echo "            quit. This is the default behavior."
         |                               echo
         |                               echo "        --is-gnu-tar"
         |                               echo
         |                               echo "            Consider tar to be the GNU implementation even if it is"
         |                               echo "            not. Note that GNU tar directly supports compression"
         |                               echo "            (with the z option). This option is rarely used."
         |                               echo
         |                               echo "        --just-check"
         |                               echo
         |                               echo "            Don't enforce compatibility. If the source system C and C++"
         |                               echo "            library versions don't agree then simply report the problem"
         |                               echo "            then carry-on with the installation."
EOF21
         print SCRIPT pKit_fixIndentStuff(<<"EOF22");
         |                               echo
         |                               echo "        -k"
         |                               echo "        --keep"
         |                               echo
         |                               echo "            Don't cleanup intermediate temporary files and directories that"
         |                               echo "            are produced during the extraction and installation process."
         |                               echo
         |                               echo "        --not-gnu-tar"
         |                               echo
         |                               echo "            Don't consider tar to be the GNU implementation even if it"
         |                               echo "            is. Note that GNU tar directly supports compression (with"
         |                               echo "            the z option). This option is rarely used."
         |                               echo
         |                               echo "        --prefix=<pathname>"
         |                               echo
         |                               echo "            The pathname of the single directory where all of the payload"
EOF22
         if (1 <= $fileBasenameCount) {
            print SCRIPT pKit_fixIndentStuff(<<"EOF23");
         |                               echo "            directories and files are to be placed."
EOF23
         }
         else {
            print SCRIPT pKit_fixIndentStuff(<<"EOF24");
         |                               echo "            directories are to be placed."
EOF24
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               print SCRIPT pKit_fixIndentStuff(<<"EOF25");
         |                               echo
         |                               echo "        --prefix-$bn=<pathname>"
         |                               echo
         |                               echo "            The pathname of the directory where the \\"$bn\\" payload directory"
         |                               echo "            is to be placed. Note that if this option is not specified then the"
         |                               echo "            overall --prefix=<pathname> should be used."
EOF25
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF26");
         |                               echo
         |                               echo "        -q"
         |                               echo "        --query"
         |                               echo
         |                               echo "            Don't actually perform the installation. Instead only harvest the"
         |                               echo "            target system information such as OS name and version number, C"
         |                               echo "            and C++ compiler version numbers, C library version number, The"
         |                               echo "            Standard C++ library and C++ ABI version numbers."
         |                               echo
         |                               echo "        -v[erbose][<digit>]"
         |                               echo
         |                               echo "            Operate in a verbose mode."
         |                               echo
         |                               echo "            Repeating this option increases the amount of output produced."
         |                               echo "            Note that the option may end with an optional digit which"
         |                               echo "            indicates a repetition count. Thus the option:"
         |                               echo
         |                               echo "               -v3"
         |                               echo
         |                               echo "            is equivalent to:"
         |                               echo
         |                               echo "               -v -v -v"
         |                               echo
         |                               echo "    Note that if no prefix is specified then this script will prompt for one."
         |                               echo
         |                               echo "RETURNS"
         |                               echo "    \\"$scriptName\\" returns the standard exit codes:"
         |                               echo
         |                               echo "       0 -- success"
         |                               echo "       1 -- failure"
         |                               echo
         |                               echo "ENVIRONMENT"
         |                               echo "    \\"$scriptName\\" refers to the following environment variables:"
         |                               echo
         |                               echo "        DEBUG"
         |                               echo "        DEBUG_$scriptNameU"
         |                               echo
         |                               echo "            This environment variable controls the production of additional"
         |                               echo "            output intended as an aid in debugging the script itself. When"
         |                               echo "            set to a non-zero integer value additional output will be"
         |                               echo "            generated and sent to <stderr>. If set to a pathname additional"
         |                               echo "            output will sent to a file with the given pathname. If set to"
         |                               echo "            a value of 0 (zero) or left unset then no additional debugging"
         |                               echo "            output will be produced."
         |                               echo
         |                               echo "            The DEBUG_$scriptNameU environment variable isn't fully"
         |                               echo "            implemented at this time. In particular setting it to a"
         |                               echo "            pathname won't cause debugging output to be sent to the"
         |                               echo "            file; in this it will case it will be sent to <stderr>."
         |                               echo
         |                               echo "        OPTS_$scriptNameU"
         |                               echo
         |                               echo "            Additional options are taken from this variable. Note that all"
         |                               echo "            such options are processed before the command line options."
         |                               echo
         |                               echo "        $SCRIPTNAME_TMPDIR"
         |                               echo
         |                               echo "            Consider this pathname before considering TMPDIR (see"
         |                               echo "            step (0) in the NOTES section below)."
         |                               echo
         |                               echo "INPLEMENTATION"
         |                               echo "    \\"$scriptName\\" is implemented as an sh script."
         |                               echo
         |                               echo "SEE ALSO"
         |                               echo "    mkinstaller(1x), sed(1), sh(1), tar(1)"
         |                               echo
         |                               echo "NOTES"
         |                               echo "    Both the sed and tar utilities are required."
EOF26
         if ($OSname ne "") {
            print SCRIPT "                               echo\n";
            print SCRIPT "                               echo \"    This installer script was built on \\\"$OSname\\\" \"\n";
         }
         if ($CC_pathname ne "") {
            print SCRIPT "                               echo\n";
            my $bn = pKit_basename($CC_pathname);
            if ($bn eq $CC_basename) {
               print SCRIPT "                               echo \"    The C compiler \\\"$CC_pathname\\\" was used to build the payload.\"\n";
            }
            else {
               print SCRIPT "                               echo \"    The C compiler \\\"$CC_pathname\\\" (aka. \\\"$CC_basename\\\") was used to build the payload.\"\n";
            }
         }
         if ($CXX_pathname ne "") {
            print SCRIPT "                               echo\n";
            if ($bn eq $CXX_basename) {
               print SCRIPT "                               echo \"    The C++ compiler \\\"$CXX_pathname\\\" was used to build the payload.\"\n";
            }
            else {
               print SCRIPT "                               echo \"    The C++ compiler \\\"$CXX_pathname\\\" (aka. \\\"$CXX_basename\\\") was used to build the payload.\"\n";
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF27");
         |                               echo
         |                               echo "    The directory where temporary files are to be placed is determined"
         |                               echo "    as follows:"
         |                               echo
         |                               echo "        0) If $SCRIPTNAME_TMPDIR is defined and is not empty then"
         |                               echo "           consider its value as a directory pathname. If this pathname"
         |                               echo "           exists and is a directory and is writable then temporary"
         |                               echo "           files will be placed in this directory. Otherwise..."
         |                               echo "        1) If TMPDIR is defined and is not empty then consider its"
         |                               echo "           value as a directory pathname. If this pathname exists"
         |                               echo "           and is a directory and is writable then temporary files"
         |                               echo "           will be placed in this directory. Otherwise..."
         |                               echo "        2) If TMP is defined and is not empty then consider its"
         |                               echo "           value as a directory pathname. If this pathname exists"
         |                               echo "           and is a directory and is writable then temporary files"
         |                               echo "           will be placed in this directory. Otherwise..."
         |                               echo "        3) If TEMP is defined and is not empty then consider its"
         |                               echo "           value as a directory pathname. If this pathname exists"
         |                               echo "           and is a directory and is writable then temporary files"
         |                               echo "           will be placed in this directory. Otherwise..."
         |                               echo "        4) If the user's home directory can be determined and if"
         |                               echo "           this home directory contains a subdirectory named tmp"
         |                               echo "           that is itself writable then temporary files will be"
         |                               echo "           placed in this directory. Otherwise..."
         |                               echo "        5) If \\"C:<userProfile>\\\\AppData\\\\Local\\\\temp\\" exists and"
         |                               echo "           is a writable directory then temporary files will be"
         |                               echo "           placed in this directory. Otherwise..."
         |                               echo "        6) If \\"/tmp\\" exists and is writable then temporary files"
         |                               echo "           will be placed in this directory. Otherwise..."
         |                               echo "        7) If \\"/var/tmp\\" exists and is writable then temporary files"
         |                               echo "           will be placed in this directory. Otherwise..."
         |                               echo "        8) If \\"C:\\\\Temp\\" exists and is writable then temporary files"
         |                               echo "           will be placed in this directory. Otherwise..."
         |                               echo "        9) If \\"C:\\\\Windows\\\\Temp\\" exists and is writable then temporary"
         |                               echo "           files will be placed in this directory. Otherwise..."
         |                               echo "       10) If the current directory is writable then temporary files"
         |                               echo "           will be placed in the current directory. Otherwise..."
         |                               echo "       11) A fatal error message will be sent to <stderr> and"
         |                               echo "           the program will exit with a non-zero exit code."
         |                               echo
         |                               echo "    Note that 5, 8, and 9 are only applicable on Windows-like hosts."
         |                               echo
         |                               echo "AUTHOR"
         |                               echo "    mkinstaller version $mkinstaller_ver_name rev. $mkinstaller_ver_time"
EOF27
         if ($Contact ne "") {
            print SCRIPT "                               echo\n";
            print SCRIPT "                               echo \"CONTACT\"\n";
            if ($ProjectName ne "") {
               print SCRIPT "                               echo \"    Please contact the $ProjectName team at:\"\n";
            }
            else {
               print SCRIPT "                               echo \"    Please contact:\"\n";
            }
            print SCRIPT "                               echo\n";
            print SCRIPT "                               echo \"        $Contact\"\n";
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF28");
         |                               echo
         |                               exit 0
         |                               ;;
EOF28
         if ($ProjectVer ne "") {
            print SCRIPT "\n";
            print SCRIPT "            --vernum)          echo $ProjectVer\n";
            print SCRIPT "                               exit 0\n";
            print SCRIPT "                               ;;\n";
            if ($ProjectName ne "") {
               print SCRIPT "\n";
               print SCRIPT "            --version)         echo $ProjectName: version $ProjectVer\n";
               print SCRIPT "                               exit 0\n";
               print SCRIPT "                               ;;\n";
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF29");
         |
         |            #---------------------------------------
         |            #
         |            #  Non-standard options...
         |            #
         |            #---------------------------------------
         |
         |            --enforce-check)   if [ "X\${Enforce}" = "Xfalse" ]
         |                               then
         |                                  echo "$scriptName: error: already specified --just-check" >&2
         |                                  exit 1
         |                               fi
         |                               Enforce=true
         |                               ;;
         |
         |            --is-gnu-tar)      if [ "X\${IsGNUtar}" = "Xfalse" ]
         |                               then
         |                                  if [ "X\${IsGNUtarHow}" = "Xtold" ]
         |                                  then
         |                                     echo "$scriptName: note: override specified capability of tar" >&2
         |                                  else
         |                                     echo "$scriptName: note: override tested capability of tar" >&2
         |                                  fi
         |                               fi
         |                               IsGNUtar="true"
         |                               IsGNUtarHow="told"
         |                               echo "$scriptName: ...assume tar is GNU tar" >&2
         |                               ;;
         |
         |            --just-check)      if [ "X\${Enforce}" = "Xtrue" ]
         |                               then
         |                                  echo "$scriptName: error: already specified --enforce-check" >&2
         |                                  exit 1
         |                               fi
         |                               Enforce=false
         |                               ;;
         |
         |            -k|--keep)         keep=true
         |                               ;;
         |
         |            --not-gnu-tar)     if [ "X\${IsGNUtar}" = "Xtrue" ]
         |                               then
         |                                  if [ "X\${IsGNUtarHow}" = "Xtold" ]
         |                                  then
         |                                     echo "$scriptName: note: override specified capability of tar" >&2
         |                                  else
         |                                     echo "$scriptName: note: override tested capability of tar" >&2
         |                                  fi
         |                               fi
         |                               IsGNUtar="false"
         |                               IsGNUtarHow="told"
         |                               echo "$scriptName: ...assume tar is not GNU tar" >&2
         |                               ;;
         |
         |            --prefix=*)        given="\${opt}"
         |                               stmp=\`echo \${given} | \${Use_sed} -e 's/^--prefix=\\(.*\\)\$/\\1/'\`
         |                               given="\${stmp}"
         |                               case "X\${given}" in
         |                                  X\\"*\\") given=`echo \${given} | \${Use_sed} 's/^"\\(.*\\)"\$/\\1/'`
         |                                          echo "$scriptName: note: stripped enclosing double-quotes from argument to --prefix option" >&2
         |                                          ;;
         |                                  X\\'*\\') given=`echo \${given} | \${Use_sed} 's/^.\\(.*\\).\$/\\1/'`
         |                                          echo "$scriptName: note: stripped enclosing single-quotes from argument to --prefix option" >&2
         |                                          ;;
         |                                  X*)
         |                                          ;;
         |                               esac
         |                               if [ "X\${given}" = "X" ]
         |                               then
         |                                  echo "$scriptName: error: missing or zero-length argument to --prefix option" >&2
         |                                  exit 1
         |                               fi
         |                               PREFIX="\${given}"
         |                               ;;
EOF29
         if ($fileBasenameCount <= 0) {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT pKit_fixIndentStuff(<<"EOF30");
         |
         |            --prefix-$bn=*)
         |                               given="\${opt}"
         |                               stmp=\`echo \${given} | \${Use_sed} -e 's/^--prefix-$bn=\\(.*\\)\$/\\1/'\`
         |                               given="\${stmp}"
         |                               case "X\${given}" in
         |                                  X\\"*\\") given=`echo \${given} | \${Use_sed} 's/^"\\(.*\\)"\$/\\1/'`
         |                                          echo "$scriptName: note: stripped enclosing double-quotes from argument to --prefix-$bn option" >&2
         |                                          ;;
         |                                  X\\'*\\') given=`echo \${given} | \${Use_sed} 's/^.\\(.*\\).\$/\\1/'`
         |                                          echo "$scriptName: note: stripped enclosing single-quotes from argument to --prefix-$bn option" >&2
         |                                          ;;
         |                                  X*)
         |                                          ;;
         |                               esac
         |                               if [ "X\${given}" = "X" ]
         |                               then
         |                                  echo "$scriptName: error: missing or zero-length argument to --prefix-$bn option" >&2
         |                                  exit 1
         |                               fi
         |                               PREFIX_$vn="\${given}"
         |                               if [ "X\${IntermediateName}" != "X" ]
         |                               then
         |                                  echo "$scriptName: note: version directory name(=\\"\${IntermediateName}\\") suppressed by --prefix-$bn option" >&2
         |                                  IntermediateName=
         |                               fi
         |                               ;;
EOF30
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF31");
         |
         |            -q|--query)        JustQuery=true
         |                               ;;
         |
         |            #---------------------------------------
         |            #
         |            #  "Semi-standard" options...
         |            #
         |            #---------------------------------------
         |
         |            -v)                verbosityLevel=\`\${Use_expr} \${verbosityLevel} + 1\`
         |                               ;;
         |
         |            -v0)               verbosityLevel=0
         |                               ;;
         |
         |            -v[0-9])           given=\${opt}
         |                               itmp=\`echo \${given} | \${Use_sed} -e 's/^-v\\([0-9]\\)\$/\\1/'\`
         |                               verbosityLevel=\`\${Use_expr} \${verbosityLevel} + \${itmp}\`
         |                               ;;
         |
         |            --verbose)         verbosityLevel=\`\${Use_expr} \${verbosityLevel} + 1\`
         |                               ;;
         |
         |            --verbose0)        verbosityLevel=0
         |                               ;;
         |
         |            --verbose[0-9])    given="\${opt}"
         |                               itmp=\`echo \${given} | \${Use_sed} -e 's/^--verbose\\([0-9]\\)\$/\\1/'\`
         |                               verbosityLevel=\`\${Use_expr} \${verbosityLevel} + \${itmp}\`
         |                               ;;
         |
         |            #---------------------------------------
         |            #
         |            #  Unknown options...
         |            #
         |            #---------------------------------------
         |
         |            -*)                echo "$scriptName: error: unknown option \\"\$opt\\" " >&2
         |                               echo "$scriptName: ...if \\"\$opt\\" is meant to be a pathname try using \\'./\$opt\\' " >&2
         |                               exit 1
         |                               ;;
         |
         |            #---------------------------------------
         |            #
         |            #  Parameters...
         |            #
         |            #---------------------------------------
         |
         |            *)                 echo "$scriptName: error: unexpected \\"\${opt}\\" " >&2
         |                               exit 1
         |                               ;;
         |
         |         esac
         |      else
         |         echo "$scriptName: error: zero-length parameter" >&2
         |         exit 1
         |      fi
         |      shift
         |   done
         |}
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Process command line...
         |#
         |#-------------------------------------------------------------------------------
         |
         |arg_process \${OPTS_$scriptNameU} \$@
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Enforce compability checking by default unless we're just querying.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${Enforce}" = "X" ]
         |then
         |   if [ "X\${JustQuery}" = "Xtrue" ]
         |   then
         |      Enforce=false
         |   else
         |      Enforce=true
         |   fi
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  We'll be passing the verbosity level to pre- and post-install scripts...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   if [ 1 -lt \${verbosityLevel} ]
         |   then
         |      Vflag=" -v\${verbosityLevel}"
         |   else
         |      Vflag=" -v"
         |   fi
         |else
         |   Vflag=
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  A reminder that we're doing this all from a temporary directory.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: generated by: \${GeneratedBy}" >&2
         |   echo "$scriptName: running \\"\${commandPathname}\\" " >&2
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: working in \\"\${amNowIn}\\" " >&2
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      /bin/ls -alF >&2
         |   fi
         |else
         |   if [ "X\${JustQuery}" != "Xfalse" ]
         |   then
         |      echo "$scriptName: generated by: \${GeneratedBy}" >&2
         |   fi
         |fi
         |
         |if [ "X\${JustQuery}" != "Xtrue" ]
         |then
         |   #----------------------------------------------------------------------------
         |   #
         |   #  Dealing with PREFIX...
         |   #
         |   #  The overall PREFIX is only needed if one or more of the individual PREFIX...
         |   #  pathnames wasn't specified using the appropriate options. In this case we'll
         |   #  have to ask for the overall PREFIX if it wasn't supplied then use it to set
         |   #  each of the PREFIX... pathnames that wern't supplied.
         |   #
         |   #  If an intermediate or version directory name has been specified, it will
         |   #  be appended under the given PREFIX directory.
         |   #
         |   #  NOTE: We don't actually care about the prefix if the --query option has
         |   #        been specified, if it was we can skip all of this and get on to
         |   #        the work of gathering info on the host system.
         |   #
         |   #----------------------------------------------------------------------------
         |
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: dealing with PREFIX..." >&2
         |   fi
         |   haveAll=true
EOF31
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT pKit_fixIndentStuff(<<"EOF32");
         |   if [ "X\${PREFIX_$vn}" = "X" ]
         |   then
         |      haveAll=false
         |   fi
EOF32
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF33");
         |
         |   if [ "X\${haveAll}" != Xtrue ]
         |   then
         |      #---------------------------------------
         |      #
         |      #  First try the default (if any) that
         |      #  was given when this script was
         |      #  generated...
         |      #
         |      #---------------------------------------
         |
         |      if [ "X\${PREFIX}" = "X" ]
         |      then
         |         PREFIX="\${DefaultPrefix}"
         |      fi
         |
         |      #---------------------------------------
         |      #
         |      #  Ask for PREFIX if one wasn't given...
         |      #
         |      #---------------------------------------
         |
         |      while [ "X\${PREFIX}" = "X" ]
         |      do
         |         [ "\${PREFIX}" != "" ] || read -e -p "$scriptName: Enter the PREFIX path: " PREFIX
         |         if [ "X\${PREFIX}" = "X" ]
         |         then
         |            echo "$scriptName: can't have empty PREFIX, try again"
         |         else
         |            case "X\${PREFIX}" in
         |               X\\"*\\") PREFIX=`echo \${PREFIX} | \${Use_sed} 's/^"\\(.*\\)"\$/\\1/'`
         |                       echo "$scriptName: stripped surrounding double-quotes" >&2
         |                       if [ "X\${PREFIX}" = "X" ]
         |                       then
         |                          echo "$scriptName: ...leaving an empty PREFIX, try again" >&2
         |                       fi
         |                       ;;
         |               X\\'*\\') PREFIX=`echo \${PREFIX} | \${Use_sed} 's/^.\\(.*\\).\$/\\1/'`
         |                       echo "$scriptName: ...stripped surrounding single-quotes" >&2
         |                       if [ "X\${PREFIX}" = "X" ]
         |                       then
         |                          echo "$scriptName: leaving an empty PREFIX, try again" >&2
         |                       fi
         |                       ;;
         |               X*)
         |                       ;;
         |            esac
         |         fi
         |      done
         |
         |      #---------------------------------------
         |      #
         |      #  Force PREFIX to be absolute.
         |      #
         |      #---------------------------------------
         |
         |      case "\${PREFIX}" in
         |         /*)
         |             ;;
         |         *)
         |             PREFIX=\"\${here}/\${PREFIX}\"
         |             ;;
         |      esac
EOF33
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT pKit_fixIndentStuff(<<"EOF34");
         |
         |      #---------------------------------------
         |      #
         |      #  Set PREFIX_$vn from PREFIX if we must.
         |      #
         |      #---------------------------------------
         |
         |      if [ "X\${PREFIX_$vn}" = "X" ]
         |      then
         |         PREFIX_$vn="\${PREFIX}"
         |      fi
EOF34
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF35");
         |   fi
         |
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: install under:" >&2
         |      echo "$scriptName: ...PREFIX=\\"\${PREFIX}\\" " >&2
EOF35
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT pKit_fixIndentStuff(<<"EOF36");
         |      if [ "X\${PREFIX_$vn}" != "X\${PREFIX}" ]
         |      then
         |         echo "$scriptName: ...PREFIX_$vn=\\"\${PREFIX_$vn}\\" " >&2
         |      fi
EOF36
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF37");
         |   fi
         |
         |   #---------------------------------------
         |   #
         |   #  Append an intermediate directory name
         |   #  to the installation PREFIX directories
         |   #  if appropriate...
         |   #
         |   #---------------------------------------
         |
         |   if [ "X\${IntermediateName}" != "X" ]
         |   then
         |      PREFIX=\"\${PREFIX}/\${IntermediateName}\"
EOF37
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT pKit_fixIndentStuff(<<"EOF38");
         |      PREFIX_$vn=\"\${PREFIX_$vn}/\${IntermediateName}\"
EOF38
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF39");
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...done" >&2
         |   fi
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Collect and report on information about the target system...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${Target_hw}" = "X" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: collect info on HW..." >&2
         |   fi
         |   #---------------------------------------
         |   #
         |   #  The HW type...
         |   #
         |   #  Note that is is done above in the
         |   #  idTheHardware function. BTW When
         |   #  no parameter is given then this
         |   #  function will use the "standard"
         |   #  uname tool.
         |   #
         |   #---------------------------------------
         |   idTheHardware
         |   Target_hw=\"\${HWtype}\"
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...done, gives [\${Target_hw}]" >&2
         |   fi
         |fi
         |
         |if [ "X\${Target_os}" = "X" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: collect info on OS..." >&2
         |   fi
         |   #---------------------------------------
         |   #
         |   #  The OS type and version...
         |   #
         |   #---------------------------------------
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...run [\${Use_uname} -s | \${Use_tr} '[:upper:]' '[:lower:]]" >&2
         |   fi
         |   UnameOStype=`\${Use_uname} -s | \${Use_tr} '[:upper:]' '[:lower:]' 2>konftest.log`
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName:    gives [\${UnameOStype}]" >&2
         |   fi
         |   status=\$?
         |   if [ "X\${status}" = "X0" ]
         |   then
         |      if [ "X\${UnameOStype}" != "X" ]
         |      then
         |         map_uname_s_to_perl \${UnameOStype}
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...maps to [\${PerlOStype}]" >&2
         |         fi
         |         Target_os="\${PerlOStype}"
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...run [\${Use_uname} -r]" >&2
         |         fi
         |         UnameOSrev=`\${Use_uname} -r 2>konftest.log`
         |         status=\$?
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    gives [\${UnameOSrev}]" >&2
         |         fi
         |         if [ "X\${status}" = "X0" ]
         |         then
         |            gotVersionNum=`echo "\${UnameOSrev}" | \${Use_sed} 's/^[ ]*\\([0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^[0-9].*\\)\$/\\1/'`
         |            Target_os_version="\${gotVersionNum}"
         |         else
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName: can't identify system type" >&2
         |               echo "$scriptName: ...[\${Use_uname} -r 2>konftest.log] returned exit code \${status}" >&2
         |               if [ -f "konftest.log" ]
         |               then
         |                  echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                  cat konftest.log >&2
         |                  echo "$scriptName]" >&2
         |               fi
         |            fi
         |            Target_os_version=""
         |         fi
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: can't identify system type" >&2
         |            echo "$scriptName: ...[\${Use_uname} -r 2>konftest.log] returned an empty string" >&2
         |            if [ -f "konftest.log" ]
         |            then
         |               echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |               cat konftest.log >&2
         |               echo "$scriptName\]" >&2
         |            fi
         |         fi
         |         Target_os=\"\"
         |         Target_os_version=\"\"
         |      fi
         |   else
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: can't identify system type" >&2
         |         echo "$scriptName: ...[\${Use_uname} -s | \${Use_tr} '[:upper:]' '[:lower:]' 2>konftest.log] returned exit code \${status}" >&2
         |         if [ -f "konftest.log" ]
         |         then
         |            echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |            cat konftest.log >&2
         |            echo "$scriptName\]" >&2
         |         fi
         |      fi
         |      Target_os=""
         |      Target_os_version=""
         |   fi
         |   rm -f konftest.out
         |   rm -f konftest.log
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...done" >&2
         |   fi
         |fi
         |
         |if [ "X\${Target_CC}" = "X" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: collect info on C compiler (\${Source_CC})..." >&2
         |   fi
         |   #---------------------------------------
         |   #
         |   #  The C compiler and version...
         |   #
         |   #---------------------------------------
         |   Target_CC=`basename \${Source_CC}`
         |   if [ "X\${Target_CC}" != "X" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: ...locate \\"\${Target_CC}\\" " >&2
         |      fi
         |      for d in \${myPath}
         |      do
         |         if [ X\${d} != X ]
         |         then
         |            if [ X\${d} != X. ]
         |            then
         |               if [ -f "\${d}/\${Target_CC}" ]
         |               then
         |                  if [ -x "\${d}/\${Target_CC}" ]
         |                  then
         |                     case "\${d}" in
         |                        /*) Use_cc="\${d}/\${Target_CC}"
         |                            ;;
         |                        *)  Use_cc="\${here}/\${d}/\${Target_CC}"
         |                            ;;
         |                     esac
         |                     break
         |                  fi
         |               fi
         |            fi
         |         fi
         |      done
         |      Target_CC_pathname="\${Use_cc}"
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         if [ "X\${Target_CC_pathname}" != "X" ]
         |         then
         |            echo "$scriptName:    found \\\"\${Target_CC_pathname}\\\" " >&2
         |         else
         |            echo "$scriptName:    can't find \\\"\${Target_CC}\\\" " >&2
         |         fi
         |         echo "$scriptName: ...run [checkForCompilerVersion \${Target_CC}]" >&2
         |      fi
         |      gives=`checkForCompilerVersion \${Target_CC}`
         |      status=\$?
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName:    gives [\${gives}]" >&2
         |      fi
         |      if [ "X\${status}" = "X0" ]
         |      then
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...succeeded" >&2
         |         fi
         |         givesName=`echo \${gives} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^.0-9].*\\)*\$/\\1/'`
         |         givesVers=`echo \${gives} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^.0-9].*\\)*\$/\\2/'`
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:       match gives:" >&2
         |            echo "$scriptName:       ...name is [\${givesName}]" >&2
         |            echo "$scriptName:          version [\${givesVers}]" >&2
         |         fi
         |         if [ "X\${givesName}" != "X\${gives}" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...name is [\${givesName}]" >&2
         |            fi
         |            if [ "X\${givesVers}" != "X\${gives}" ]
         |            then
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:       version number is [\${givesVers}]" >&2
         |               fi
         |               Target_CC_version="\${givesVers}"
         |            else
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:       ...version failed" >&2
         |               fi
         |               Target_CC_version=""
         |            fi
         |         else
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:       ...name failed" >&2
         |            fi
         |            Target_CC_version=""
         |         fi
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    failed with exit code \${status}" >&2
         |         fi
         |      fi
         |   else
         |      Target_CC_version=""
         |   fi
         |   rm -f konftest
         |   rm -f konftest.o
         |   rm -f konftest.c
         |   rm -f konftest.out
         |   rm -f konftest.log
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...done" >&2
         |   fi
         |fi
         |
         |if [ "X\${Target_libc_XversionX}" = "X" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: collect info on libc..." >&2
         |      echo "$scriptName: ...method 1 (shortcut)" >&2
         |   fi
         |   if [ "X\${Target_CC}" != "X" ]
         |   then
         |      #---------------------------------------
         |      #
         |      #  Shortcut C library version...
         |      #
         |      #---------------------------------------
         |      bn=`basename \${Target_CC}`
         |      if [ "X\${bn}" != "X" ]
         |      then
         |         #
         |         #  Build the C test code...
         |         #
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    generate test code" >&2
         |         fi
         |         rm -f konftest.c
         |         echo '#include <stdio.h>'                  >konftest.c
         |         echo '#include <gnu/libc-version.h>'      >>konftest.c
         |         echo                                      >>konftest.c
         |         echo 'int main (void)'                    >>konftest.c
         |         echo '{'                                  >>konftest.c
         |         echo '   puts(gnu_get_libc_version());'   >>konftest.c
         |         echo '   return 0;'                       >>konftest.c
         |         echo '}'                                  >>konftest.c
         |         echo                                      >>konftest.c
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...done" >&2
         |         fi
         |         if [ -f "konftest.c" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...found test code" >&2
         |               echo "$scriptName:    compile and link test code" >&2
         |            fi
         |            cmd="\${bn} -o konftest konftest.c"
         |            rm -f konftest.out konftest.log
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...run [\${cmd}]" >&2
         |            fi
         |            \${cmd} 1>konftest.out 2>konftest.log
         |            status=\$?
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:       gives exit code \${status}" >&2
         |            fi
         |            if [ "X\${status}" = "X0" ]
         |            then
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:    ...done" >&2
         |               fi
         |               if [ -f "konftest" ]
         |               then
         |                  if [ "X\${debugging}" != "X0" ]
         |                  then
         |                     echo "$scriptName:    found \\"konftest\\" " >&2
         |                  fi
         |                  if [ -x "konftest" ]
         |                  then
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    which is executable" >&2
         |                     fi
         |                     rm -f konftest.out
         |                     rm -f konftest.log
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    run test code" >&2
         |                     fi
         |                     gives=`konftest 2>konftest.log`
         |                     status=\$?
         |                     if [ "X\${status}" = "X0" ]
         |                     then
         |                        if [ "X\${debugging}" != "X0" ]
         |                        then
         |                           echo "$scriptName:    ...done, gives \${gives}" >&2
         |                        fi
         |                        Target_libc_XversionX="\${gives}"
         |                     else
         |                        if [ "X\${debugging}" != "X0" ]
         |                        then
         |                           echo "$scriptName:    ...failed, with exist code \${status}" >&2
         |                           echo "$scriptName:    ...[konftest 2>konftest.log] failed, returned exit code \${status}" >&2
         |                           if [ -f "konftest.log" ]
         |                           then
         |                              echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                              cat konftest.log >&2
         |                              echo "$scriptName]" >&2
         |                           fi
         |                        fi
         |                     fi
         |                  else
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    but \\"konftest\\" isn't executable" >&2
         |                        echo "$scriptName:    ...[\${cmd} 1>konftest.out 2>konftest.log] failed, can't find \\"konftest\\" " >&2
         |                        if [ -f "konftest.out" ]
         |                        then
         |                           echo "$scriptName\[       \\"konftest.out\\" contains:" >&2
         |                           cat konftest.out >&2
         |                           echo "$scriptName]" >&2
         |                        fi
         |                        if [ -f "konftest.log" ]
         |                        then
         |                           echo "$scriptName\[       \\"konftest.log\\" contains:" >&2
         |                           cat konftest.log >&2
         |                           echo "$scriptName]" >&2
         |                        fi
         |                     fi
         |                  fi
         |               else
         |                  if [ "X\${debugging}" != "X0" ]
         |                  then
         |                     echo "$scriptName:    but can't find \\"konftest\\" " >&2
         |                     echo "$scriptName:    ...[\${cmd} 1>konftest.out 2>konftest.log] failed, can't find \\"konftest\\" " >&2
         |                     if [ -f "konftest.out" ]
         |                     then
         |                        echo "$scriptName\[       \\"konftest.out\\" contains:" >&2
         |                        cat konftest.out >&2
         |                        echo "$scriptName]" >&2
         |                     fi
         |                     if [ -f "konftest.log" ]
         |                     then
         |                        echo "$scriptName\[       \\"konftest.log\\" contains:" >&2
         |                        cat konftest.log >&2
         |                        echo "$scriptName]" >&2
         |                     fi
         |                  fi
         |               fi
         |            else
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:    ...failed, exit code \${status}" >&2
         |                  echo "$scriptName:       [\${cmd} 1>konftest.out 2>konftest.log] returned exit code \${status}" >&2
         |                  if [ -f "konftest.out" ]
         |                  then
         |                     echo "$scriptName\[       \\"konftest.out\\" contains:" >&2
         |                     cat konftest.out >&2
         |                     echo "$scriptName]" >&2
         |                  fi
         |                  if [ -f "konftest.log" ]
         |                  then
         |                     echo "$scriptName\[       \\"konftest.log\\" contains:" >&2
         |                     cat konftest.log >&2
         |                     echo "$scriptName]" >&2
         |                  fi
         |               fi
         |            fi
         |         fi
         |         rm -f konftest.log
         |         rm -f konftest.out
         |         rm -f konftest
         |         rm -f konftest.o
         |         rm -f konftest.c
         |      fi
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: ...done" >&2
         |   fi
         |fi
         |
         |if [ "X\${Target_libc_pathname}" = "X" ]
         |then
         |   if [ "X\${Target_CC}" != "X" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: collect info on libc..." >&2
         |         echo "$scriptName: ...method 2 (the hard way)" >&2
         |      fi
         |      #---------------------------------------
         |      #
         |      #  Locate the C library...
         |      #
         |      #---------------------------------------
         |      bn=`basename \${Target_CC}`
         |      if [ "X\${bn}" != "X" ]
         |      then
         |         #
         |         #  Build a C binary executable...
         |         #
         |         rm -f konftest.c
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    generate test code" >&2
         |         fi
         |         echo 'extern int strlen ( const char * );'   >>konftest.c
         |         echo                                         >>konftest.c
         |         echo 'int main ( int argc, char *argv[] )'   >>konftest.c
         |         echo '{'                                     >>konftest.c
         |         echo '   int i;'                             >>konftest.c
         |         echo                                         >>konftest.c
         |         echo '   for (i=1; i<argc; ++i) {'           >>konftest.c
         |         echo '      if (strlen(argv[i]) <= 0) {'     >>konftest.c
         |         echo '         return 1;'                    >>konftest.c
         |         echo '      }'                               >>konftest.c
         |         echo '   }'                                  >>konftest.c
         |         echo '   return 0;'                          >>konftest.c
         |         echo '}'                                     >>konftest.c
         |         echo                                         >>konftest.c
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...done" >&2
         |         fi
         |         if [ -f "konftest.c" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...found test code" >&2
         |               echo "$scriptName:    compile and link test code" >&2
         |            fi
         |            cmd="\${bn} -o konftest konftest.c"
         |            rm -f konftest.out konftest.log
         |            \${cmd} 1>konftest.out 2>konftest.log
         |            status=\$?
         |            if [ "X\${status}" = "X0" ]
         |            then
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:    ...done" >&2
         |               fi
         |               if [ -f "konftest" ]
         |               then
         |                  if [ "X\${debugging}" != "X0" ]
         |                  then
         |                     echo "$scriptName:    found \\"konftest\\" " >&2
         |                  fi
         |                  if [ -x "konftest" ]
         |                  then
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    which is executable" >&2
         |                        echo "$scriptName:    examine the binary executable" >&2
         |                     fi
         |                     rm -f konftest.log
         |                     if [ "X\${Target_os}" = "Xdarwin" ]
         |                     then
         |                        if [ "X\${debugging}" != "X0" ]
         |                        then
         |                           echo "$scriptName:    ...using \\"otool -L konftest | \${Use_fgrep} 'libgcc' | ..." >&2
         |                        fi
         |                        gives=`( otool -L konftest | \${Use_fgrep} 'libgcc' | while read a b c d ; do echo \\\${a} ; done ) 2>konftest.log`
         |                        status=\$?
         |                        if [ "X\${status}" = "X0" ]
         |                        then
         |                           if [ "X\${debugging}" != "X0" ]
         |                           then
         |                              echo "$scriptName:       done, gives [\${gives}]" >&2
         |                           fi
         |                           Target_libc_pathname="\${gives}"
         |                        else
         |                           if [ "X\${debugging}" != "X0" ]
         |                           then
         |                              echo "$scriptName:       failed, exit code \${status}" >&2
         |                              echo "$scriptName: ...[otool -L konftest | \${Use_fgrep} 'libgcc' | while read a b c d ; do echo \\\${a} ; done 2>konftest.log] failed,  returned exit code \${status}" >&2
         |                              if [ -f "konftest.log" ]
         |                              then
         |                                 echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                                 cat konftest.log >&2
         |                                 echo "$scriptName]" >&2
         |                              fi
         |                           fi
         |                        fi
         |                     else
         |                        if [ "X\${debugging}" != "X0" ]
         |                        then
         |                           echo "$scriptName:    ...using \\"\${Use_ldd} konftest | \${Use_grep} -w 'libc' | ..." >&2
         |                        fi
         |                        gives=`( \${Use_ldd} konftest | \${Use_grep} -w 'libc' | while read a b c d ; do echo \\\${c} ; done ) 2>konftest.log`
         |                        status=\$?
         |                        if [ "X\${status}" = "X0" ]
         |                        then
         |                           if [ "X\${debugging}" != "X0" ]
         |                           then
         |                              echo "$scriptName:       done, gives [\${gives}]" >&2
         |                           fi
         |                           Target_libc_pathname="\${gives}"
         |                        else
         |                           if [ "X\${debugging}" != "X0" ]
         |                           then
         |                              echo "$scriptName:       failed, exit code \${status}" >&2
         |                              if [ -f "konftest.log" ]
         |                              then
         |                                 echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                                 cat konftest.log >&2
         |                                 echo "$scriptName]" >&2
         |                              fi
         |                           fi
         |                        fi
         |                     fi
         |                  else
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    \\"konftest\\" isn't executable" >&2
         |                        echo "$scriptName: ...[\${cmd} 1>konftest.out 2>konftest.log] failed, \\"konftest\\" isn't executable" >&2
         |                        if [ -f "konftest.out" ]
         |                        then
         |                           echo "$scriptName\[    \\"konftest.out\\" contains:" >&2
         |                           cat konftest.out >&2
         |                           echo "$scriptName]" >&2
         |                        fi
         |                        if [ -f "konftest.log" ]
         |                        then
         |                           echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                           cat konftest.log >&2
         |                           echo "$scriptName]" >&2
         |                        fi
         |                     fi
         |                  fi
         |               else
         |                  if [ "X\${debugging}" != "X0" ]
         |                  then
         |                     echo "$scriptName:    can't find \\"konftest\\" " >&2
         |                     echo "$scriptName: ...[\${cmd} 1>konftest.out 2>konftest.log] failed, can't find \\"konftest\\" " >&2
         |                     if [ -f "konftest.out" ]
         |                     then
         |                        echo "$scriptName\[    \\"konftest.out\\" contains:" >&2
         |                        cat konftest.out >&2
         |                        echo "$scriptName]" >&2
         |                     fi
         |                     if [ -f "konftest.log" ]
         |                     then
         |                        echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                        cat konftest.log >&2
         |                        echo "$scriptName]" >&2
         |                     fi
         |                  fi
         |               fi
         |            else
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:    ...failed, exit code \${status}" >&2
         |                  echo "$scriptName: ...[\${cmd} 1>konftest.out 2>konftest.log] returned exit code \${status}" >&2
         |                  if [ -f "konftest.out" ]
         |                  then
         |                     echo "$scriptName\[    \\"konftest.out\\" contains:" >&2
         |                     cat konftest.out >&2
         |                     echo "$scriptName]" >&2
         |                  fi
         |                  if [ -f "konftest.log" ]
         |                  then
         |                     echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                     cat konftest.log >&2
         |                     echo "$scriptName]" >&2
         |                  fi
         |               fi
         |            fi
         |         else
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...can't find test code" >&2
         |            fi
         |         fi
         |         rm -f konftest.log
         |         rm -f konftest.out
         |         rm -f konftest
         |         rm -f konftest.o
         |         rm -f konftest.c
         |      fi
         |   fi
         |fi
         |
         |if [ "X\${Target_libc_pathname}" != "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  Examine the C library...
         |   #
         |   #---------------------------------------
         |   if [ "X\${Target_libc_verList}" = "X" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: examine \\"\${Target_libc_pathname}\\" for version numbers supported" >&2
         |      fi
         |      #---------------------------------------
         |      #
         |      #  ...for C library versions supported
         |      #
         |      #---------------------------------------
         |      rm -f konftest.log
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: ...run [\${Use_strings} \${Target_libc_pathname} | \${Use_grep} 'GLIBC_[0-9]' ..." >&2
         |      fi
         |      gives=`\${Use_strings} \${Target_libc_pathname} | \${Use_grep} 'GLIBC_[0-9]' | \${Use_sed} 's/^GLIBC_\\([0-9][.0-9]*\\)/\\1/' | \${Use_tr} '.' ' ' | \${Use_sort} -r -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | \${Use_tr} ' ' '.' | \${Use_tr} '\\n' ' ' 2>konftest.log`
         |      status=\$?
         |      if [ "X\${status}" = "X0" ]
         |      then
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    done, found [\${gives}]" >&2
         |         fi
         |         Target_libc_verList="\${gives}"
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    failed, exit code \${status}" >&2
         |         fi
         |      fi
         |      rm -f konftest.log
         |   fi
         |   if [ "X\${Target_libc_version}" = X ]
         |   then
         |      if [ "X\${Target_libc_verList}" != "X" ]
         |      then
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...find the first (latest) version..." >&2
         |         fi
         |         #---------------------------------------
         |         #
         |         #  ...for C library version
         |         #
         |         #---------------------------------------
         |         gives=`for first in \${Target_libc_verList}; do echo \\\${first}; break; done`
         |         status=\$?
         |         if [ "X\${status}" = "X0" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    done, found \${gives}" >&2
         |            fi
         |            Target_libc_version="\${gives}"
         |         else
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    failed, exit code is \${status}" >&2
         |            fi
         |         fi
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName: ...didn't find any version numbers" >&2
         |         fi
         |      fi
         |   fi
         |fi
EOF39
         if ($CXX_basename ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF40");
         |
         |if [ "X\${Target_CXX}" = "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  The C++ compiler and version...
         |   #
         |   #---------------------------------------
         |   Target_CXX="\${Source_CXX}"
         |   if [ "X\${Target_CXX}" != "X" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: ...locate \\"\${Target_CXX}\\" " >&2
         |      fi
         |      for d in \${myPath}
         |      do
         |         if [ X\${d} != X ]
         |         then
         |            if [ X\${d} != X. ]
         |            then
         |               if [ -f "\${d}/\${Target_CXX}" ]
         |               then
         |                  if [ -x "\${d}/\${Target_CXX}" ]
         |                  then
         |                     case "\${d}" in
         |                        /*) Use_cxx="\${d}/\${Target_CXX}"
         |                            ;;
         |                        *)  Use_cxx="\${here}/\${d}/\${Target_CXX}"
         |                            ;;
         |                     esac
         |                     break
         |                  fi
         |               fi
         |            fi
         |         fi
         |      done
         |      Target_CXX_pathname="\${Use_cxx}"
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         if [ "X\${Target_CXX_pathname}" != "X" ]
         |         then
         |            echo "$scriptName:    found \\\"\${Target_CXX_pathname}\\\" " >&2
         |         else
         |            echo "$scriptName:    can't find \\\"\${Target_CXX}\\\" " >&2
         |         fi
         |         echo "$scriptName: ...run [checkForCompilerVersion \${Target_CXX}]})..." >&2
         |      fi
         |      gives=`checkForCompilerVersion \${Target_CXX}`
         |      status=\$?
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName:    gives [\${gives}]" >&2
         |      fi
         |      if [ "X\${status}" = "X0" ]
         |      then
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...succeeded" >&2
         |         fi
         |         givesName=`echo \${gives} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^.0-9].*\\)*\$/\\1/'`
         |         givesVers=`echo \${gives} | \${Use_sed} -e 's/^[ ]*\\([^ ][^ ]*\\)[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^.0-9].*\\)*\$/\\2/'`
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:       match gives:" >&2
         |            echo "$scriptName:       ...name is [\${givesName}]" >&2
         |            echo "$scriptName:          version [\${givesVers}]" >&2
         |         fi
         |         if [ "X\${givesName}" != "X\${gives}" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...name is [\${givesName}]" >&2
         |            fi
         |            if [ "X\${givesVers}" != "X\${gives}" ]
         |            then
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:       version number is [\${givesVers}]" >&2
         |               fi
         |               Target_CXX_version="\${givesVers}"
         |            else
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:       ...version failed" >&2
         |               fi
         |               Target_CXX_version=""
         |            fi
         |         else
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:       ...name failed" >&2
         |            fi
         |            Target_CXX_version=""
         |         fi
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    failed with exit code \${status}" >&2
         |         fi
         |      fi
         |   else
         |      Target_CXX_version=""
         |   fi
         |   rm -f konftest
         |   rm -f konftest.o
         |   rm -f konftest.cxx
         |   rm -f konftest.out
         |   rm -f konftest.log
         |fi
         |
         |if [ "X\${Target_CXX}" != "X" ]
         |then
         |   if [ "X\${Target_stdcxxlib_pathname}" = "X" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName: collect info on Standard C++ library..." >&2
         |      fi
         |      #---------------------------------------
         |      #
         |      #  Locate the Standard C++ library...
         |      #
         |      #---------------------------------------
         |      bn=`basename \${Target_CXX}`
         |      if [ "X\${bn}" != "X" ]
         |      then
         |         #
         |         #  Build a C++ binary executable...
         |         #
         |         rm -f konftest.cxx
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    generate test code" >&2
         |         fi
         |         echo '#include <vector>'                      >konftest.cxx
         |         echo                                         >>konftest.cxx
         |         echo 'int main ( int argc, char *argv[] )'   >>konftest.cxx
         |         echo '{  int                      i;'        >>konftest.cxx
         |         echo '   std::vector<const char*> v;'        >>konftest.cxx
         |         echo                                         >>konftest.cxx
         |         echo '   for (i=0; i<argc; ++i) {'           >>konftest.cxx
         |         echo '      v.push_back(argv[i]);'           >>konftest.cxx
         |         echo '   }'                                  >>konftest.cxx
         |         echo '   for (i=0; i<argc; ++i) {'           >>konftest.cxx
         |         echo '      if (v[i]) {'                     >>konftest.cxx
         |         echo '         ;'                            >>konftest.cxx
         |         echo '      }'                               >>konftest.cxx
         |         echo '      else {'                          >>konftest.cxx
         |         echo '         return 1;'                    >>konftest.cxx
         |         echo '      }'                               >>konftest.cxx
         |         echo '   }'                                  >>konftest.cxx
         |         echo '   return 0;'                          >>konftest.cxx
         |         echo '}'                                     >>konftest.cxx
         |         echo                                         >>konftest.cxx
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...done" >&2
         |         fi
         |         if [ -f "konftest.cxx" ]
         |         then
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...found test code" >&2
         |               echo "$scriptName:    compile and link test code" >&2
         |            fi
         |            cmd="\${bn} -o konftest konftest.cxx"
         |            rm -f konftest.out konftest.log
         |            \${cmd} 1>konftest.out 2>konftest.log
         |            status=\$?
         |            if [ "X\${status}" = "X0" ]
         |            then
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:    ...done" >&2
         |               fi
         |               if [ -f "konftest" ]
         |               then
         |                  if [ "X\${debugging}" != "X0" ]
         |                  then
         |                     echo "$scriptName:    found \\"konftest\\" " >&2
         |                  fi
         |                  if [ -x "konftest" ]
         |                  then
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    which is executable" >&2
         |                        echo "$scriptName:    examine the binary executable" >&2
         |                     fi
         |                     rm -f konftest.log
         |                     if [ "X\${Target_os}" = "Xdarwin" ]
         |                     then
         |                        if [ "X\${debugging}" != "X0" ]
         |                        then
         |                           echo "$scriptName:    ...using \\"otool -L konftest | \${Use_grep} 'libstdc++' ..." >&2
         |                        fi
         |                        gives=`( otool -L konftest | \${Use_grep} 'libstdc++[^ ]*\\.dylib' | while read a b c d ; do echo \\\${a} ; done ) 2>konftest.log`
         |                        status=\$?
         |                        if [ "X\${status}" = "X0" ]
         |                        then
         |                           Target_stdcxxlib_pathname="\${gives}"
         |                        else
         |                           if [ "X\${debugging}" != "X0" ]
         |                           then
         |                              echo "$scriptName:       failed, exit code \${status}" >&2
         |                              if [ -f "konftest.log" ]
         |                              then
         |                                 echo "$scriptName\[       \\"konftest.log\\" contains:" >&2
         |                                 cat konftest.log >&2
         |                                 echo "$scriptName]" >&2
         |                              fi
         |                           fi
         |                        fi
         |                     else
         |                        if [ "X\${debugging}" != "X0" ]
         |                        then
         |                           echo "$scriptName:    ...using \\"\${Use_ldd} konftest | \${Use_fgrep} 'libstdc++' | ..." >&2
         |                        fi
         |                        gives=`( \${Use_ldd} konftest | \${Use_fgrep} 'libstdc++' | while read a b c d ; do echo \\\${c} ; done ) 2>konftest.log`
         |                        status=\$?
         |                        if [ "X\${status}" = "X0" ]
         |                        then
         |                           Target_stdcxxlib_pathname="\${gives}"
         |                        else
         |                           if [ "X\${debugging}" != "X0" ]
         |                           then
         |                              echo "$scriptName:       failed, exit code \${status}" >&2
         |                              echo "$scriptName\[       \\"konftest.log\\" contains:" >&2
         |                              cat konftest.log >&2
         |                              echo "$scriptName]" >&2
         |                           fi
         |                        fi
         |                     fi
         |                  else
         |                     if [ "X\${debugging}" != "X0" ]
         |                     then
         |                        echo "$scriptName:    but it isn't executable" >&2
         |                        if [ -f "konftest.out" ]
         |                        then
         |                           echo "$scriptName\[    ...\\"konftest.out\\" contains:" >&2
         |                           cat konftest.out >&2
         |                           echo "$scriptName]" >&2
         |                        fi
         |                        if [ -f "konftest.log" ]
         |                        then
         |                           echo "$scriptName\[    ...\\"konftest.log\\" contains:" >&2
         |                           cat konftest.log >&2
         |                           echo "$scriptName]" >&2
         |                        fi
         |                     fi
         |                  fi
         |               else
         |                  if [ "X\${debugging}" != "X0" ]
         |                  then
         |                     echo "$scriptName:    can't find \\"konftest\\" " >&2
         |                     if [ -f "konftest.out" ]
         |                     then
         |                        echo "$scriptName\[    \\"konftest.out\\" contains:" >&2
         |                        cat konftest.out >&2
         |                        echo "$scriptName]" >&2
         |                     fi
         |                     if [ -f "konftest.log" ]
         |                     then
         |                        echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                        cat konftest.log >&2
         |                        echo "$scriptName]" >&2
         |                     fi
         |                  fi
         |               fi
         |            else
         |               if [ "X\${debugging}" != "X0" ]
         |               then
         |                  echo "$scriptName:    ...failed, with exit code \${status}" >&2
         |                  if [ -f "konftest.out" ]
         |                  then
         |                     echo "$scriptName\[       \\"konftest.out\\" contains:" >&2
         |                     cat konftest.out >&2
         |                     echo "$scriptName]" >&2
         |                  fi
         |                  if [ -f "konftest.log" ]
         |                  then
         |                     echo "$scriptName\[       \\"konftest.log\\" contains:" >&2
         |                     cat konftest.log >&2
         |                     echo "$scriptName]" >&2
         |                  fi
         |               fi
         |            fi
         |         else
         |            if [ "X\${debugging}" != "X0" ]
         |            then
         |               echo "$scriptName:    ...can't find test code" >&2
         |            fi
         |         fi
         |         rm -f konftest.log
         |         rm -f konftest.out
         |         rm -f konftest
         |         rm -f konftest.o
         |         rm -f konftest.cxx
         |      fi
         |   fi
         |fi
         |
         |if [ "X\${Target_stdcxxlib_pathname}" != "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  Examine the Standard C++ library...
         |   #
         |   #---------------------------------------
         |   if [ "X\${Target_stdcxxlib_libcVerList}" = "X" ]
         |   then
         |      #---------------------------------------
         |      #
         |      #  ...for C library versions supported
         |      #
         |      #---------------------------------------
         |      rm -f konftest.log
         |      gives=`\${Use_strings} \${Target_stdcxxlib_pathname} | \${Use_grep} 'GLIBC_[0-9]' | \${Use_sed} 's/^GLIBC_\\([0-9][.0-9]*\\)/\\1/' | \${Use_tr} '.' ' ' | \${Use_sort} -r -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | \${Use_tr} ' ' '.' | \${Use_tr} '\\n' ' ' 2>konftest.log`
         |      status=\$?
         |      if [ "X\${status}" = "X0" ]
         |      then
         |         Target_stdcxxlib_libcVerList="\${gives}"
         |      fi
         |      rm -f konftest.log
         |   fi
         |   if [ "X\${Target_stdcxxlib_libcVersion}" = X ]
         |   then
         |      if [ "X\${Target_stdcxxlib_libcVerList}" != "X" ]
         |      then
         |         #---------------------------------------
         |         #
         |         #  ...for C library version
         |         #
         |         #---------------------------------------
         |         gives=`for first in \${Target_stdcxxlib_libcVerList}; do echo \\\${first}; break; done`
         |         status=\$?
         |         if [ "X\${status}" = "X0" ]
         |         then
         |            Target_stdcxxlib_libcVersion="\${gives}"
         |         fi
         |      fi
         |   fi
         |fi
         |
         |if [ "X\${Target_stdcxxlib_pathname}" != "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  Examine the Standard C++ library...
         |   #
         |   #---------------------------------------
         |   if [ "X\${Target_stdcxxlib_verList}" = "X" ]
         |   then
         |      #---------------------------------------
         |      #
         |      #  ...for Standard C++ library versions supported
         |      #
         |      #---------------------------------------
         |      rm -f konftest.log
         |      gives=`\${Use_strings} \${Target_stdcxxlib_pathname} | \${Use_grep} 'GLIBC\\(XX\\|PP\\)_[0-9]' | \${Use_sed} 's/^GLIBC\\(PP\\|XX\\)_\\([0-9][.0-9]*\\)/\\2/' | \${Use_tr} '.' ' ' | \${Use_sort} -r -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | \${Use_tr} ' ' '.' | \${Use_tr} '\\n' ' ' 2>konftest.log`
         |      status=\$?
         |      if [ "X\${status}" = "X0" ]
         |      then
         |         after=`echo \${gives} | \${Use_sed} 's/[^\\. 0-9]//g'`
         |         Target_stdcxxlib_verList="\${after}"
         |      fi
         |      rm -f konftest.log
         |   fi
         |   if [ "X\${Target_stdcxxlib_version}" = X ]
         |   then
         |      if [ "X\${Target_stdcxxlib_verList}" != "X" ]
         |      then
         |         #---------------------------------------
         |         #
         |         #  ...for Standard C++ library version
         |         #
         |         #---------------------------------------
         |         gives=`for first in \${Target_stdcxxlib_verList}; do echo \\\${first}; break; done`
         |         status=\$?
         |         if [ "X\${status}" = "X0" ]
         |         then
         |            Target_stdcxxlib_version="\${gives}"
         |         fi
         |      fi
         |   fi
         |fi
         |
         |if [ "X\${Target_stdcxxlib_pathname}" != "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  Examine the Standard C++ library...
         |   #
         |   #---------------------------------------
         |   if [ "X\${Target_stdcxxlib_abiVerList}" = "X" ]
         |   then
         |      #---------------------------------------
         |      #
         |      #  ...for C++ ABI versions supported
         |      #
         |      #---------------------------------------
         |      rm -f konftest.log
         |      gives=`\${Use_strings} \${Target_stdcxxlib_pathname} | \${Use_grep} 'C\\(XX\\|PP\\)ABI_[0-9]' | \${Use_sed} 's/^C\\(PP\\|XX\\)ABI_\\([0-9][.0-9]*\\)/\\2/' | \${Use_tr} '.' ' ' | \${Use_sort} -r -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | \${Use_tr} ' ' '.' | \${Use_tr} '\\n' ' ' 2>konftest.log`
         |      status=\$?
         |      if [ "X\${status}" = "X0" ]
         |      then
         |         after=`echo \${gives} | \${Use_sed} 's/[^\\. 0-9]//g'`
         |         Target_stdcxxlib_abiVerList="\${after}"
         |      fi
         |      rm -f konftest.log
         |   fi
         |   if [ "X\${Target_stdcxxlib_abiVersion}" = X ]
         |   then
         |      if [ "X\${Target_stdcxxlib_abiVerList}" != "X" ]
         |      then
         |         #---------------------------------------
         |         #
         |         #  ...for C++ ABI version
         |         #
         |         #---------------------------------------
         |         gives=`for first in \${Target_stdcxxlib_abiVerList}; do echo \\\${first}; break; done`
         |         status=\$?
         |         if [ "X\${status}" = "X0" ]
         |         then
         |            Target_stdcxxlib_abiVersion="\${gives}"
         |         fi
         |      fi
         |   fi
         |fi
EOF40
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF41");
         |
         |showInfo=false
         |if [ "X\${JustQuery}" != "Xfalse" ]
         |then
         |   showInfo=true
         |fi
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   showInfo=true
         |fi
         |if [ "X\${showInfo}" != "X0" ]
         |then
         |   echo "$scriptName: supplied info:" >&2
         |   echo "$scriptName: ...Generated by mkinstaller $mkinstaller_ver_name rev. $mkinstaller_ver_time" >&2
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName:              on $GenTime" >&2
         |   fi
         |   echo "$scriptName: ...Source_hw                    = [\${Source_hw}]" >&2
         |   echo "$scriptName:    Source_os                    = [\${Source_os}]" >&2
         |   echo "$scriptName:    Source_os_version            = [\${Source_os_version}]" >&2
         |   echo "$scriptName:    Source_CC                    = [\${Source_CC}]" >&2
         |   echo "$scriptName:    Source_CC_pathname           = [\${Source_CC_pathname}]" >&2
         |   echo "$scriptName:    Source_CC_version            = [\${Source_CC_version}]" >&2
         |   echo "$scriptName:    Source_libc_pathname         = [\${Source_libc_pathname}]" >&2
         |   echo "$scriptName:    Source_libc_verList          = [\${Source_libc_verList}]" >&2
         |   echo "$scriptName:    Source_libc_version          = [\${Source_libc_version}]" >&2
         |   echo "$scriptName:    Source_libc_XversionX        = [\${Source_libc_XversionX}]" >&2
         |   echo "$scriptName:    Source_CXX                   = [\${Source_CXX}]" >&2
         |   echo "$scriptName:    Source_CXX_pathname          = [\${Source_CXX_pathname}]" >&2
EOF41
         if ($CXX_basename ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF42");
         |   echo "$scriptName:    Source_CXX_version           = [\${Source_CXX_version}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_pathname    = [\${Source_stdcxxlib_pathname}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_verList     = [\${Source_stdcxxlib_verList}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_version     = [\${Source_stdcxxlib_version}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_abiVerList  = [\${Source_stdcxxlib_abiVerList}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_abiVersion  = [\${Source_stdcxxlib_abiVersion}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_libcVerList = [\${Source_stdcxxlib_libcVerList}]" >&2
         |   echo "$scriptName:    Source_stdcxxlib_libcVersion = [\${Source_stdcxxlib_libcVersion}]" >&2
EOF42
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF43");
         |   echo "$scriptName: derived info:" >&2
         |   echo "$scriptName: ...Target_hw                    = [\${Target_hw}]" >&2
         |   echo "$scriptName:    Target_os                    = [\${Target_os}]" >&2
         |   echo "$scriptName:    Target_os_version            = [\${Target_os_version}]" >&2
         |   echo "$scriptName:    Target_CC                    = [\${Target_CC}]" >&2
         |   echo "$scriptName:    Target_CC_pathname           = [\${Target_CC_pathname}]" >&2
         |   echo "$scriptName:    Target_CC_version            = [\${Target_CC_version}]" >&2
         |   echo "$scriptName:    Target_libc_pathname         = [\${Target_libc_pathname}]" >&2
         |   echo "$scriptName:    Target_libc_verList          = [\${Target_libc_verList}]" >&2
         |   echo "$scriptName:    Target_libc_version          = [\${Target_libc_version}]" >&2
         |   echo "$scriptName:    Target_libc_XversionX        = [\${Target_libc_XversionX}]" >&2
         |   echo "$scriptName:    Target_CXX                   = [\${Target_CXX}]" >&2
EOF43
         if ($CXX_basename ne "") {
            print SCRIPT pKit_fixIndentStuff(<<"EOF44");
         |   echo "$scriptName:    Target_CXX_version           = [\${Target_CXX_version}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_pathname    = [\${Target_stdcxxlib_pathname}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_verList     = [\${Target_stdcxxlib_verList}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_version     = [\${Target_stdcxxlib_version}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_abiVerList  = [\${Target_stdcxxlib_abiVerList}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_abiVersion  = [\${Target_stdcxxlib_abiVersion}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_libcVerList = [\${Target_stdcxxlib_libcVerList}]" >&2
         |   echo "$scriptName:    Target_stdcxxlib_libcVersion = [\${Target_stdcxxlib_libcVersion}]" >&2
EOF44
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF45");
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Check for compatibility...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: checking for compatibility..." >&2
         |fi
         |if [ "X\${enforce}" != "Xtrue" ]
         |then
         |   style="warning"
         |else
         |   style="error"
         |fi
         |ok=true
         |
         |#---------------------------------------
         |#
         |#  Check for HW compatibility...
         |#
         |#---------------------------------------
         |
         |if [ "X\${Source_hw}" != "X" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...HW type" >&2
         |   fi
         |   if [ "X\${Target_hw}" != "X" ]
         |   then
         |      if [ "X\${Source_hw}" != "X\${Target_hw}" ]
         |      then
         |         echo "$scriptName: \${style} -- this installer is not compatible with this system" >&2
         |         echo "$scriptName: ...source HW was [\${Source_hw}] " >&2
         |         echo "$scriptName:     target HW is [\${Target_hw}] " >&2
         |         ok=false
         |      fi
         |   else
         |      echo "$scriptName: \${style} -- couldn't determine OS for this system" >&2
         |      ok=false
         |   fi
         |fi
         |
         |if [ "X\${ok}" != "Xtrue" ]
         |then
         |   if [ "X\${enforce}" = "Xtrue" ]
         |   then
         |      echo "$scriptName: fatal: installation aborted" >&2
         |      exit 1
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  Check for OS compatibility...
         |#
         |#---------------------------------------
         |
         |if [ "X\${Source_os}" != "X" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...OS type" >&2
         |   fi
         |   if [ "X\${Target_os}" != "X" ]
         |   then
         |      if [ "X\${Source_os}" != "X\${Target_os}" ]
         |      then
         |         echo "$scriptName: \${style} -- this installer is not compatible with this system" >&2
         |         echo "$scriptName: ...source OS was \\\"\${Source_os}\\\" " >&2
         |         echo "$scriptName:     target OS is \\\"\${Target_os}\\\" " >&2
         |         ok=false
         |      fi
         |   else
         |      echo "$scriptName: \${style} -- couldn't determine OS for this system" >&2
         |      ok=false
         |   fi
         |fi
         |
         |if [ "X\${ok}" != "Xtrue" ]
         |then
         |   if [ "X\${enforce}" = "Xtrue" ]
         |   then
         |      echo "$scriptName: fatal: installation aborted" >&2
         |      exit 1
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  Check for libc compatibility...
         |#
         |#---------------------------------------
         |
         |if [ "X\${Source_libc_version}" != "X" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...libc version" >&2
         |   fi
         |   if [ "X\${Target_libc_verList}" != "X" ]
         |   then
         |      found=false
         |      for v in \${Target_libc_verList}
         |      do
         |         if [ "X\${v}" = "X\${Source_libc_version}" ]
         |         then
         |            found=true
         |            break
         |         fi
         |      done
         |      if [ "X\${found}" != "Xtrue" ]
         |      then
         |         echo "$scriptName: \${style} -- this installer is not compatible with this system" >&2
         |         echo "$scriptName: ...source libc version is \\\"\${Source_libc_version}\\\" " >&2
         |         first=true
         |         for v in \${Target_libc_verList}
         |         do
         |            if [ "X\${first}" = "Xtrue" ]
         |            then
         |               echo "$scriptName:      target supports libc \\\"\${v}\\\" " >&2
         |               first=false
         |            else
         |               echo "$scriptName:                           \\\"\${v}\\\" " >&2
         |            fi
         |         done
         |         ok=false
         |      fi
         |   else
         |      echo "$scriptName: \${style} -- couldn't determine list of supported libc versions for this system" >&2
         |      ok=false
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  Check for Standard C++ library compatibility...
         |#
         |#---------------------------------------
         |
         |if [ "X\${Source_stdcxxlib_version}" != "X" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...standard C++ library version" >&2
         |   fi
         |   if [ "X\${Target_stdcxxlib_verList}" != "X" ]
         |   then
         |      found=false
         |      for v in \${Target_stdcxxlib_verList}
         |      do
         |         if [ "X\${v}" = "X\${Source_stdcxxlib_version}" ]
         |         then
         |            found=true
         |            break
         |         fi
         |      done
         |      if [ "X\${found}" != "Xtrue" ]
         |      then
         |         echo "$scriptName: \${style} -- this installer is not compatible with this system" >&2
         |         echo "$scriptName: ...source standard C++ library version is \\\"\${Source_stdcxxlib_version}\\\" " >&2
         |         first=true
         |         for v in \${Target_stdcxxlib_verList}
         |         do
         |            if [ "X\${first}" = "Xtrue" ]
         |            then
         |               echo "$scriptName:      target supports standard C++ library \\\"\${v}\\\" " >&2
         |               first=false
         |            else
         |               echo "$scriptName:                                           \\\"\${v}\\\" " >&2
         |            fi
         |         done
         |         ok=false
         |      fi
         |   else
         |      echo "$scriptName: \${style} -- couldn't determine list of supported standard C++ library versions for this system" >&2
         |      ok=false
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  Check for Standard C++ library ABI compatibility...
         |#
         |#---------------------------------------
         |
         |if [ "X\${Source_stdcxxlib_abiVersion}" != "X" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...standard C++ library ABI version" >&2
         |   fi
         |   if [ "X\${Target_stdcxxlib_abiVerList}" != "X" ]
         |   then
         |      found=false
         |      for v in \${Target_stdcxxlib_abiVerList}
         |      do
         |         if [ "X\${v}" = "X\${Source_stdcxxlib_abiVersion}" ]
         |         then
         |            found=true
         |            break
         |         fi
         |      done
         |      if [ "X\${found}" != "Xtrue" ]
         |      then
         |         echo "$scriptName: \${style} -- this installer is not compatible with this system" >&2
         |         echo "$scriptName: ...source standard C++ library ABI version is \\\"\${Source_stdcxxlib_abiVersion}\\\" " >&2
         |         first=true
         |         for v in \${Target_stdcxxlib_abiVerList}
         |         do
         |            if [ "X\${first}" = "Xtrue" ]
         |            then
         |               echo "$scriptName:      target supports standard C++ library ABI \\\"\${v}\\\" " >&2
         |               first=false
         |            else
         |               echo "$scriptName:                                               \\\"\${v}\\\" " >&2
         |            fi
         |         done
         |         ok=false
         |      fi
         |   else
         |      echo "$scriptName: \${style} -- couldn't determine list of supported standard C++ library ABI versions for this system" >&2
         |      ok=false
         |   fi
         |fi
         |
         |if [ "X\${ok}" != "Xtrue" ]
         |then
         |   if [ "X\${enforce}" = "Xtrue" ]
         |   then
         |      echo "$scriptName: fatal: installation aborted" >&2
         |      exit 1
         |   fi
         |fi
         |
         |if [ "X\${JustQuery}" != "Xfalse" ]
         |then
         |   echo "$scriptName: ...done" >&2
         |   exit 0
         |fi
         |
         |#---------------------------------------
         |#
         |#  Create the (adjusted) installation
         |#  PREFIX directories if necessary...
         |#
         |#---------------------------------------
         |
         |if [ "X\${PREFIX}" != "X" ]
         |then
         |   if [ ! -d "\${PREFIX}" ]
         |   then
         |      if [ 1 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: creating directory \\"\${PREFIX}\\" " >&2
         |      fi
         |      mkdir -p "\${PREFIX}" >/dev/null 2>&1
         |      status=\$?
         |      if [ "X\${status}" != "X0" ]
         |      then
         |         echo "$scriptName: error: can't create directory \\"\${PREFIX}\\" " >&2
         |         echo "$scriptName: ...[mkdir -p \\"\${PREFIX}\\"] returned exit code \${status}" >&2
         |         exit 1
         |      fi
         |      if [ ! -d "\${PREFIX}" ]
         |      then
         |         echo "$scriptName: error: didn't create directory \\"\${PREFIX}\\" " >&2
         |         exit 1
         |      fi
         |      if [ 2 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: ...done" >&2
         |      fi
         |      if [ 0 -eq \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: note: created \\"\${PREFIX}\\" " >&2
         |      fi
         |   else
         |      if [ 2 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: note: \\"\${PREFIX}\\" already exists" >&2
         |      fi
         |   fi
         |fi
EOF45
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT pKit_fixIndentStuff(<<"EOF46");
         |
         |if [ "X\${PREFIX_$vn}" != "X" ]
         |then
         |   if [ ! -d "\${PREFIX_$vn}" ]
         |   then
         |      if [ 1 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: creating directory \\"\${PREFIX_$vn}\\" " >&2
         |      fi
         |      mkdir -p "\${PREFIX_$vn}" >/dev/null 2>&1
         |      status=\$?
         |      if [ "X\${status}" != "X0" ]
         |      then
         |         echo "$scriptName: error: can't create directory \\"\${PREFIX_$vn}\\" " >&2
         |         echo "$scriptName: ...[mkdir -p \\"\${PREFIX_$vn}\\"] returned exit code \${status}" >&2
         |         exit 1
         |      fi
         |      if [ ! -d "\${PREFIX_$vn}" ]
         |      then
         |         echo "$scriptName: error: didn't create directory \\"\${PREFIX_$vn}\\" " >&2
         |         exit 1
         |      fi
         |      if [ 2 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: ...done" >&2
         |      fi
         |      if [ 0 -eq \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: note: created \\"\${PREFIX_$vn}\\" " >&2
         |      fi
         |   fi
         |fi
EOF46
            }
         }
         if ($withPayload) {
            print SCRIPT pKit_fixIndentStuff(<<"EOF47");
         |
         |if [ "X\${debugging}" = "Xtrue" ]
         |then
         |   amNowIn="`pwd`"
         |   echo "$scriptName: contents of "\${amNowIn}" " >&2
         |   /bin/ls -alF
         |fi
EOF47
         }
         else {
            print SCRIPT pKit_fixIndentStuff(<<"EOF48");
         |
         |if [ "X\${debugging}" = "Xtrue" ]
         |then
         |   amNowIn="`pwd`"
         |   echo "$scriptName: contents of "\${amNowIn}" " >&2
         |   /bin/ls -alF
         |fi
EOF48
         }
         if ($withPayload) {
         print SCRIPT pKit_fixIndentStuff(<<"EOF49");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  The self-extraction magic...
         |#
         |#  FIX: The untar process reports:
         |#
         |#          wrapper/
EOF49
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               print SCRIPT pKit_fixIndentStuff(<<"EOF50");
         |#          wrapper/$bn.tar.gz
EOF50
            }
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF51");
         |#
         |#          gzip: stdin: unexpected end of file
         |#          tar: Child returned status 1
         |#          tar: Error is not recoverable: exiting now
         |#
         |#       Note that we've used a work-around: The wrapper tarball(=wrapper.tar)
         |#       is not compressed (thus avoiding the above problem). This may seem a
         |#       bit waseful but the contents of the wrapper directory are already
         |#       compressed tarballs, compressing the wrapper directory actually gives
         |#       very little improvement anyway.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: extracting wrapper tarball" >&2
         |fi
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   nowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${nowIn}\" " >&2
         |   echo "$scriptName: ...run [\${Use_awk} '/^__PAYLOAD_BELOW__/ {print NR + 1; exit 0; }' \"\${commandPathname}\"] " >&2
         |fi
         |PAYLOAD_LINE=\`\${Use_awk} '/^__PAYLOAD_BELOW__/ {print NR + 1; exit 0; }' "\${commandPathname}"\`
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: [\${Use_awk} '/^__PAYLOAD_BELOW__/ {print NR + 1; exit 0; }' \"\${commandPathname}\"] failed, exit code \${status}" >&2
         |   exit 1
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName:    gives: [\${PAYLOAD_LINE}]" >&2
         |   nowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${nowIn}\" " >&2
         |   echo "$scriptName: ...run [\${Use_tail} -n +\${PAYLOAD_LINE} \"\${commandPathname}\" > \"wrapper.tar\"]" >&2
         |fi
         |\${Use_tail} -n +\${PAYLOAD_LINE} "\${commandPathname}" >"wrapper.tar"
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: [\${Use_tail} +\${PAYLOAD_LINE} "\${commandPathname}" >"wrapper.tar"] failed, exit code \${status}" >&2
         |   exit 1
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName:    done" >&2
         |   pwd
         |   /bin/ls -aldF
         |   pwd
         |   nowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${nowIn}\" " >&2
         |   if [ "X\${IsGNUtar}" = "Xtrue" ]
         |   then
         |      echo "$scriptName:    note \${Use_tar} is GNU tar" >&2
         |   else
         |      echo "$scriptName:    note \${Use_tar} is not GNU tar" >&2
         |   fi
         |   echo "$scriptName: ...run [\${Use_tar} -xf \"wrapper.tar\"]" >&2
         |fi
         |if [ "X\${QuitJustBefore}" = "Xtrue" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName: quitting first" >&2
         |   fi
         |   exit 1
         |fi
         |
         |\${Use_tar} -xf "wrapper.tar" >tar.output 2>&1
         |status=\$?
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName:    gives exit code \${status}" >&2
         |fi
         |if [ "X\${status}" != "X0" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName:    ...failure" >&2
         |   fi
         |   echo "$scriptName: error: problem extracting tarball(=\"wrapper.tar\") from script(=\"\${commandPathname}\")" >&2
         |   echo "$scriptName: ...[\${Use_tar} -xf \"wrapper.tar\"] returned exit code \${status}" >&2
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      if [ -f "tar.output" ]
         |      then
         |         cat "tar.output" >&2
         |         rm -f "tar.output"
         |      fi
         |      exit 1
         |   fi
         |else
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName:    ...success" >&2
         |   fi
         |fi
         |rm -f "tar.output"
         |
         |if [ 2 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: ...done" >&2
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  After extracting the wrapper directory from the wrapper directory from
         |#  the wrapper tarball we can toss the wrapper tarball (it was just a copy
         |#  extracted from the $scriptName script.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${keep}" != "Xtrue" ]
         |then
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      nowIn="`pwd`"
         |      echo "$scriptName: ...in \\"\${nowIn}\\" " >&2
         |      echo "$scriptName: ...run [rm \\"wrapper.tar\\"]" >&2
         |   fi
         |   rm "wrapper.tar"
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: error: can't cleanup the tarball(=\"wrapper.tar\")" >&2
         |      echo "$scriptName: ...[rm \"wrapper.tar\"] returned exit code \${status}" >&2
         |      exit 1
         |   fi
         |else
         |   echo "$scriptName: keeping tarball(=\"wrapper.tar\")" >&2
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${amNowIn}\" " >&2
         |   lookFor="\${amNowIn}/wrapper.tar"
         |   if [ -f "\${lookFor}" ]
         |   then
         |      echo "$scriptName: ...have \"\${lookFor}\" " >&2
         |   fi
         |fi
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: \"\${amNowIn}\" after extraction..." >&2
         |   /bin/ls -alF
         |fi
EOF51
         }
         if ($withPayload) {
            print SCRIPT pKit_fixIndentStuff(<<"EOF52");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  The wrapper directory should now be in place. Remember that we're in the
         |#  temporary directory. Before further unwrapping we'll step in to the wrapper
         |#  directory check for pre- and post-install scripts (if they'd been supplied)
         |#  and each of the expected individual tarballs. If we find all of what is
         |#  expected we can then unwrap each individual tarball putting each its proper
         |#  place.
         |#
         |#-------------------------------------------------------------------------------
         |
         |cd "wrapper"
         |
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: contents of \"\${amNowIn}\" " >&2
         |   /bin/ls -alF
         |fi
         |
         |allThere=true
EOF52
            if ($preInstallPathname ne "") {
               my $bn = pKit_basename($preInstallPathname);
               print SCRIPT pKit_fixIndentStuff(<<"EOF53");
         |
         |#---------------------------------------
         |#
         |#  Check for \"$bn\" (the pre-install
         |#  script)...
         |#
         |#---------------------------------------
         |
         |if [ ! -f "$bn" ]
         |then
         |   echo "$scriptName: seem to be missing \\"$bn\\" " >&2
         |   allThere=false
         |else
         |   if [ 2 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...have \\"$bn\\" in \\"wrapper\\" " >&2
         |   fi
         |fi
EOF53
            }
            if ($postInstallPathname ne "") {
               my $bn = pKit_basename($postInstallPathname);
               print SCRIPT pKit_fixIndentStuff(<<"EOF54");
         |
         |#---------------------------------------
         |#
         |#  Check for \"$bn\" (the post-install
         |#  script)...
         |#
         |#---------------------------------------
         |
         |if [ ! -f "$bn" ]
         |then
         |   echo "$scriptName: seem to be missing \\"$bn\\" " >&2
         |   allThere=false
         |else
         |   if [ 2 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...have \\"$bn\\" in \\"wrapper\\" " >&2
         |   fi
         |fi
EOF54
            }
            {
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  my $vn = $bn;
                  $vn    =~ tr/a-zA-Z0-9_/_/c;
                  print SCRIPT pKit_fixIndentStuff(<<"EOF55");
         |
         |#---------------------------------------
         |#
         |#  Check for the \"$bn\" tarball...
         |#
         |#---------------------------------------
         |
         |if [ ! -f "$bn.tar.gz" ]
         |then
         |   echo "$scriptName: error: seem to be missing \\"$bn.tar.gz\\" " >&2
         |   allThere=false
         |else
         |   if [ 3 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...have \\"$bn.tar.gz\\" in \\"wrapper\\" " >&2
         |   fi
         |fi
EOF55
               }
               print SCRIPT pKit_fixIndentStuff(<<"EOF56");
         |if [ "X\${allThere}" != "Xtrue" ]
         |then
         |   exit 1
         |fi
EOF56
            }
            if ($preInstallBasename ne "") {
               print SCRIPT pKit_fixIndentStuff(<<"EOF57");
            |
            |#-------------------------------------------------------------------------------
            |#
            |#  Run the pre-install script...
            |#
            |#  Note that this is done from the temporary wrapper directory and that the
            |#  prefix directories are passed as options on the command line (so that the
            |#  script knows where to find things.
            |#
            |#-------------------------------------------------------------------------------
            |
            |if [ -f "$preInstallBasename" ]
            |then
            |   amIn=\`pwd\`
            |   if [ 1 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: running pre-install script \\"\${PostInstallScriptName}\\" " >&2
            |   fi
EOF57
               my $theCmd = "\"./$preInstallBasename\"\${Vflag}";
               {
                  my $bn;
                  foreach $bn (sort keys %dirBasenames) {
                     my $vn  = $bn;
                     $vn     =~ tr/a-zA-Z0-9_/_/c;
                     $theCmd = $theCmd." --prefix-$bn=\"\${PREFIX_$vn}\"";
                  }
               }
               if ($preInstallStyle ne "binary") {
                  $theCmd = $preInstallStyle." ".$theCmd;
               }
               print SCRIPT pKit_fixIndentStuff(<<"EOF58");
            |   if [ "X\${debugging}" != "X0" ]
            |   then
            |      echo "$scriptName: ...from \\"\${amIn}\\" " >&2
            |      echo "$scriptName:    run [$theCmd]" >&2
            |   fi
            |   $theCmd >&2
            |   status=\$?
            |   if [ "X\${status}" != "X0" ]
            |   then
            |      if [ "X\${debugging}" != "X0" ]
            |      then
            |         echo "$scriptName:    ...failed, exit code \${status}" >&2
            |      fi
            |      echo "$scriptName: error: pre-install script(=\\"$preInstallBasename\\") failed" >&2
            |      echo "$scriptName: ...[$theCmd] returned exit code \${status}" >&2
            |      exit 1
            |   else
            |      if [ "X\${debugging}" != "X0" ]
            |      then
            |         echo "$scriptName:    ...succeeded" >&2
            |      fi
            |   fi
            |   if [ 2 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: ...done" >&2
            |   fi
            |else
            |   echo "$scriptName: error: didn't find pre-install script \\"$preInstallBasename\\" " >&2
            |   exit 1
            |fi
EOF58
            }
            {
            print SCRIPT pKit_fixIndentStuff(<<"EOF59");
            |if [ 1 -le \${verbosityLevel} ]
            |then
            |   echo "$scriptName:" >&2
            |fi
EOF59
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  my $vn = $bn;
                  $vn    =~ tr/a-zA-Z0-9_/_/c;
                  print SCRIPT pKit_fixIndentStuff(<<"EOF60");
         |
         |#---------------------------------------
         |#
         |#   Unwrap the individual $bn.tar.gz
         |#   tarball to form the \${PREFIX_$vn}/$bn
         |#   directory.
         |#
         |#---------------------------------------
         |
         |wasIn="\`pwd\`"
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: was in \\"\${wasIn}\\" " >&2
         |fi
         |cd "\${PREFIX_$vn}"
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: extracting \\"$bn\\" " >&2
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      nowIn="\`pwd\`"
         |      echo "$scriptName: ...in \\"\${nowIn}\\" " >&2
         |   fi
         |   if [ "X\${WasCompressed}" != "X0" ]
         |   then
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName:    with compression" >&2
         |      fi
         |      if [ "X\${IsGNUtar}" != "Xfalse" ]
         |      then
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...note \${Use_tar} is GNU tar" >&2
         |            echo "$scriptName:    run [\${Use_tar} -xzf \\"\${wasIn}/$bn.tar.gz\\"]" >&2
         |         fi
         |         \${Use_tar} -xzf "\${wasIn}/$bn.tar.gz" 2>/dev/null
         |         status=\$?
         |         if [ "X\${status}" != "X0" ]
         |         then
         |            echo "$scriptName: error: can't unwrap \\"$bn\\" " >&2
         |            echo "$scriptName: ...[\${Use_tar} -xzf \\"\\\${wasIn}/$bn.tar.gz\\"] returned exit code \${status}" >&2
         |            exit 1
         |         fi
         |      else
         |         if [ "X\${debugging}" != "X0" ]
         |         then
         |            echo "$scriptName:    ...note \${Use_tar} is not GNU tar" >&2
         |            echo "$scriptName:    run [\${Use_gzcat} \\"\${wasIn}/$bn.tar.gz\\" | \${Use_tar} xf - ]" >&2
         |         fi
         |         ( \${Use_gzcat} "\${wasIn}/$bn.tar.gz" | \${Use_tar} xf - ) 2>/dev/null
         |         status=\$?
         |         if [ "X\${status}" != "X0" ]
         |         then
         |            echo "$scriptName: error: can't unwrap \\"$bn\\" " >&2
         |            echo "$scriptName: ...[\${Use_gzcat} "\${wasIn}/$bn.tar.gz" | \${Use_tar} xf -] returned exit code \${status}" >&2
         |            exit 1
         |         fi
         |      fi
         |   else
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName:    without compression" >&2
         |      fi
         |      if [ "X\${debugging}" != "X0" ]
         |      then
         |         echo "$scriptName:    run [\${Use_tar} -xf \\"\${wasIn}/$bn.tar\\"]" >&2
         |      fi
         |      \${Use_tar} -xf "\${wasIn}/$bn.tar" 2>/dev/null
         |      status=\$?
         |      if [ "X\${status}" != "X0" ]
         |      then
         |         echo "$scriptName: error: can't unwrap \\"$bn\\" " >&2
         |         echo "$scriptName: ...[\${Use_tar} -xf \\"\\\${wasIn}/$bn.tar\\"] returned exit code \${status}" >&2
         |         exit 1
         |      fi
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName:    done" >&2
         |      if [ -d "\${PREFIX_$vn}/$bn" ]
         |      then
         |         echo "$scriptName: ...found directory \\"\${PREFIX_$vn}/$bn\\" " >&2
         |      else
         |         echo "$scriptName: ...can't find directory \\"\${PREFIX_$vn}/$bn\\" " >&2
         |      fi
         |   fi
         |cd "\${wasIn}"
EOF60
               }
            }
            if (1 <= $fileBasenameCount) {
               print SCRIPT pKit_fixIndentStuff(<<"EOF61");
         |#---------------------------------------
         |#
         |#   Copy the individual files into the
         |#   (top level) \${PREFIX}/ directory.
         |#
         |#---------------------------------------
         |
         |wasIn="\`pwd\`"
         |if [ "X\${debugging}" != "X0" ]
         |then
         |   echo "$scriptName: was in \\"\${wasIn}\\" " >&2
         |fi
EOF61
               my $bn;
               foreach $bn (sort keys %fileBasenames) {
                  my $vn = $bn;
                  $vn    =~ tr/a-zA-Z0-9_/_/c;
                  print SCRIPT pKit_fixIndentStuff(<<"EOF62");
         |cd "\${PREFIX}"
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: copying \\"$bn\\" " >&2
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      nowIn="\`pwd\`"
         |      echo "$scriptName: ...in \\"\${nowIn}\\" " >&2
         |      echo "$scriptName:    run [cp -p \"\${wasIn}/$bn\" . ]" >&2
         |   fi
         |   cp -p "\${wasIn}/$bn" . 2>/dev/null
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: error: can't place \\"$bn\\" " >&2
         |      echo "$scriptName: ...[cp -p \"\${wasIn}/$bn\" . ] returned exit code \${status}" >&2
         |      exit 1
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      echo "$scriptName:    done" >&2
         |      if [ -f "\${PREFIX}/$bn" ]
         |      then
         |         echo "$scriptName: ...found file \\"\${PREFIX}/$bn\\" " >&2
         |      else
         |         echo "$scriptName: ...can't find file \\"\${PREFIX}/$bn\\" " >&2
         |      fi
         |   fi
         |cd "\${wasIn}"
EOF62
               }
            }
            if ($postInstallBasename ne "") {
               print SCRIPT pKit_fixIndentStuff(<<"EOF63");
            |
            |#-------------------------------------------------------------------------------
            |#
            |#  Run the post-install script...
            |#
            |#  Note that this is done from the temporary wrapper directory and that the
            |#  prefix directories are passed as options on the command line (so that the
            |#  script knows where to find things.
            |#
            |#-------------------------------------------------------------------------------
            |
            |if [ -f "$postInstallBasename" ]
            |then
            |   amIn=\`pwd\`
            |   if [ 1 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: running post-install script \\"$postInstallBasename\\" " >&2
            |   fi
EOF63
            my $theCmd = "\"./$postInstallBasename\"\${Vflag}";
            {
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  my $vn  = $bn;
                  $vn     =~ tr/a-zA-Z0-9_/_/c;
                  $theCmd = $theCmd." --prefix-$bn=\"\${PREFIX_$vn}\"";
               }
            }
            if ($postInstallStyle ne "binary") {
               $theCmd = $postInstallStyle." ".$theCmd;
            }
            print SCRIPT pKit_fixIndentStuff(<<"EOF64");
            |   if [ "X\${debugging}" != "X0" ]
            |   then
            |      echo "$scriptName: ...from \\"\${amIn}\\" " >&2
            |      echo "$scriptName:    run [$theCmd]" >&2
            |   fi
            |   $theCmd >&2
            |   status=\$?
            |   if [ "X\${status}" != "X0" ]
            |   then
            |      if [ "X\${debugging}" != "X0" ]
            |      then
            |         echo "$scriptName:    ...failed, exit code \${status}" >&2
            |      fi
            |      echo "$scriptName: error: post-install script(=\\"$postInstallBasename\\") failed" >&2
            |      echo "$scriptName: ...[$theCmd] returned exit code \${status}" >&2
            |      exit 1
            |   else
            |      if [ "X\${debugging}" != "X0" ]
            |      then
            |         echo "$scriptName:    ...succeeded" >&2
            |      fi
            |   fi
            |   if [ 2 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: ...done" >&2
            |   fi
            |else
            |   echo "$scriptName: error: didn't find post-install script \\"$postInstallBasename\\" " >&2
            |   exit 1
            |fi
EOF64
            }
            print SCRIPT pKit_fixIndentStuff(<<"EOF65");
         |
         |#if [ 1 -le \${verbosityLevel} ]
         |#then
         |#   echo "$scriptName:" >&2
         |#fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Make some suggestions...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   makeBinSuggestion=false
         |   makeBothSuggestion=false
         |   makeLib64Suggestion=false
         |   makeLibSuggestion=false
         |   makeSuggestion=false
         |   if [ "X\${PREFIX_bin}" != X ]
         |   then
         |      makeSuggestion=true
         |      makeBinSuggestion=true
         |   fi
         |   if [ "X\${PREFIX_lib}" != X ]
         |   then
         |      makeSuggestion=true
         |      makeLibSuggestion=true
         |      if [ "X\${PREFIX_bin}" != X ]
         |      then
         |         makeBothSuggestion=true
         |      fi
         |   fi
         |   if [ "X\${PREFIX_lib64}" != X ]
         |   then
         |      makeSuggestion=true
         |      makeLib64Suggestion=true
         |      if [ "X\${PREFIX_bin}" != X ]
         |      then
         |         makeBothSuggestion=true
         |      fi
         |   fi
         |   if [ "X\${makeSuggestion}" != X0 ]
         |   then
         |      echo "$scriptName:" >&2
         |      if [ "X\${makeBothSuggestion}" != X0 ]
         |      then
         |         echo "$scriptName: suggest setting LD_LIBRARY_PATH and/or PATH using the prefix pathname" >&2
         |      else
         |         if [ "X\${makeBinSuggestion}" != X0 ]
         |         then
         |            echo "$scriptName: suggest setting PATH using the prefix pathname" >&2
         |         fi
         |         if [ "X\${makeLibSuggestion}" != X0 ]
         |         then
         |            echo "$scriptName: suggest setting LD_LIBRARY_PATH using the prefix pathname" >&2
         |         else
         |            if [ "X\${makeLib64Suggestion}" != X0 ]
         |            then
         |               echo "$scriptName: suggest setting LD_LIBRARY_PATH using the prefix pathname" >&2
         |            fi
         |         fi
         |      fi
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    when using sh or bash:" >&2
         |      echo "$scriptName:" >&2
         |      if [ "X\${makeLibSuggestion}" != X0 ]
         |      then
         |         echo "$scriptName:       LD_LIBRARY_PATH=\"\\\${LD_LIBRARY_PATH}:\${PREFIX_lib}/\${LibDirBasename}\" ; export LD_LIBRARY_PATH" >&2
         |      else
         |         if [ "X\${makeLib64Suggestion}" != X0 ]
         |         then
         |            echo "$scriptName:       LD_LIBRARY_PATH=\"\\\${LD_LIBRARY_PATH}:\${PREFIX_lib64}/\${LibDirBasename}\" ; export LD_LIBRARY_PATH" >&2
         |         fi
         |      fi
         |      if [ "X\${makeBinSuggestion}" != X0 ]
         |      then
         |         echo "$scriptName:       PATH=\"\\\${PATH}:\${PREFIX_bin}/bin\" ; export PATH" >&2
         |      fi
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    when using csh or tcsh:" >&2
         |      echo "$scriptName:" >&2
         |      if [ "X\${makeLibSuggestion}" != X0 ]
         |      then
         |         echo "$scriptName:       setenv LD_LIBRARY_PATH \"\\\${LD_LIBRARY_PATH}:\${PREFIX_lib}/\${LibDirBasename}\" " >&2
         |      else
         |         if [ "X\${makeLib64Suggestion}" != X0 ]
         |         then
         |            echo "$scriptName:       setenv LD_LIBRARY_PATH \"\\\${LD_LIBRARY_PATH}:\${PREFIX_lib64}/\${LibDirBasename}\" " >&2
         |         fi
         |      fi
         |      if [ "X\${makeBinSuggestion}" != X0 ]
         |      then
         |         echo "$scriptName:       setenv PATH \"\\\${PATH}:\${PREFIX_bin}/bin\" " >&2
         |         echo "$scriptName:       rehash" >&2
         |      fi
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    You can use echo to quickly determine which shell is in use:" >&2
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:       bigtop: echo \\\$0" >&2
         |      echo "$scriptName:       csh" >&2
         |      echo "$scriptName:       bigtop:" >&2
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    The above echo command should produce one of: bash, csh, sh" >&2
         |      echo "$scriptName:    or tcsh. On some systems it may be shown with a leading dash." >&2
         |      echo "$scriptName:" >&2
         |   fi
         |fi
EOF65
         }
         print SCRIPT pKit_fixIndentStuff(<<"EOF66");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Cleanup...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: back to \"\${here}\" " >&2
         |fi
         |cd "\${here}"
         |
         |exitCode=0
         |if [ "X\${keep}" != "Xtrue" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: cleanup" >&2
         |   fi
         |   if [ "X\${debugging}" != "X0" ]
         |   then
         |      nowIn="`pwd`"
         |      echo "$scriptName: ...in \\"\${nowIn}\\" " >&2
         |      echo "$scriptName: ...run [rm -r \\"\${MyTmpDir}\\"]" >&2
         |   fi
         |   rm -r "\${MyTmpDir}" >/dev/null 2>&1
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: error: can't cleanup the temporary directory(=\\"\${MyTmpDir}\\")" >&2
         |      echo "$scriptName: ...from \"`pwd`\" " >&2
         |      echo "$scriptName: ...[rm -r \\"\${MyTmpDir}\\"] returned exit code \${status}" >&2
         |      exitCode=1
         |   else
         |      if [ -d "\${MyTmpDir}" ]
         |      then
         |         echo "$scriptName: error: didn't cleanup the temporary directory(=\\"\${MyTmpDir}\\")" >&2
         |         echo "$scriptName: ...from \"`pwd`\" " >&2
         |         echo "$scriptName: ...[rm -r \\"\${MyTmpDir}\\"] failed" >&2
         |         echo "$scriptName:    directory \\"\${MyTmpDir}\\" is still there" >&2
         |         exitCode=1
         |      else
         |         exitCode=0
         |      fi
         |   fi
         |else
         |   echo "$scriptName: note that the temporary directory(=\\"\${MyTmpDir}\\") has been left intact" >&2
         |   exitCode=0
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  All done.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: all done" >&2
         |fi
         |
         |exit \${exitCode}
         |
EOF66
         if ($withPayload) {
            print SCRIPT pKit_fixIndentStuff(<<"EOF67");
         |__PAYLOAD_BELOW__
EOF67
         }

         close(SCRIPT);

         my $Tend = time();
         my $dT   = $Tend - $Tstart;
         if (0 <= $dT) {
            if ($dT == 0) {
               print STDERR "mkinstaller:    done (in <1 second)\n" if (2 <= $verbosityLevel);
            }
            elsif ($dT == 1) {
               print STDERR "mkinstaller:    done (in $dT second)\n" if (2 <= $verbosityLevel);
            }
            else {
               print STDERR "mkinstaller:    done (in $dT seconds)\n" if (2 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
         }

         #-------------------------------------------------------------------------
         #
         #  Done generating the "script" part of the script, now append the wrapper
         #  tarball (the payload) to the end to form the self-extracting script.
         #
         #  At this point the script has assumed its proper name.
         #
         #-------------------------------------------------------------------------

         {
            my $Tstart = time();
            my $cmd;
            my $status;
            if ($withPayload) {
               if ($debugging) {
                  print DBGOUT "mkinstaller: ...the script fragment and tarball\n" if $debugging;
                  system "pwd";
                  system "/bin/ls -aldF \"$TmpFile\"";
                  system "/bin/ls -aldF \"$TmpDirT/wrapper.tar\"";
                  system "pwd";
               }
               print STDERR "mkinstaller: ...adding the payload (\"$TmpDirT/wrapper.tar\") to \"$scriptName\" script\n" if (1 <= $verbosityLevel);
               $cmd = "cat \"$TmpFile\" \"$TmpDirT/wrapper.tar\" > \"$scriptName\"";
            }
            else {
               if ($debugging) {
                  print DBGOUT "mkinstaller: ...the script fragment (no tarball)\n" if $debugging;
                  system "pwd";
                  system "/bin/ls -aldF \"$TmpFile\"";
                  system "/bin/ls -aldF \"$TmpDirT/wrapper.tar\"";
                  system "pwd";
               }
               print STDERR "mkinstaller: ...without payload!\n" if (1 <= $verbosityLevel);
               $cmd = "cat \"$TmpFile\" > \"$scriptName\"";
            }
            print DBGOUT "mkinstaller:    run [$cmd]\n" if $debugging;
            $status = system "( $cmd )";
            if ($status != 0) {
               print DBGOUT "mkinstaller:    ...failed\n" if $debugging;
               print STDERR "mkinstaller: error: can't form \"$scriptName\"\n";
               print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            print DBGOUT "mkinstaller:    ...done\n" if $debugging;
            if ( ! -f $scriptName) {
               print DBGOUT "mkinstaller:       but didn't generate \"$scriptName\"\n" if $debugging;
               print STDERR "mkinstaller: error: didn't form \"$scriptName\"\n";
               print STDERR "mkinstaller: ...[$cmd] failed\n";
               print STDERR "mkinstaller: ...can't find \"$scriptName\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            else {
               print DBGOUT "mkinstaller:       generated \"$scriptName\"\n" if $debugging;
            }
            if ($debugging) {
               print DBGOUT "mkinstaller: ...the generated script\n" if $debugging;
               system "pwd";
               system "/bin/ls -aldF \"$scriptName\"";
               system "pwd";
            }

            my $Tend = time();
            my $dT   = $Tend - $Tstart;
            print DBGOUT "mkinstaller:       ...in $dT seconds\n" if $debugging;
            if (0 <= $dT) {
               if ($dT == 0) {
                  print STDERR "mkinstaller:    done (in <1 second)\n" if (2 <= $verbosityLevel);
               }
               elsif ($dT == 1) {
                  print STDERR "mkinstaller:    done (in $dT second)\n" if (2 <= $verbosityLevel);
               }
               else {
                  print STDERR "mkinstaller:    done (in $dT seconds)\n" if (2 <= $verbosityLevel);
               }
            }
            else {
               print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
            }
            {
               print DBGOUT "mkinstaller: ...mark \"$scriptName\" as executable\n" if $debugging;
               my $Tstart = time();
               print STDERR "mkinstaller: ...mark \"$scriptName\" as executable\n" if (1 <= $verbosityLevel);
               $cmd    = "chmod +x \"$scriptName\"";
               print DBGOUT "mkinstaller:    run [$cmd]\n" if $debugging;
               $status = system "( $cmd ) >/dev/null 2>&1";
               if ($status != 0) {
                  print DBGOUT "mkinstaller:    ...failed\n" if $debugging;
                  print STDERR "mkinstaller: error: can't make \"$scriptName\" executable\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  close DBGOUT if $dbgOutToPathname ne "";
                  exit 1;
               }
               else {
                  print DBGOUT "mkinstaller:    ...done\n" if $debugging;
               }
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               print DBGOUT "mkinstaller:       in $dT seconds\n" if $debugging;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller:    done (in <1 second)\n" if (2 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller:    done (in $dT second)\n" if (2 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller:    done (in $dT seconds)\n" if (2 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
               }
            }

            #----------------------------------------------------------------------
            #
            #  The script now has the proper name, contains the payload,
            #  and has been given the proper permissions.
            #
            #  Time to generate a hash...
            #
            #----------------------------------------------------------------------

            if ($genSHA) {
               if ($use_hasher ne "") {
                  print DBGOUT "mkinstaller: ...generate a SHA-".$genSHA." hash\n" if $debugging;
                  my $how    = "";
                  my $Tstart = time();
                  print STDERR "mkinstaller: ...generate a SHA-".$genSHA." hash\n" if (1 <= $verbosityLevel);
                  my $hashFileName = $scriptName.".sha-".$genSHA;
                  print STDERR "mkinstaller:    as \"$hashFileName\"\n" if (2 <= $verbosityLevel);
                  my $cmd = pKit_quoteIfReqd($use_hasher).$use_hasherOpt." \"$scriptName\" >\"$hashFileName\"";
                  print DBGOUT "mkinstaller:    run [$cmd]\n" if $debugging;
                  $status = system "( $cmd ) 2>/dev/null";
                  if ($status != 0) {
                     print DBGOUT "mkinstaller:    ...failed\n" if $debugging;
                     print STDERR "mkinstaller: warning: can't create \"$hashFileName\" hash\n";
                     print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                     $how  = "failed";
                  }
                  else {
                     print DBGOUT "mkinstaller:    ...done\n" if $debugging;
                     $how  = "done";
                  }
                  my $Tend = time();
                  my $dT   = $Tend - $Tstart;
                  print DBGOUT "mkinstaller:       in $dT seconds\n" if $debugging;
                  if (0 <= $dT) {
                     if ($dT == 0) {
                        print STDERR "mkinstaller:    $how (in <1 second)\n" if (2 <= $verbosityLevel);
                     }
                     elsif ($dT == 1) {
                        print STDERR "mkinstaller:    $how (in $dT second)\n" if (2 <= $verbosityLevel);
                     }
                     else {
                        print STDERR "mkinstaller:    $how (in $dT seconds)\n" if (2 <= $verbosityLevel);
                     }
                  }
                  else {
                     print STDERR "mkinstaller:    $how\n" if (2 <= $verbosityLevel);
                  }
               }
            }
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
#}= cut here ========================================================================================================== cut here ===
   }
   elsif ($OSclass eq "Windows-like") {
#{= cut here ========================================================================================================== cut here ===

      #=========================================================================
      #
      #  This is a Windows-like host
      #
      #  The installer to be generated will actually be produced using Nullsoft's
      #  NSIS (Nullsoft Scriptable Install System) software. The mkinstaller
      #  script will generate the NSIS input script then use NSIS to generate
      #  the actual installer.
      #
      #=========================================================================

      print DBGOUT "mkinstaller: working on a \"$OSclass\" host\n" if $debugging;

      #---------------------------------------
      #
      #  Locate makensis (is required)...
      #
      #---------------------------------------

      print DBGOUT "mkinstaller: locate required \"makensis\" utility...\n" if $debugging;
      $use_makensis = pKit_lookForExecutable("makensis",\@myPATH,$OSclass);
      if ($use_makensis eq "") {
         print STDERR "mkinstaller: error: can't locate required \"makensis\" utility\n";
         if ( exists $ENV{'PATH'} ) {
            my $havePath = $ENV{'PATH'};
            if ($havePath ne "") {
               my @havePath = split /;/, $havePath; # Remember, this is a Windows-like host
               my $i;
               for ($i=0; $i<=$#havePath; ++$i) {
                  my $pathname = $havePath[$i];
                  if ($i == 0) {
                     print STDERR "mkinstaller: ...PATH is: \"$pathname\"\n";
                  }
                  else {
                     print STDERR "mkinstaller:             \"$pathname\"\n";
                  }
               }
            }
            else {
               print STDERR "mkinstaller: ...PATH is empty\n";
            }
         }
         else {
            print STDERR "mkinstaller: ...PATH isn't defined\n";
         }
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         close DBGOUT if $dbgOutToPathname ne "";
         exit 1;
      }
      print DBGOUT "mkinstaller: ...\"".pKit_nativePathname($use_makensis)."\"\n" if $debugging;
      print STDERR "mkinstaller: ...using \"".pKit_nativePathname($use_makensis)."\"\n" if (1 <= $verbosityLevel);

      #---------------------------------------
      #
      #  Check the directories...
      #
      #---------------------------------------

      {
         print DBGOUT "mkinstaller: check the directories to be installed...\n" if $debugging;
         my $failed     = 0;
         my $hasEmpties = 0;
         my $bn;
         foreach $bn (sort keys %dirBasenames) {
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               print DBGOUT "mkinstaller: ...\"".pKit_nativePathname($pathname)."\"\n" if $debugging;
               if ( -d $pathname) {
                  print DBGOUT "mkinstaller:    scan \"".pKit_nativePathname($pathname)."\" for directories\n" if $debugging;
                  my @subDirs = pKit_findAllSubdirs($pathname,"mkinstaller");
                  if ($subDirs[0] != 0) {
                     print DBGOUT "mkinstaller:    ...succeeded\n" if $debugging;
                     my $j;
                     for ($j=1; $j<=$#subDirs; $j+=1) {
                        my $X_name            = $subDirs[$j]{"name"};
                        my $X_type            = $subDirs[$j]{"type"};
                        my $X_NbrokenSymLinks = $subDirs[$j]{"NbrokenSymLinks"};
                        my $X_Ndirectories    = $subDirs[$j]{"Ndirectories"};
                        my $X_Nfiles          = $subDirs[$j]{"Nfiles"};
                        my $X_Nothers         = $subDirs[$j]{"Nothers"};
                        my $X_NsymbolicLinks  = $subDirs[$j]{"NsymbolicLinks"};
                        my $X_ok              = $subDirs[$j]{"ok"};
                        print DBGOUT "mkinstaller:       \"".pKit_nativePathname($X_name)."\"\n" if $debugging;
                        if ($X_type eq "directory") {
                           my $isEmpty;
                           if (0 < $X_Nfiles) {
                              $isEmpty = 0;
                           }
                           else {
                              $isEmpty = 1;
                           }
                           if ($isEmpty) {
                              print DBGOUT "mkinstaller:       ...empty\n" if $debugging;
                              if (($fillMode != 0) && ($fillMode != 1)) {
                                 $fillMode = 0;
                              }
                              if ($fillMode) {
                                 print STDERR "mkinstaller: note: \"".pKit_nativePathname($X_name)."\" is an empty directory\n";
                                 my $dummyFile = pKit_joinpath($X_name,"dummy.txt");
                                 print DBGOUT "mkinstaller:          create \"".pKit_nativePathname($dummyFile)."\"\n" if $debugging;
                                 print STDERR "mkinstaller: ...creating \"".pKit_nativePathname($dummyFile)."\"\n";
                                 if (open(DUMMY,"> $dummyFile")) {
                                    print DUMMY "This dummy file was created by mkinstaller\n";
                                    close DUMMY;
                                 }
                                 else {
                                    print DBGOUT "mkinstaller:          ...failed\n" if $debugging;
                                    print STDERR "mkinstaller: error: can't create \"".pKit_nativePathname($dummyFile)."\"\n";
                                    $failed = 1;
                                 }
                              }
                              else {
                                 print STDERR "mkinstaller: warning: \"".pKit_nativePathname($X_name)."\" is an empty directory\n";
                                 $hasEmpties = 1;
                              }
                           }
                           else {
                              print DBGOUT "mkinstaller:       ...done\n" if $debugging;
                           }
                        }
                        else {
                           print STDERR "mkinstaller: bug -- \"".pKit_nativePathname($X_name)."\" isn't a directory\n";
                           $failed = 1;
                        }
                     }
                  }
                  else {
                     print DBGOUT "mkinstaller:    ...failed\n" if $debugging;
                     $failed = 1;
                  }
               }
               else {
                  print DBGOUT "mkinstaller:    not a directory\n" if $debugging;
                  print STDERR "mkinstaller: error: \"".pKit_nativePathname($pathname)."\" is not a directory\n";
                  $failed = 1;
               }
            }
         }
         print DBGOUT "mkinstaller: ...done\n" if $debugging;
         if ($hasEmpties) {
            print STDERR "mkinstaller: error: there are empty directories\n";
            $failed = 1;
         }
         if ($failed) {
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
      }

      #---------------------------------------
      #
      #  Off to work...
      #
      #---------------------------------------

      my $NSISscriptName    = "$here/$scriptName.nsi";
      my $NSISscriptExeName = "$here/$scriptName.exe";
      my $removedOld         = 0;

      #---------------------------------------
      #
      #  Destroy existing NSIS script (if any)...
      #
      #---------------------------------------

      print DBGOUT "mkinstaller: cleanup existing NSIS script...\n" if $debugging;
      {
         print STDERR "mkinstaller: ...initial cleanup\n" if (1 <= $verbosityLevel);
         if ( -l $NSISscriptName) {
            if ( -e $NSISscriptName) {
               print STDERR "mkinstaller: error: \"".pKit_nativePathname($NSISscriptName)."\" is a symbolic-link not a file\n";
            }
            else {
               print STDERR "mkinstaller: error: \"".pKit_nativePathname($NSISscriptName)."\" is a broken symbolic-link not a file\n";
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         elsif ( -f $NSISscriptName) {
            print STDERR "mkinstaller:    destroy existing \"".pKit_nativePathname($NSISscriptName)."\" script\n" if (1 <= $verbosityLevel);
            my $Ndeleted = unlink "$NSISscriptName";
            if ($Ndeleted < 1) {
               print STDERR "mkinstaller: error: can't destroy existing \"".pKit_nativePathname($NSISscriptName)."\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ( -f $NSISscriptName) {
               print STDERR "mkinstaller: error: didn't destroy existing \"".pKit_nativePathname($NSISscriptName)."\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            print STDERR "mkinstaller:    ...done\n" if (2 <= $verbosityLevel);
            $removedOld = 1;
         }
         elsif ( -e $NSISscriptName) {
            print STDERR "mkinstaller: error: existing \"".pKit_nativePathname($NSISscriptName)."\" is not a file\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         if ( -l $NSISscriptExeName) {
            if ( -e $NSISscriptExeName) {
               print STDERR "mkinstaller: error: \"".pKit_nativePathname($NSISscriptExeName)."\" is a symbolic-link not a file\n";
            }
            else {
               print STDERR "mkinstaller: error: \"".pKit_nativePathname($NSISscriptExeName)."\" is a broken symbolic-link not a file\n";
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         elsif ( -f $NSISscriptExeName) {
            print STDERR "mkinstaller:    destroy existing \"".pKit_nativePathname($NSISscriptExeName)."\" script\n" if (1 <= $verbosityLevel);
            my $Ndeleted = unlink "$NSISscriptExeName";
            if ($Ndeleted < 1) {
               print STDERR "mkinstaller: error: can't destroy existing \"".pKit_nativePathname($NSISscriptExeName)."\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            if ( -f $NSISscriptExeName) {
               print STDERR "mkinstaller: error: didn't destroy existing \"".pKit_nativePathname($NSISscriptExeName)."\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
            print STDERR "mkinstaller:    ...done\n" if (2 <= $verbosityLevel);
            $removedOld = 1;
         }
         elsif ( -e $NSISscriptExeName) {
            print STDERR "mkinstaller: error: existing \"".pKit_nativePathname($NSISscriptExeName)."\" is not a file\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;

      #---------------------------------------
      #
      #  Generate NSIS script...
      #
      #---------------------------------------

      print DBGOUT "mkinstaller: create NSIS script...\n" if $debugging;
      {
         my $UninstallerName = "uninstaller.exe";
         if (1 <= $verbosityLevel) {
            if ($removedOld) {
               print STDERR "mkinstaller: ...create new NSIS script\n";
            }
            else {
               print STDERR "mkinstaller: ...create NSIS script\n";
            }
            print STDERR "mkinstaller:    \"".pKit_nativePathname($NSISscriptName)."\"\n" if (2 <= $verbosityLevel);
         }
         if ( ! open(OSCRIPT,"> $NSISscriptName")) {
            print STDERR "mkinstaller: error: can't create/write \"".pKit_nativePathname($NSISscriptName)."\"\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         print OSCRIPT "#-------------------------------------------------------------------------------\n";
         print OSCRIPT "#\n";
         print OSCRIPT "#  ".pKit_nativePathname($NSISscriptName)."\n";
         print OSCRIPT "#\n";
         print OSCRIPT "#  This NSIS input script was generated by mkinstaller ver. $mkinstaller_ver_name\n";
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
         print OSCRIPT "#  for $ProjectName ver. $ProjectVer\n";
            }
            else {
         print OSCRIPT "#  for $ProjectName.\n";
            }
         }
         print OSCRIPT "#\n";
         print OSCRIPT "#  The following command line was used:\n";
         print OSCRIPT "#\n";
         print OSCRIPT "#     ".$theCommandLine."\n";
         print OSCRIPT "#\n";
         print OSCRIPT "#-------------------------------------------------------------------------------\n";
         print OSCRIPT "\n";
         print OSCRIPT "Name                  \"".$scriptName."\"\n";
         print OSCRIPT "OutFile               \"".$scriptName.".exe\"\n";
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
         print OSCRIPT "InstallDir            \$DESKTOP\\$ProjectName-$ProjectVer\n";
         print OSCRIPT "DirText               \"The ".$ProjectName." ".$ProjectVer." installer. Choose an installation prefix directory\"\n";
            }
            else {
         print OSCRIPT "InstallDir            \$DESKTOP\\$ProjectName\n";
         print OSCRIPT "DirText               \"The ".$ProjectName." installer. Choose an installation prefix directory\"\n";
            }
         }
         else {
         print OSCRIPT "InstallDir            \$DESKTOP\\$scriptName\n";
         print OSCRIPT "DirText               \"Choose an installation prefix directory\"\n";
         }
         print OSCRIPT "RequestExecutionLevel user\n";
         print OSCRIPT "SetCompressor         /SOLID /FINAL lzma\n";
         print OSCRIPT "\n";
         print OSCRIPT "Section \"\"\n";
         print OSCRIPT "   SetOutPath         \$INSTDIR\n";
         print OSCRIPT "   WriteUninstaller   \$INSTDIR\\".$UninstallerName."\n";
         my $bn;
         foreach $bn (sort keys %dirBasenames) {
            my $vn   = $bn;
            $vn      =~ tr/a-zA-Z0-9_/_/c;
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               print STDERR "mkinstaller:    ...from \"".pKit_nativePathname($pathname)."\"\n" if (2 <= $verbosityLevel);
         print OSCRIPT "   File /nonfatal /r  \"".pKit_nativePathname($pathname)."\"\n";
            }
         }
         my $bn;
         foreach $bn (sort keys %fileBasenames) {
            my $vn       = $bn;
            $vn          =~ tr/a-zA-Z0-9_/_/c;
            my $pathname = $fileBasenames{$bn};
         print OSCRIPT "   File               \"".pKit_nativePathname($pathname)."\"\n";
         }
         print OSCRIPT "SectionEnd\n";
         print OSCRIPT "\n";
         print OSCRIPT "Section \"Uninstall\"\n";
         print OSCRIPT "   Delete           \$INSTDIR\\".$UninstallerName."\n";
         my $bn;
         foreach $bn (sort keys %dirBasenames) {
         print OSCRIPT "   RMDir /r         \$INSTDIR\\$bn\n";
         }
         print OSCRIPT "   RMDir            \$INSTDIR\n";
         print OSCRIPT "SectionEnd\n";
         print OSCRIPT "\n";
         close OSCRIPT;
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
         if ($debugging) {
            if (open(ISCRIPT,"< $NSISscriptName")) {
               print DBGOUT "mkinstaller{ ...gives:\n";
               while (<ISCRIPT>) {
                  chomp; s/\r$//;
                  my $got = $_;
                  print DBGOUT "mkinstaller|".$got."\n";
               }
               print DBGOUT "mkinstaller} ...done\n";
               close ISCRIPT;
            }
            else {
               print STDERR "mkinstaller: ...can't find/read \"".pKit_nativePathname($NSISscriptName)."\"\n";
               close DBGOUT if $dbgOutToPathname ne "";
               exit 1;
            }
         }
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
      print DBGOUT "mkinstaller: compile NSIS script...\n" if $debugging;
      {
         print STDERR "mkinstaller: ...\"compiling\" \"".pKit_nativePathname($NSISscriptName)."\"\n" if (1 <= $verbosityLevel);
         print STDERR "mkinstaller:    using \"".pKit_nativePathname($use_makensis)."\"\n" if (2 <= $verbosityLevel);
         my $cmd    = "\"".pKit_nativePathname($use_makensis)."\" \"".pKit_nativePathname($NSISscriptName)."\"";
         print DBGOUT "mkinstaller: ...run [$cmd]\n" if $debugging;
         my $status = system "( $cmd ) >$devNull 2>&1";
         print DBGOUT "mkinstaller:    gives exit code $status\n" if $debugging;
         if ($status != 0) {
            print DBGOUT "mkinstaller:    ...failed, exit code $status\n" if $debugging;
            print STDERR "mkinstaller: error: can't compile \"".pKit_nativePathname($NSISscriptName).\" executable\n";
            print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            close DBGOUT if $dbgOutToPathname ne "";
            exit 1;
         }
         else {
            print DBGOUT "mkinstaller:    ...succeeded\n" if $debugging;
            my $ok = 0;
            if ( -l $NSISscriptExeName) {
               if ( -e $NSISscriptExeName) {
                  print DBGOUT "mkinstaller:    found symbolic-link \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if $debugging;
                  my $target = readlink($NSISscriptExeName);
                  my $dn     = pKit_dirname($NSISscriptExeName);
                  $target    = pKit_joinpath($dn,$target);
                  if ( -f $target) {
                     print DBGOUT "mkinstaller:    ...to file \"".pKit_nativePathname($target)."\"\n" if $debugging;
                     print STDERR "mkinstaller:    generated \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if (1 <= $verbosityLevel);
                     $ok = 1;
                  }
                  elsif ( -d $target) {
                     print DBGOUT "mkinstaller:    ...to file \"".pKit_nativePathname($target)."\"\n" if $debugging;
                  }
                  else {
                     print DBGOUT "mkinstaller:    ...to \"".pKit_nativePathname($target)."\"\n" if $debugging;
                     print DBGOUT "mkinstaller:       which is not a directory, file, or symbolic-link\n" if $debugging;
                  }
               }
               else {
                  print DBGOUT "mkinstaller:    found broken symbolic-link \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if $debugging;
               }
            }
            elsif ( -f $NSISscriptExeName) {
               print DBGOUT "mkinstaller:    found file \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if $debugging;
               print STDERR "mkinstaller:    generated \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if (1 <= $verbosityLevel);
               $ok = 1;
            }
            elsif ( -d $NSISscriptExeName) {
               print DBGOUT "mkinstaller:    found directory \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if $debugging;
            }
            elsif ( -e $NSISscriptExeName) {
               print DBGOUT "mkinstaller:    found \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if $debugging;
               print DBGOUT "mkinstaller:    ...but not a directory, file, or symbolic-link\"\n" if $debugging;
            }
            else {
               print DBGOUT "mkinstaller:    can't find \"".pKit_nativePathname($NSISscriptExeName)."\"\n" if $debugging;
            }
         }
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
      }
      print DBGOUT "mkinstaller: ...done\n" if $debugging;
#}= cut here ========================================================================================================== cut here ===
   }
   else {
      print STDERR "mkinstaller: error: can't identify the class of host\n";
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
      close DBGOUT if $dbgOutToPathname ne "";
      exit 1;
   }

   #---------------------------------------
   #
   #  Cleanup
   #
   #---------------------------------------

   print DBGOUT "mkinstaller: cleanup...\n" if $debugging;
   {
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
   }
   print DBGOUT "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  All done
   #
   #----------------------------------------------------------------------------

   my $TendOverall = time();
   my $dToverall   = $TendOverall - $TstartOverall;
   if (0 <= $dToverall) {
      if ($dToverall == 0) {
         print STDERR "mkinstaller: all done (in <1 second)\n" if (1 <= $verbosityLevel);
      }
      elsif ($dToverall == 1) {
         print STDERR "mkinstaller: all done (in $dToverall second)\n" if (1 <= $verbosityLevel);
      }
      else {
         print STDERR "mkinstaller: all done (in $dToverall seconds)\n" if (1 <= $verbosityLevel);
      }
   }
   else {
      print STDERR "mkinstaller: all done\n" if (1 <= $verbosityLevel);
   }
   close DBGOUT if $dbgOutToPathname ne "";
   exit 0;

##============================================================================##
##============================================================================##
##                                                                            ##
##  Local functions...                                                        ##
##                                                                            ##
##============================================================================##
##============================================================================##

   #----------------------------------------------------------------------------
   #
   #  Cleanup any and all temporaries.
   #
   #  Note that it will issue warnings if content isn't all being deleted.
   #
   #----------------------------------------------------------------------------

   sub cleanupTemps {
      my $myTmpDirT      = shift;
      my $keep           = shift;
      my $verbosityLevel = shift;
      my $debugging      = shift;

      print DBGOUT "mkinstaller.cleanupTemps[ myTmpDirT=\"$myTmpDirT\", keep=$keep, verbosityLevel=$verbosityLevel...\n" if $debugging;
      if ($myTmpDirT ne "") {
         if ( ! $keep) {
            print DBGOUT "mkinstaller.cleanupTemps: ...not keeping\n" if $debugging;
            print STDERR "mkinstaller: ...cleanup\n" if (1 <= $verbosityLevel);
            if ( -d "$myTmpDirT") {
               my $first = 1;
               my $count = 8;
               while ( -d "$myTmpDirT") {
                  print DBGOUT "mkinstaller.cleanupTemps:    have \"$myTmpDirT\" directory\n" if $debugging;
                  $count -= 1;
                  if (count < 0) {
                     print DBGOUT "mkinstaller.cleanupTemps:    ...but giving-up\n" if $debugging;
                     last;
                  }
                  else {
                     if ($first) {
                        $first = 0;
                        print STDERR "mkinstaller:    \"".pKit_nativePathname($myTmpDirT)."\"\n" if (1 <= $verbosityLevel);
                     }
                     my @remainder  = pKit_shouldDeletePathname($myTmpDirT);
                     my $Nremainder = $#remainder + 1;
                     if (1 <= $Nremainder) {
                        my $i;
                        for ($i=0; $i<$Nremainder; $i+=1) {
                           my $pathname = $remainder[$i];
                           if ($i == 0) {
                              print STDERR "mkinstaller: ...couldn't delete \"".pKit_nativePathname($pathname)."\"\n";
                           }
                           else {
                              print STDERR "mkinstaller:                 or \"".pKit_nativePathname($pathname)."\"\n";
                           }
                        }
                     }
                  }
               }
            }
            else {
               print DBGOUT "mkinstaller.cleanupTemps:    don't have \"$myTmpDirT\" directory\n" if $debugging;
            }
            print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
         }
         else {
            print DBGOUT "mkinstaller:    keeping \"$myTmpDirT\"\n" if $debugging;
            if ( -d $myTmpDirT) {
               print STDERR "mkinstaller: note: $keepOpt was used, not deleting \"$myTmpDirT\"\n";
            }
            else {
               print STDERR "mkinstaller: note: $keepOpt was used, but can't find \"$myTmpDirT\"\n";
            }
         }
      }
      else {
         print DBGOUT "mkinstaller: ...nothing to cleanup\n" if $debugging;
      }
      print DBGOUT "mkinstaller.cleanupTemps] ...done\n" if $debugging;
   }

   #----------------------------------------------------------------------------
   #
   #  Output the copyright notice to stdout.
   #
   #----------------------------------------------------------------------------

   sub copyright {
      my $Nowners    = $#defaultCopyrightOwners + 1;
      my $Nstatement = $#defaultCopyrightStatement + 1;
      my $didOne     = 0;
      my $i;
      if (0 < $Nowners) {
         print STDOUT "\n";
         for ($i=0; $i<$Nowners; $i+=1) {
            print STDOUT $defaultCopyrightOwners[$i];
         }
         $didOne = 1;
      }
      if (0 < $Nstatement) {
         print STDOUT "\n";
         for ($i=0; $i<$Nstatement; $i+=1) {
            print STDOUT $defaultCopyrightStatement[$i];
         }
         $didOne = 1;
      }
      if ($didOne) {
         print STDOUT "\n";
      }
   }

#{= cut here ========================================================================================================== cut here ===
   #----------------------------------------------------------------------------
   #
   #  This function is used to figure-out the version number of the given
   #  compiler or linker. This code is quite complex and was derived from
   #  the code used in an autokonf generated configure script. This is only
   #  done on Linux hosts. Note that this function was derived from the code
   #  used in an autokonf generated cobfigure script. Changes made to this
   #  function should be propagated to autokonf.
   #
   #  See: totebag/src/autokonf/autokonf.pmain
   #
   #  Dated: 11Apr2019
   #
   #  NOTE: This really should be replaced with the more up-to-date function
   #        in pKit/checkForCompilerVersion.psub
   #
   #----------------------------------------------------------------------------

   sub mki_checkForCompilerVersion {
      my $pathname    = shift;
      my $treatAs     = shift;
      print DBGOUT "mki_checkForCompilerVersion[ pathname=\"$pathname\", treatAs=\"$treatAs\"...\n" if $debugging;
      my $result      = "";

      my $theBasename;
      if ($treatAs eq "") {
         $theBasename = pKit_basename($pathname);
      }
      else {
         $theBasename = $treatAs;
      }
      print DBGOUT "mki_checkForCompilerVersion: ...compiler name is \"$theBasename\"\n" if $debugging;
      $_              = $theBasename;
      identify: {
                  #---------------------------------------
                  #
                  #  HP C++ compiler naming...
                  #
                  #---------------------------------------

                  /^aCC$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...HP C++ compiler name\n" if $debugging;
                        print DBGOUT "mki_checkForCompilerVersion:    on an HP, probably native\n" if $debugging;
                        my $cmd      = "$pathname -V 2>&1";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*aCC:\s+HP\s+ANSI\s+C\+\+\s+\S+\s+[AB]\.([0-9]+\.[0-9]+\S*)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Microsoft compiler naming...
                  #
                  #---------------------------------------

                  /^cl(.exe)?$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...Microsoft C/C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ( $OSclass eq "Windows-like") {
                           print DBGOUT "mki_checkForCompilerVersion:    on Windows, probably native\n" if $debugging;
                           my $Wpathname = pKit_makePathNative($pathname);
                           my $cmd       = "\"$Wpathname\" 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response  = `$cmd`;
                           my $status    = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response     =~ tr!\n! !;
                           $response     =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*Microsoft\s+.*\s+Optimizing Compiler Version ([0-9]+\.[0-9]+\S*)/) {
                              $result    = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Clang C/C++ compiler...
                  #
                  #     Note that clang and clang++ are
                  #     sometimes given funny names.
                  #
                  #---------------------------------------

                  /^(bg)?clang$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...clang C compiler name on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*\bclang\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^.*\bLLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*Apple\s+LLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)\s+.*\s+\(based on LLVM\s+([0-9]+\.[0-9]+).*\)/) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^(bg)?clang\+\+$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...clang C++ compiler name on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*\bclang\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^.*\bbgclang\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^.*\bLLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*Apple\s+LLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)\s+.*\s+\(based on LLVM\s+([0-9]+\.[0-9]+).*\)/) {
                           $result   = "$theBasename $2";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Generic compiler naming...
                  #
                  #---------------------------------------

                  /^cc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...generic C compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "darwin") {
                           print DBGOUT "mki_checkForCompilerVersion:    on a mac, possibly gcc (GNU C)\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "hpux") {
                           print DBGOUT "mki_checkForCompilerVersion:    on an HP, probably native\n" if $debugging;
                           print DBGOUT "mki_checkForCompilerVersion:    ...create trivial C source file\n" if $debugging;
                           my $baseName = "dummy".$$;
                           my $srcName  = $baseName.".c";
                           my $objName  = $baseName.".o";
                           if (open(DUMMY,"> $srcName")) {
                              print DUMMY <<EOF;
int main ( )
{
   return 0;
}

EOF
                              close DUMMY;
                              print DBGOUT "mki_checkForCompilerVersion:       done\n" if $debugging;
                              my $cmd      = "$pathname -Ae -c -V $srcName 2>&1";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              my $response = `$cmd`;
                              my $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response    =~ tr!\n! !;
                              $response    =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^.*ccom:\s+\S+\s+[AB]\.([0-9]+\.[0-9]+\S+)\s+HP\s+C\s+Compiler/) {
                                 $result   = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              }
                              print DBGOUT "mki_checkForCompilerVersion:    ...cleanup\n" if $debugging;
                              unlink($objName);
                              unlink($srcName);
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       failed\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "irix64") {
                           print DBGOUT "mki_checkForCompilerVersion: ...on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "osf") {
                           print DBGOUT "mki_checkForCompilerVersion: ...on an DEC, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*DEC\s+C\s+V([0-9]+\.\S+)\s+/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif (($OSname eq "SunOS") || ($OSname eq "solaris")) {
                           print DBGOUT "mki_checkForCompilerVersion: ...on an SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc:\s+Studio\s+([0-9]+\.[0-9]+)\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $2";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                              $cmd      = "$pathname -version 2>&1";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response =~ tr!\n! !;
                              $response =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                              }
                              elsif ($response =~ /^\s*cc:\s+Studio\s+([0-9]+\.[0-9]+)\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $2";
                                 print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion: ...not an HP, mac, SGI, or SUN\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*egcs-([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case E\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case F\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case G (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^cxx$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...generic C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "osf") {
                           print DBGOUT "mki_checkForCompilerVersion:    on a DEC, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*DIGITAL\s+C\+\+\s+V([0-9]+\.\S+)\s+/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:    not a DEC\n" if $debugging;
                        }
                        last identify;
                     };

                  /^c\+\+$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...generic C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "darwin") {
                           print DBGOUT "mki_checkForCompilerVersion:    on a mac, possibly g++ (GNU C++)\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:    not a mac\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^CC$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...generic C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "darwin") {
                           print DBGOUT "mki_checkForCompilerVersion:    on a mac, possibly g++ (GNU C++)\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*\S+\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "irix64") {
                           print DBGOUT "mki_checkForCompilerVersion:    on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif (($OSname eq "SunOS") || ($OSname eq "solaris")) {
                           print DBGOUT "mki_checkForCompilerVersion:    on a SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*CC:\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*CC:\s+Studio\s+([0-9]+\.[0-9]+)\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $2";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              $cmd      = "$pathname -V 2>&1";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response =~ tr!\n! !;
                              $response =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*CC:\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                              }
                              elsif ($response =~ /^\s*CC:\s+Studio\s+([0-9]+\.[0-9]+)\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $2";
                                 print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:    not an HP, mac, SGI, or SUN\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^f77$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...generic FORTAN 77 compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "irix64") {
                           print DBGOUT "mki_checkForCompilerVersion:    on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif (($OSname eq "SunOS") || ($OSname eq "solaris")) {
                           print DBGOUT "mki_checkForCompilerVersion:    on a SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.+\s+-f77\s+.+f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^.+\s+-f77\s+.+f90:\s+Studio\s+([0-9]+\.[0-9]+)\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $2";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                              $cmd      = "$pathname -V 2>&1";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response =~ tr!\n! !;
                              $response =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^.+\s+-f77\s+.+f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                              }
                              elsif ($response =~ /^.+\s+-f77\s+.+f90:\s+Studio\s+([0-9]+\.[0-9]+)\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $2";
                                 print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:    not an SGI or SUN\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*GNU\s+Fortran\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*GNU\s+Fortran\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^f90$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...generic FORTAN 90 compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "hpux") {
                           print DBGOUT "mki_checkForCompilerVersion:    on an HP, probably native\n" if $debugging;
                           my $cmd      = "$pathname +version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*HP\s+F90\s+v([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "irix64") {
                           print DBGOUT "mki_checkForCompilerVersion:    on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif (($OSname eq "SunOS") || ($OSname eq "solaris")) {
                           print DBGOUT "mki_checkForCompilerVersion:    on a SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response    =~ tr!\n! !;
                           $response    =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*f90:\s+Studio\s+([0-9]+\.[0-9]+)\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "$theBasename $2";
                              print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                              $cmd      = "$pathname -V 2>&1";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response    =~ tr!\n! !;
                              $response    =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                              }
                              elsif ($response =~ /^\s*f90:\s+Studio\s+([0-9]+\.[0-9]+)\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "$theBasename $2";
                                 print DBGOUT "mki_checkForCompilerVersion:       case E\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case F\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:    not an HP, SGI, or SUN\n" if $debugging;
                           print DBGOUT "mki_checkForCompilerVersion:    ...case A (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  GNU compilers...
                  #
                  #---------------------------------------

                  /^g77$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like g77 (GNU FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*GNU\s+Fortran\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*GNU\s+Fortran\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^gcc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like gcc (GNU C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*gcc\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*gcc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*egcs-([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case E\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case F (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^gfortran$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like gfortran (GNU FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*GNU\s+Fortran\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^g\+\+$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like g++ (GNU C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*g\+\+\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*egcs-([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case E\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case F (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Intel compilers...
                  #
                  #---------------------------------------

                  /^icc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like icc (Intel C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*icc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response =~ tr!\n! !;
                           $response =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^icpc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like icpc (Intel C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*icpc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response =~ tr!\n! !;
                           $response =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^ifort$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like ifort (Intel FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*ifort\s+\(IFORT\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response =~ tr!\n! !;
                           $response =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*ifort\s+version\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Microsoft linker naming...
                  #
                  #---------------------------------------

                  /^link(.exe)?$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...Microsoft C/C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ( $OSclass eq "Windows-like") {
                           print DBGOUT "mki_checkForCompilerVersion:    on Windows, probably native\n" if $debugging;
                           my $Wpathname = pKit_makePathNative($pathname);
                           my $cmd       = "\"$Wpathname\" 2>&1";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response  = `$cmd`;
                           my $status    = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response     =~ tr!\n! !;
                           $response     =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*Microsoft\s+.*\s+Incremental\s+Linker\s+Version\s+([0-9]+\.[0-9]+\S*)/) {
                              $result    = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  MPI compiler wrappers...
                  #
                  #---------------------------------------

                  /^mpicc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like mpicc (MPI C compiler) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*gcc\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*gcc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*icc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response =~ tr!\n! !;
                           $response =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case E\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case F (failed)\n" if $debugging;
                              $cmd      = "$pathname -V";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response =~ tr!\n! !;
                              $response =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*pgcc\s+([0-9]+\.\S+)/) {
                                 $result = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case G\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case H (failed)\n" if $debugging;
                              }
                           }
                        }
                        last identify;
                     };

                  /^mpiCC$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like mpiCC (MPI C++ compiler) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*g\+\+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*g\+\+\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*icpc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response =~ tr!\n! !;
                           $response =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case E\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case F\n" if $debugging;
                              $cmd      = "$pathname -V";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response =~ tr!\n! !;
                              $response =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*pgCC\s+([0-9]+\.\S+)/) {
                                 $result = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case G\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case G (failed)\n" if $debugging;
                              }
                           }
                        }
                        last identify;
                     };

                  /^mpif77$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like mpif77 (MPI FORTRAN 77 compiler) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*ifort\s+\(IFORT\)\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response; $response =~ s/\r$//;
                           $response =~ tr!\n! !;
                           $response =~ tr!\r!!d;
                           print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "$theBasename $1";
                              print DBGOUT "mki_checkForCompilerVersion:       case D\n" if $debugging;
                           }
                           else {
                              print DBGOUT "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                              $cmd      = "$pathname -V";
                              print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response; $response =~ s/\r$//;
                              $response =~ tr!\n! !;
                              $response =~ tr!\r!!d;
                              print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*pgf77\s+([0-9]+\.\S+)/) {
                                 $result = "$theBasename $1";
                                 print DBGOUT "mki_checkForCompilerVersion:       case F\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_checkForCompilerVersion:       case G (failed)\n" if $debugging;
                              }
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Portland Group compilers...
                  #
                  #---------------------------------------

                  /^pgcc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like pgcc (PGI C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgcc\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgCC$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like pgCC (PGI C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgCC\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgf77$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like pgf77 (PGI FORTRAN 77) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgf77\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgf90$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like pgf90 (PGI FORTRAN 90) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgf90\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgf95$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like pgf95 (PGI FORTRAN 95) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgf95\s+([0-9]+\.\S+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  SUN compilers...
                  #
                  #---------------------------------------

                  /^suncc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like suncc (SunPRO C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunCC$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like sunCC (SunPRO C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*CC:\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunf77$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like sunf77 (SunPRO FORTRAN 77) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*-f77.*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunf90$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like sunf90 (SunPRO FORTRAN 90) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunf95$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like sunf95 (SunPRO FORTRAN 95) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  IBM compilers...
                  #
                  #---------------------------------------

                  /^xlf$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like xlf (IBM FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+Fortran\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlf90$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like xlf90 (IBM FORTRAN 90) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+Fortran\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlf95$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like xlf95 (IBM FORTRAN 95) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+Fortran\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlc$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like xlc (IBM C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+C\/C\+\+\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlC$/

                     && do {
                        print DBGOUT "mki_checkForCompilerVersion: ...looks like xlC (IBM C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print DBGOUT "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response; $response =~ s/\r$//;
                        $response    =~ tr!\n! !;
                        $response    =~ tr!\r!!d;
                        print DBGOUT "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+C\/C\+\+\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "$theBasename $1";
                           print DBGOUT "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                }
      print DBGOUT "mki_checkForCompilerVersion] ...result is \"$result\"" if $debugging;
      if ($result ne "") {
         print DBGOUT " (success)\n" if $debugging;
      }
      else {
         print DBGOUT " (failure)\n" if $debugging;
      }
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Check for the availability of a command. If the given name is simple
   #  name (no /'s) then this macro tests if a program with the could be found
   #  in one of the directories listed in the established PATH environment
   #  variable and is marked executable. If the given name is not simple (an
   #  absolute or relative pathname) then this macro will test of the pathname
   #  is an executable. This may seem trivial and best answer directly using
   #  the -x operator provided by Perl but use of this macro also sets up the
   #  proper substitutions for later header file, makefile, and buildfile
   #  generation. Note that the name of the program must be double quoted.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_CHECK_PROG macro/test supplied with autokonf. Changes made
   #  to this function should be propagated to the original AK_CHECK_PROG
   #  macro/test.
   #
   #  See: totebag/src/autokonf/macros/check_prog
   #
   #----------------------------------------------------------------------------

   sub mki_check_prog {
      my @params = @_;
      my $result = 0;
      print DBGOUT "mki_check_prog[ starting...\n" if $debugging;
      my $N      = $#params + 1;
      if (0 < $N) {
         my $given         = $params[0];
         print DBGOUT "mki_check_prog: ...given \"$given\"\n" if $debugging;
         if ($given ne "") {
            my $programName   = pKit_basename($given);
            print DBGOUT "mki_check_prog:    basename is \"$programName\"\n" if $debugging;
            $_                = $programName;
                                s/^\s+//g;
                                s/\s+$//g;
                                s/\s+/_/g;
                                s/[^a-zA-Z0-9_]/_/g;
            my $programName_u = $_;
            print DBGOUT "mki_check_prog:           aka. \"$programName_u\"\n" if $debugging;
            print DBGOUT "mki_check_prog: ...existence of \"$programName\" already known?\n" if $debugging;

            if ( ! exists $check_prog_isSupported{$programName}) {
               $check_prog_isSupported{$programName} = 0;
               $check_prog_pathname{$programName}    = "";

               print DBGOUT "mki_check_prog:    no, must test\n" if $debugging;
               if ($programName != $given) {
                  my $pathname = $given;
                  print DBGOUT "mki_check_prog: ...\"$given\" is a pathname\n" if $debugging;
                  print DBGOUT "mki_check_prog:    check \"$pathname\"\n" if $debugging;
                  if (-f $pathname) {
                     print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and is a file\n" if $debugging;
                     if (-x $pathname) {
                        print DBGOUT "mki_check_prog:       which is executable\n" if $debugging;
                        $check_prog_isSupported{$programName} = 1;
                        $check_prog_pathname{$programName}    = "$pathname";
                        print DBGOUT "mki_check_prog:    ...note its availability\n" if $debugging;
                     }
                     else {
                        print DBGOUT "mki_check_prog:    ...which is NOT executable\n" if $debugging;
                     }
                  }
                  else {
                     if ( -l $pathname) {
                        if ( -e $pathname) {
                           print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and is a symbolic-link to something other than a file\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and is a broken symbolic-link\n" if $debugging;
                        }
                     }
                     else {
                        if ( -e $pathname) {
                           print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and but is not a file\n" if $debugging;
                        }
                        else {
                           print DBGOUT "mki_check_prog:    ...\"$pathname\" doesn't exist\n" if $debugging;
                        }
                     }
                  }
               }
               else {
                  print DBGOUT "mki_check_prog: ...\"$given\" is a simple name\n" if $debugging;
                  if ( exists $ENV{'PATH'} ) {
                     $myPATH = $ENV{'PATH'};
                     @myPATH = split /:/, $myPATH;
                     my $i;
                     for ($i=0; $i<=$#myPATH; ++$i) {
                        my $pathname = pKit_joinpath($myPATH[$i],$programName);
                        print DBGOUT "mki_check_prog:    check \"$pathname\"\n" if $debugging;
                        if (-f $pathname) {
                           print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and is a file\n" if $debugging;
                           if (-x $pathname) {
                              print DBGOUT "mki_check_prog:       which is executable\n" if $debugging;
                              $check_prog_isSupported{$programName} = 1;
                              $check_prog_pathname{$programName}    = $pathname;
                              print DBGOUT "mki_check_prog:    ...note its availability\n" if $debugging;
                              last;
                           }
                           else {
                              print DBGOUT "mki_check_prog:       which isn't executable\n" if $debugging;
                           }
                        }
                        else {
                           if ( -l $pathname) {
                              if ( -e $pathname) {
                                 print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and is a symbolic-link to something other than a file\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and is a broken symbolic-link\n" if $debugging;
                              }
                           }
                           else {
                              if ( -e $pathname) {
                                 print DBGOUT "mki_check_prog:    ...\"$pathname\" exists and but is not a file\n" if $debugging;
                              }
                              else {
                                 print DBGOUT "mki_check_prog:    ...\"$pathname\" doesn't exist\n" if $debugging;
                              }
                           }
                        }
                     }
                  }
               }
            }
            else {
               print DBGOUT "mki_check_prog:    yes\n" if $debugging;
            }
            $result = $check_prog_isSupported{$programName};
         }
         else {
            print DBGOUT "mki_check_prog:    zero-length parameter\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mki_check_prog: ...no parameters\n" if $debugging;
      }
      print DBGOUT "mki_check_prog]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #   Compare 2 version number strings. A version number string is a
   #   string formed from doit (period) separated numbers (aka. version
   #   components. In a regular expression form a version number is:
   #
   #      \d+(\.\d+)*
   #
   #   A version number never starts with a dot and may indeed contain
   #   not dots (has a single component). No prefixes or suffixes are
   #   allowed. Note this function isn't a test/macro, rather it acts
   #   in support of the testing process.
   #
   #   On success an integer value is returned: negative if the first
   #   version number is less than the second version number, zero if
   #   the version numbers are the same, or positive if the first version
   #   number is greater than the second version number (they are "out
   #   of order).
   #
   #   On failure a empty (zero length) string is returned.
   #
   #  See: totebag/src/autokonf/macros/cmp_version_nums
   #
   #----------------------------------------------------------------------------

   sub mki_cmp_version_nums {
      my $versionNumI = shift;
      my $versionNumJ = shift;
      my $result      = "";

      if ($versionNumI =~ /^\d+(\.\d+)*$/) {
         if ($versionNumJ =~ /^\d+(\.\d+)*$/) {
            my @componentsI = split /\./, $versionNumI;
            my @componentsJ = split /\./, $versionNumJ;
            my $Ni          = $#componentsI + 1;
            my $Nj          = $#componentsJ + 1;
            my $Nmin        = $Ni; $Nmin = $Nj if ($Nj < $Nmin);
            my $Nmax        = $Ni; $Nmax = $Nj if ($Nmax < $Nj);
            my $k;
            for ($k=0; $k<$Nmax; ++$k) {
               my $componentI;
               my $componentJ;
               if ($k < $Ni) {
                  $componentI = $componentsI[$k] + 0;
               }
               else {
                  $componentI = 0;
               }
               if ($k < $Nj) {
                  $componentJ = $componentsJ[$k] + 0;
               }
               else {
                  $componentJ = 0;
               }
               if ($componentI < $componentJ) {
                  $result = -1;
                  last;
               }
               elsif ($componentI == $componentJ) {
                  if ($k == $Nmax-1) {
                     $result = 0;
                     last;
                  }
               }
               else {
                  $result = 1;
                  last;
               }
            }
            if ($result eq "") {
               $result = 0;
            }
         }
      }
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to cleanup files that may have been left by a C++
   #  test. This is only done on Linux hosts. Note that this function was
   #  derived from the AK_CXX_CLEANUP macro/test supplied with autokonf.
   #  Changes made to this function should be propagated to the original
   #  AK_CXX_CLEANUP macro/test.
   #
   #  See: totebag/src/autokonf/macros/cxx_cleanup
   #
   #----------------------------------------------------------------------------

   sub mki_cxx_cleanup {
      my @params = @_;
      my $N      = $#params + 1;
      print DBGOUT "mki_cxx_cleanup[ starting...\n" if $debugging;
      my $result = 0;

      if ($N <= 0) {
         my $first    = 1;
         my $i        = 0;
         my @nameList = ( "konftest.cxx"
                        , "konftest.o"
                        , "konftest.obj"
                        , "konftest"
                        , "konftest.exe"
                        , "konftest.out"
                        , "konftest.log"
                        , "konftest.dSYM"
                        , "konfmain.cxx"
                        , "konfmain.o"
                        , "konfmain.obj"
                        , "konfmain.dSYM"
                        , "konffunc.cxx"
                        , "konffunc.o"
                        , "konffunc.obj"
                        , "konffunc.dSYM"
                        );

         for ($i=0; $i<=$#nameList; ++$i) {
            my $pathname = $nameList[$i];
            if (-e $pathname) {
               if ($first) {
                  print DBGOUT "mki_cxx_cleanup: ...delete \"$pathname\"\n" if $debugging;
                  $first = 0;
               }
               else {
                  print DBGOUT "mki_cxx_cleanup:    delete \"$pathname\"\n" if $debugging;
               }
               unlink($pathname);
            }
         }
         $result = 1;
      }
      else {
         print DBGOUT "mki_cxx_cleanup: ...too many parameters for mki_cxx_cleanup()\n" if $debugging;
         $result = 0;
      }

      print DBGOUT "mki_cxx_cleanup] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log and konftest.c files to stderr.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_C_DUMP_SRC_LOG macro/function supplied with autokonf. Changes
   #  made to this function should be propagated to the original AK_C_DUMP_SRC_LOG
   #  macro/function.
   #
   #  See: totebag/src/autokonf/macros/c_dump_src_log
   #
   #----------------------------------------------------------------------------

   sub mki_c_dump_src_log {
      my @params  = @_;
      my $N       = $#params + 1;
      my $result  = 0;
      print DBGOUT "mki_c_dump_src_log[ starting...\n" if $debugging;
      my $srcname = "";
      my $ok;
      if ($N == 0) {
         $srcname = "konftest.c";
         $ok      = 1;
      }
      elsif ($N == 1) {
         $srcname = "$params[0]";
         $ok      = 1;
      }
      else {
         $ok      = 0;
      }
      if ($ok) {
         mki_dump_log();
         mki_dump_file($srcname);
         $result = 1;
      }
      else {
         print DBGOUT "mki_c_dump_src_log: ...too many parameters for mki_c_dump_src_log()\n" if $debugging;
         $result = 0;
      }
      print DBGOUT "mki_c_dump_src_log]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log and konftest.cxx files to stderr.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_CXX_DUMP_SRC_LOG macro/function supplied with autokonf. Changes
   #  made to this function should be propagated to the original AK_CXX_DUMP_SRC_LOG
   #  macro/function.
   #
   #  See: totebag/src/autokonf/macros/cxx_dump_src_log
   #
   #----------------------------------------------------------------------------

   sub mki_cxx_dump_src_log {
      my @params  = @_;
      my $N       = $#params + 1;
      my $result  = 0;
      print DBGOUT "mki_cxx_dump_src_log[ starting...\n" if $debugging;
      my $srcname = "";
      my $ok;
      if ($N == 0) {
         $srcname = "konftest.cxx";
         $ok      = 1;
      }
      elsif ($N == 1) {
         $srcname = "$params[0]";
         $ok      = 1;
      }
      else {
         $ok      = 0;
      }
      if ($ok) {
         mki_dump_log();
         mki_dump_file($srcname);
         $result = 1;
      }
      else {
         print DBGOUT "mki_cxx_dump_src_log: ...too many parameters for mki_cxx_dump_src_log()\n" if $debugging;
         $result = 0;
      }
      print DBGOUT "mki_cxx_dump_src_log]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log and konftest.cxx files to stderr.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_CXX_DUMP_SRC_LOG macro/function supplied with autokonf. Changes
   #  made to this function should be propagated to the original AK_CXX_DUMP_SRC_LOG
   #  macro/function.
   #
   #  See: totebag/src/autokonf/macros/dump_file
   #
   #----------------------------------------------------------------------------

   sub mki_dump_file {
      my @params   = @_;
      my $N        = $#params + 1;
      my $result   = 0;
      print DBGOUT "mki_dump_file[ starting...\n" if $debugging;
      my $filename = "";
      my $ok;
      if ($N == 0) {
         $filename = "konftest.c";
         $ok       = 1;
      }
      elsif ($N == 1) {
         $filename = "$params[0]";
         $ok       = 1;
      }
      else {
         $ok       = 0;
      }

      if ($ok) {
         if (-f $filename) {
            print DBGOUT "mki_dump_file: ...\"$filename\" is a file\n" if $debugging;
            if (-s $filename) {
               if ( open(mki_fromOutFile, "< $filename") ) {
                  print DBGOUT "mki_dump_file: ...the contents of \"$filename\"\n" if $debugging;
                  print STDERR "{-------------------------------------------------------------------------------\n";
                  print STDERR "$_" while <mki_fromOutFile>;
                  print STDERR "}-------------------------------------------------------------------------------\n";
                  close mki_fromOutFile;
               }
               else {
                  print DBGOUT "mki_dump_file: ...can't read \"$filename\"\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_dump_file: ...\"$filename\" is empty\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_dump_file: ...can't find \"$filename\" is empty\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mki_dump_file: ...too many parameters for mki_dump_file()\n" if $debugging;
      }
      print DBGOUT "mki_dump_file] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log file to stderr. This is only done
   #  on Linux hosts. Note that this function was derived from the AK_DUMP_LOG
   #  macro/function supplied with autokonf. Changes made to this function
   #  should be propagated to the original AK_DUMP_LOG macro/function.
   #
   #  See: totebag/src/autokonf/macros/dump_log
   #
   #----------------------------------------------------------------------------

   sub mki_dump_log {
      my @params = @_;
      my $N      = $#params + 1;
      my $result = 0;
      print DBGOUT "mki_dump_log[ starting...\n" if $debugging;
      if ($N <= 0) {
         my @fileList = ( "konftest.out"
                        , "konftest.log"
                        );
         my $i        = 0;
         for ($i=0; $i<=$#fileList; ++$i) {
            my $filename = $fileList[$i];
            mki_dump_file($filename);
         }
         $result = 1;
      }
      else {
         print DBGOUT "mki_dump_log: ...too many parameters for mki_cxx_dump_src_log()\n" if $debugging;
         $result = 0;
      }
      print DBGOUT "mki_dump_log]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Get the version numbers for the glibc library. This is only done on
   #  Linux hosts. Note that this function was derived from the AK_LIBC_VERSION
   #  macro/function supplied with autokonf. Changes made to this function
   #  should be propagated to the original AK_LIBC_VERSION macro/function.
   #
   #  NOTE: The following globals are set:
   #
   #            $CC_libc_pathname
   #            $CC_libc_version
   #            @CC_libc_verList
   #
   #  See: totebag/src/autokonf/macros/libc_version
   #
   #----------------------------------------------------------------------------

   sub mki_libc_version {
      print DBGOUT "mki_libc_version[ starting...\n" if $debugging;
      my $result        = "";
      $CC_libc_pathname = "";
      $CC_libc_version  = "";
      @CC_libc_verList  = ( );
      my $isKnown       = 0;
      my $ok;
      if (mki_check_prog("ldd")) {
         print DBGOUT "mki_libc_version: ...have \"ldd\" utility\n" if $debugging;
         my $use_ldd = $check_prog_pathname{"ldd"};
         print DBGOUT "mki_libc_version:    using \"$use_ldd\"\n" if $debugging;
         if (mki_check_prog("fgrep")) {
            my $use_fgrep = $check_prog_pathname{"fgrep"};
            print DBGOUT "mki_libc_version: ...have \"fgrep\" utility\n" if $debugging;
            print DBGOUT "mki_libc_version:    using \"$use_fgrep\"\n" if $debugging;
            if (mki_check_prog("strings")) {
               my $use_strings = $check_prog_pathname{"strings"};
               print DBGOUT "mki_libc_version: ...have \"strings\" utility\n" if $debugging;
               print DBGOUT "mki_libc_version:    using \"$use_strings\"\n" if $debugging;
               print DBGOUT "mki_libc_version: ...initialize findings\n" if $debugging;
               $CC_libc_pathname = "";
               $CC_libc_version  = "";
               @CC_libc_verList  = ( );

               #-------------------------------
               #
               #  Generate the first test file...
               #
               #-------------------------------
               print DBGOUT "mki_libc_version: ...generate first code\n" if $debugging;
               unlink "konftest.c";
               $ok = 0;
               if (open(mki_srcFile, "> konftest.c") ) {
                  print mki_srcFile pKit_fixIndentStuff(<<"EOFc");
                  |/* Generated by macro: mki_libc_version() */
                  |extern int strlen ( const char * );
                  |
                  |int main ( int argc, char *argv[] )
                  |{
                  |   int i;
                  |
                  |   for (i=1; i<argc; ++i) {
                  |      if (strlen(argv[i]) <= 0) {
                  |         return 1;
                  |      }
                  |   }
                  |   return 0;
                  |}
                  |
EOFc
                  close mki_srcFile;
                  $ok = 1;
                  print DBGOUT "mki_libc_version:    done\n" if $debugging;
               }
               if ($ok) {
                  #---------------------------------------
                  #
                  #  Try to compile and link it. Note
                  #  that if a binary executable is
                  #  successfully created then a copy
                  #  of it is tucked-away for future
                  #  reference.
                  #
                  print DBGOUT "mki_libc_version: ...compile and link test code\n" if $debugging;
                  if (mki_try_c_link()) {
                     print DBGOUT "mki_libc_version:    done\n" if $debugging;
                     if ( -f "konftest") {
                        if ( -x "konftest") {
                           print DBGOUT "mki_libc_version: ...examine \"konftest\" using ldd and fgrep\n" if $debugging;
                           my $cmd = "\"$use_ldd\" \"./konftest\" | \"$use_fgrep\" 'libc'";
                           print DBGOUT "mki_libc_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                           if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                              print DBGOUT "mki_libc_version:    ...done\n" if $debugging;
                              if ( -f "konftest.out" ) {
                                 print DBGOUT "mki_libc_version:    found \"konftest.out\"\n" if $debugging;
                                 if ( open(mki_OUTPUT, "< konftest.out") ) {
                                    print DBGOUT "mki_libc_version: ...parse results\n" if $debugging;
                                    my $libVersion  = "";
                                    my $libPathname = "";
                                    my $count       = 0;
                                    while (<mki_OUTPUT>) {
                                       chomp; s/\r$//;
                                       my $got = $_;
                                       if (256 < length $got) {
                                          print DBGOUT "mki_libc_version:    got: <too-long-to-show>\n" if $debugging;
                                       }
                                       else {
                                          print DBGOUT "mki_libc_version:    got: [$got]\n" if $debugging;
                                       }
                                       $_ = $got;
                                       parseResults: {
                                                        /^\s*(libc.so(\.(\S+)))\s+=>\s+(\S+).*$/

                                                           && do {
                                                              my $libName    = $1;
                                                              my $libVersion = $3;
                                                              $libPathname   = $4;
                                                              print DBGOUT "mki_libc_version:    ...case 1:\n" if $debugging;
                                                              print DBGOUT "mki_libc_version:          libName     = [$libName]\n" if $debugging;
                                                              print DBGOUT "mki_libc_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                              print DBGOUT "mki_libc_version:          libPathname = [$libPathname]\n" if $debugging;
                                                              $count        += 1;
                                                              last parseResults;
                                                           };

                                                        /^\s*(libc-(\S+)\.so\S+)\s+=>\s+(\S+).*$/

                                                           && do {
                                                              my $libName    = $1;
                                                              my $libVersion = $2;
                                                              $libPathname   = $3;
                                                              print DBGOUT "mki_libc_version:    ...case 2:\n" if $debugging;
                                                              print DBGOUT "mki_libc_version:          libName     = [$libName]\n" if $debugging;
                                                              print DBGOUT "mki_libc_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                              print DBGOUT "mki_libc_version:          libPathname = [$libPathname]\n" if $debugging;
                                                              $count        += 1;
                                                              last parseResults;
                                                           };

                                                        /^(.*)$/

                                                           && do {
                                                              print DBGOUT "mki_libc_version:    ...case 3:\n" if $debugging;
                                                              last parseResults;
                                                           };

                                                     }
                                    }
                                    close mki_OUTPUT;
                                    print DBGOUT "mki_libc_version:    done\n" if $debugging;
                                    if ($count <= 0) {
                                       print DBGOUT "mki_libc_version:    didn't find a C library pathname\n" if $debugging;
                                    }
                                    elsif ($count == 1) {
                                       print DBGOUT "mki_libc_version:    found a C library pathname\n" if $debugging;
                                       $CC_libc_pathname = $libPathname;
                                       print DBGOUT "mki_libc_version:    cleanup a bit\n" if $debugging;
                                       unlink("konftest.out");
                                       unlink("konftest.log");
                                       print DBGOUT "mki_libc_version: ...examine \"$libPathname\" using strings\n" if $debugging;
                                       my $cmd = "\"$use_strings\" \"$libPathname\"";
                                       print DBGOUT "mki_libc_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                                       if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                                          print DBGOUT "mki_libc_version:    ...done\n" if $debugging;
                                          if ( -f "konftest.out" ) {
                                             print DBGOUT "mki_libc_version:    found \"konftest.out\"\n" if $debugging;
                                             if ( open(mki_OUTPUT, "< konftest.out") ) {
                                                print DBGOUT "mki_libc_version: ...parse results\n" if $debugging;
                                                while (<mki_OUTPUT>) {
                                                   chomp; s/\r$//;
                                                   my $got = $_;
                                                   if (256 < length $got) {
                                                      print DBGOUT "mki_libc_version:    got: <too-long-to-show>\n" if $debugging;
                                                   }
                                                   else {
                                                      print DBGOUT "mki_libc_version:    got: [$got]\n" if $debugging;
                                                   }
                                                   $_ = $got;
                                                   parseResults: {
                                                                    /^\s*GLIBC_([.0-9]+)\S*\s*$/

                                                                       && do {
                                                                          my $libcVersion = $1;
                                                                          print DBGOUT "mki_libc_version:    ...case 1:\n" if $debugging;
                                                                          print DBGOUT "mki_libc_version:          C libVersion    = [$libcVersion]\n" if $debugging;
                                                                          my $idx                = $#CC_libc_verList + 1;
                                                                          $CC_libc_verList[$idx] = $libcVersion;
                                                                          $isKnown               = 1;
                                                                          last parseResults;
                                                                       };

                                                                    /^(.*)$/

                                                                       && do {
                                                                          print DBGOUT "mki_libc_version:    ...case 2:\n" if $debugging;
                                                                          last parseResults;
                                                                       };

                                                                 }
                                                }
                                                close mki_OUTPUT;
                                                print DBGOUT "mki_libc_version:    done\n" if $debugging;
                                             }
                                             else {
                                                print DBGOUT "mki_libc_version:    ...failed, can't read \"konftest.out\"\n" if $debugging;
                                             }
                                          }
                                          else {
                                             print DBGOUT "mki_libc_version:    ...failed, can't find \"konftest.out\"\n" if $debugging;
                                          }
                                       }
                                       else {
                                          print DBGOUT "mki_libc_version:    ...failed\n" if $debugging;
                                       }
                                    }
                                    else {
                                       print DBGOUT "mki_libc_version:    found multiple C library pathnames\n" if $debugging;
                                    }
                                 }
                                 else {
                                    print DBGOUT "mki_libc_version:    ...failed, can't read \"konftest.out\"\n" if $debugging;
                                 }
                              }
                              else {
                                 print DBGOUT "mki_libc_version:    ...failed, can't find \"konftest.out\"\n" if $debugging;
                              }
                           }
                           else {
                              print DBGOUT "mki_libc_version:    ...failed\n" if $debugging;
                           }
                        }
                        else {
                           print DBGOUT "mki_libc_version:    failed, \"konftest\" isn't executable\n" if $debugging;
                        }
                     }
                     else {
                        print DBGOUT "mki_libc_version:    failed, can't find \"konftest\"\n" if $debugging;
                     }
                  }
                  else {
                     print DBGOUT "mki_libc_version:    failed\n" if $debugging;
                  }
                  print DBGOUT "mki_libc_version: ...cleanup\n" if $debugging;
                  unlink "konftest.out";
                  unlink "konftest.log";
                  unlink "konftest";
                  unlink "konftest.o";
                  unlink "konftest.c";
               }
               else {
                  print DBGOUT "mki_libc_version:    failed\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_libc_version: ...don't have \"strings\" utility\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_libc_version: ...don't have \"fgrep\" utility\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mki_libc_version: ...don't have \"ldd\" utility\n" if $debugging;
      }
      if ($isKnown) {
         print DBGOUT "mki_libc_version: ...found some library version number(s)\n" if $debugging;
         my $Nlibc = $#CC_libc_verList + 1;
         if (1 <= $Nlibc) {
            @CC_libc_verList = mki_sort_version_list("LIBC versions",@CC_libc_verList);
            my $i;
            for ($i=0; $i<$Nlibc; ++$i) {
               my $versionNum = $CC_libc_verList[$i];
               if ($i == 0) {
                  print DBGOUT "mki_libc_version:    C library version ......................" if $debugging;
                  $CC_libc_version = $versionNum;
               }
               elsif ($i == 1) {
                  if ($Nlibc == 2) {
                     print DBGOUT "mki_libc_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print DBGOUT "mki_libc_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print DBGOUT "mki_libc_version:          .................................." if $debugging;
               }
               print DBGOUT " $versionNum\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_libc_version:    C library version ......................" if $debugging;
            print DBGOUT " unknown\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mki_libc_version: ...didn't find a library version number\n" if $debugging;
      }

      #-------------------------------
      #
      #  Generate the second test file...
      #
      #  Note that this part uses a different
      #  method, it simply calls the Linux
      #  specific gnu_get_libc_version()
      #  function. Note that this is used
      #  to develop the return value of
      #  this mki_libc_version() function.
      #
      print DBGOUT "mki_libc_version: ...generate second code\n" if $debugging;
      unlink "konftest.c";
      $ok = 0;
      if (open(mki_srcFile, "> konftest.c") ) {
         print mki_srcFile pKit_fixIndentStuff(<<"EOFc");
         |/* Generated by macro: mki_libc_version() */
         |#include <stdio.h>
         |#include <gnu/libc-version.h>
         |
         |int main (void)
         |{
         |   puts(gnu_get_libc_version());
         |   return 0;
         |}
         |
EOFc
         close mki_srcFile;
         $ok = 1;
         print DBGOUT "mki_libc_version:    done\n" if $debugging;
      }
      else {
         print DBGOUT "mki_libc_version:    failed\n" if $debugging;
      }
      if ($ok) {
         print DBGOUT "mki_libc_version: ...compile, link, and run test code\n" if $debugging;
         if (mki_try_c_run()) {
            print DBGOUT "mki_libc_version:    done\n" if $debugging;
            if ( -f "konftest.out") {
               print DBGOUT "mki_libc_version:    ...found \"konftest.out\"\n" if $debugging;
               if (open(MKI_OUTPUT,"< konftest.out")) {
                  print DBGOUT "mki_libc_version: ...read \"konftest.out\"\n" if $debugging;
                  while (<MKI_OUTPUT>) {
                     chomp; s/\r$//;
                     my $got = $_;
                     print DBGOUT "mki_libc_version:    found [$got]\n" if $debugging;
                     parseOutput: {
                                     /^\s*(\d+(\.\d+)+)\s*$/

                                        && do {
                                           $result = $1;
                                           print DBGOUT "mki_libc_version:    ...version $result\n" if $debugging;
                                           last parseOutput;
                                        };

                                     /^.*$/

                                        && do {
                                           print DBGOUT "mki_libc_version:    ...ignore\n" if $debugging;
                                           last parseOutput;
                                        };

                                  }
                  }
                  close MKI_OUTPUT;
                  print DBGOUT "mki_libc_version:    done\n" if $debugging;
               }
               else {
                  print DBGOUT "mki_libc_version:    ...can't read \"konftest.out\"\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_libc_version:    ...can't find \"konftest.out\"\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_libc_version:    failed\n" if $debugging;
         }
      }
      print DBGOUT "mki_libc_version: ...cleanup\n" if $debugging;
      unlink "konftest.out";
      unlink "konftest.log";
      unlink "konftest";
      unlink "konftest.o";
      unlink "konftest.c";
      print DBGOUT "mki_libc_version] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Get the version numbers for the OS version. This is only done on
   #  UNIX-like hosts.
   #
   #  Uses: uname
   #
   #----------------------------------------------------------------------------

   sub mki_os_version {
      print DBGOUT "mki_os_version[ starting...\n" if $debugging;
      my $result;
      if ($use_uname eq "") {
         print DBGOUT "mki_os_version: ...locate \"uname\" utility\n" if $debugging;
         if (mki_check_prog("uname")) {
            print DBGOUT "mki_os_version:    have \"uname\" utility\n" if $debugging;
            $use_uname = $check_prog_pathname{"uname"};
            print DBGOUT "mki_os_version:    using \"$use_uname\"\n" if $debugging;
         }
         else {
            print DBGOUT "mki_os_version: ...can't locate \"uname\"\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mki_os_version: ...already located \"uname\" utility\n" if $debugging;
         print DBGOUT "mki_os_version:    using \"$use_uname\"\n" if $debugging;
      }
      if ($use_uname ne "") {
         my $cmd = "$use_uname -r";
         print DBGOUT "mki_os_version: ...run [$use_uname]\n" if $debugging;
         if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
            print DBGOUT "mki_os_version:    done\n" if $debugging;
            if ( -f "konftest.out" ) {
               print DBGOUT "mki_os_version:    and found \"konftest.out\"\n" if $debugging;
               if ( open(mki_OUTPUT, "< konftest.out") ) {
                  print DBGOUT "mki_os_version: ...parse results\n" if $debugging;
                  my $versionNumber = "";
                  while (<mki_OUTPUT>) {
                     chomp; s/\r$//;
                     my $got = $_;
                     if (256 < length $got) {
                        print DBGOUT "mki_os_version:    got: <too-long-to-show>\n" if $debugging;
                     }
                     else {
                        print DBGOUT "mki_os_version:    got: [$got]\n" if $debugging;
                     }
                     $_ = $got;
                     parseResults: {
                                      /^\s*(\d+(\.\d+)*)(\D.*)?$/

                                         && do {
                                           print DBGOUT "mki_os_version:    ...case 1:\n" if $debugging;
                                           $versionNumber = $1;
                                           print DBGOUT "mki_os_version:       found [$versionNumber]\n" if $debugging;
                                           last parseResults;
                                        };

                                      /^(.*)$/

                                         && do {
                                           print DBGOUT "mki_os_version:    ...case 2:\n" if $debugging;
                                           last parseResults;
                                        };
                                   }
                  }
                  close mki_OUTPUT;
                  if ($versionNumber ne "") {
                     print DBGOUT "mki_os_version:    done, gives [$versionNumber]\n" if $debugging;
                     $result = $versionNumber;
                  }
               }
               else {
                  print DBGOUT "mki_os_version:    but can't read \"konftest.out\"\n" if $debugging;
                  $result = "";
               }
            }
            else {
               print DBGOUT "mki_os_version:    but can't find \"konftest.out\"\n" if $debugging;
               $result = "";
            }
         }
         else {
            print DBGOUT "mki_os_version:    failed\n" if $debugging;
            $result = "";
         }
      }
      else {
         $result = "";
      }
      unlink "konftest.log";
      unlink "konftest.out";
      print DBGOUT "mki_os_version] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Run a given command. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_RUN_COMMAND macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to
   #  the original AK_RUN_COMMAND macro/function.
   #
   #  See: totebag/src/autokonf/macros/run_command
   #
   #----------------------------------------------------------------------------

   sub mki_run_command {
      my @params = @_;
      my $N      = $#params + 1;
      my $result = 0;
      print DBGOUT "mki_run_command[ starting...\n" if $debugging;

      if ($N == 1) {
         my $cmd            = $params[0];
         $mki_run_command_theStatus = -1;
         if ($cmd ne "") {
            #-------------------------------
            #
            #  Run the command...
            #
            my $ok     = 0;
            my $status = 0;
            print DBGOUT "mki_run_command: ...run [$cmd]\n" if $debugging;
            $status = 0xffff & system "$cmd";
            if ($status == 0) {
               print DBGOUT "mki_run_command:    returned $status, ok\n" if $debugging;
               $mki_run_command_theStatus    = $status;
               $result                       = 1;
            }
            elsif ($status == 0xff00) {
               print DBGOUT "mki_run_command:    returned 0xFF00, command failed: $!\n" if $debugging;
               $mki_run_command_theStatus    = -1;
               $result                       = 0;
            }
            elsif (($status & 0xff) == 0) {
               $status >>= 8;
               print DBGOUT "mki_run_command:    returned $status, error\n" if $debugging;
               $mki_run_command_theStatus    = $status;
               $result                       = 0;
            }
            else {
               print DBGOUT "mki_run_command:    returned $status, " if $debugging;
               if ($status & 0x80) {
                  $status &= ~0x80;
                  print DBGOUT "coredump from " if $debugging;
               }
               print DBGOUT "signal $status\n" if $debugging;
               $mki_run_command_theStatus    = -1;
               $result                       = 0;
            }
         }
      }
      elsif ($N < 1) {
         print DBGOUT "mki_run_command: ...too few parameters for mki_run_command()\n" if $debugging;
         $result = 0;
      }
      else {
         print DBGOUT "mki_run_command: ...too many parameters for mki_run_command()\n" if $debugging;
         $result = 0;
      }
      print DBGOUT "mki_run_command] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Sort an array of strings representing version numbers. The sort is
   #  reverse: high to low (descending order). Note that this function isn't
   #  a test/macro, rather it acts in support of the testing process.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_SORT_VERSION_LIST macro/function supplied with autokonf.
   #  Changes made to this function should be propagated to the original
   #  AK_SORT_VERSION_LIST macro/function.
   #
   #  NOTE: A version number is a string of dot separated integer numbers:
   #
   #           \d+(\.\d+)*
   #
   #  See: totebag/src/autokonf/macros/sort_version_list
   #
   #----------------------------------------------------------------------------

   sub mki_sort_version_list {
      my $whatAreThey = shift;
      my @versionNums = @_;
      my $N           = $#versionNums + 1;
      print DBGOUT "mki_sort_version_list[ sorting \"".$whatAreThey."\" ...\n" if $debugging;
      if (1 < $N) {
         print DBGOUT "mki_sort_version_list: ...sort $N version numbers\n" if $debugging;
         {
            print DBGOUT "mki_sort_version_list:    given:\n" if $debugging;
            my $k;
            for ($k=0; $k<$N; ++$k) {
               my $versionNum = $versionNums[$k];
               print DBGOUT "mki_sort_version_list:       [$versionNum]\n" if $debugging;
            }
         }
         print DBGOUT "mki_sort_version_list: ...start the actual sorting process\n" if $debugging;
         my $changed = 0;
         my $swapped = 1;
         while ($swapped) {
            $swapped = 0;
            my $i;
            my $j;
            for ($i=0,$j=1; $j<$N; ++$i,++$j) {
               my $versionNumI = $versionNums[$i];
               my $versionNumJ = $versionNums[$j];
               my $d           = mki_cmp_version_nums($versionNumI,$versionNumJ);
               if ($d eq "") {
                  print DBGOUT "mki_sort_version_list:    problem comparing [$versionNumI]\n" if $debugging;
                  print DBGOUT "mki_sort_version_list:                  and [$versionNumJ]\n" if $debugging;
                  goto theExit;
               }
               #
               #  Reverse order: sort high to low
               #
               if ($d < 0) {
                  $versionNums[$i] = $versionNumJ;
                  $versionNums[$j] = $versionNumI;
                  $swapped         = 1;
                  $changed         = 1;
               }
            }
         }
         print DBGOUT "mki_sort_version_list:    done\n" if $debugging;
         if ($changed) {
            print DBGOUT "mki_sort_version_list:    gives:\n" if $debugging;
            my $k;
            for ($k=0; $k<$N; ++$k) {
               my $versionNum = $versionNums[$k];
               print DBGOUT "mki_sort_version_list:       [$versionNum]\n" if $debugging;
            }
         }
      }
      else {
         print DBGOUT "mki_sort_version_list: ...no version numbers to sort\n" if $debugging;
      }
   theExit:
      print DBGOUT "mki_sort_version_list] ...done\n" if $debugging;
      return @versionNums;
   }

   #----------------------------------------------------------------------------
   #
   #  Get the version numbers for the C++ ABI, Standard C++ library, and the
   #  glibc library. This is only done on Linux hosts. Note that this function
   #  was derived from the AK_STDCXXLIB_VERSION macro/function supplied with
   #  autokonf. Changes made to this function should be propagated to the
   #  original AK_STDCXXLIB_VERSION macro/function.
   #
   #  NOTE: The following globals are set:
   #
   #            $CXX_stdcxxlib_pathname
   #            @CXX_stdcxxlib_verList
   #            $CXX_stdcxxlib_version
   #            @CXX_stdcxxlib_libcVerList
   #            $CXX_stdcxxlib_libcVersion
   #            @CXX_stdcxxlib_abiVerList
   #            $CXX_stdcxxlib_abiVersion
   #
   #  See: totebag/src/autokonf/macros/stdlibcxx_version
   #
   #----------------------------------------------------------------------------

   sub mki_stdcxxlib_version {
      print DBGOUT "mki_stdcxxlib_version[ starting...\n" if $debugging;
      my $ok                     = 0;
      $result                    = 0;
      $CXX_stdcxxlib_pathname    = "";
      @CXX_stdcxxlib_verList     = ( );
      $CXX_stdcxxlib_version     = "";
      @CXX_stdcxxlib_libcVerList = ( );
      $CXX_stdcxxlib_libcVersion = ( );
      @CXX_stdcxxlib_abiVerList  = ( );
      $CXX_stdcxxlib_abiVersion  = "";
      $isKnown               = 0;
      if (mki_check_prog("ldd")) {
         print DBGOUT "mki_stdcxxlib_version: ...have \"ldd\" utility\n" if $debugging;
         my $use_ldd = $check_prog_pathname{"ldd"};
         print DBGOUT "mki_stdcxxlib_version:    using \"$use_ldd\"\n" if $debugging;
         if (mki_check_prog("fgrep")) {
            my $use_fgrep = $check_prog_pathname{"fgrep"};
            print DBGOUT "mki_stdcxxlib_version: ...have \"fgrep\" utility\n" if $debugging;
            print DBGOUT "mki_stdcxxlib_version:    using \"$use_fgrep\"\n" if $debugging;
            if (mki_check_prog("strings")) {
               my $use_strings = $check_prog_pathname{"strings"};
               print DBGOUT "mki_stdcxxlib_version: ...have \"strings\" utility\n" if $debugging;
               print DBGOUT "mki_stdcxxlib_version:    using \"$use_strings\"\n" if $debugging;
               my $answeredTheQuestion = 0;
               if ( ! $answeredTheQuestion) {
                  print DBGOUT "mki_stdcxxlib_version: ...initialize findings\n" if $debugging;
                  $CXX_stdcxxlib_pathname    = "";
                  @CXX_stdcxxlib_verList     = ( );
                  @CXX_stdcxxlib_libcVerList = ( );
                  @CXX_stdcxxlib_abiVerList  = ( );

                  #-------------------------------
                  #
                  #  Generate the first test file...
                  #
                  print DBGOUT "mki_stdcxxlib_version: ...generate primary (complex) test code\n" if $debugging;
                  if ( ! open(mki_srcFile, "> konftest.cxx") ) {
                     print DBGOUT "mki_stdcxxlib_version:    can't create/write \"konftest.cxx\"\n" if $debugging;
                  }
                  else {
                     #
                     #  Note that this test code may seem stupid and
                     #  an overkill but it ensures that a standard C++
                     #  library facility is used (a vector) and that
                     #  the vector is both written in to and read from
                     #  to avoid warnings.
                     #
                     print mki_srcFile pKit_fixIndentStuff(<<"EOFc");
                     |// Generated by macro: mki_stdcxxlib_version()
                     |#include <vector>
                     |
                     |int main ( int argc, char *argv[] )
                     |{  int                      i;
                     |   std::vector<const char*> v;
                     |
                     |   for (i=0; i<argc; ++i) {
                     |      v.push_back(argv[i]);
                     |   }
                     |   for (i=0; i<argc; ++i) {
                     |      if (v[i]) {
                     |         ;
                     |      }
                     |      else {
                     |         return 1;
                     |      }
                     |   }
                     |   return 0;
                     |}
                     |
EOFc
                     close mki_srcFile;
                     $ok = 1;
                     print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                  }
                  if ($ok) {
                     #{--------------------------------------
                     #
                     #  Try to compile and link it. Note
                     #  that if a binary executable is
                     #  successfully created then a copy
                     #  of it is tucked-away for future
                     #  reference.
                     #
                     print DBGOUT "mki_stdcxxlib_version: ...compile and link test code\n" if $debugging;
                     if (mki_try_cxx_link()) {
                        print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                        if ( -f "konftest") {
                           print DBGOUT "mki_stdcxxlib_version: ...examine \"konftest\" using ldd and fgrep\n" if $debugging;
                           my $cmd = "\"$use_ldd\" \"./konftest\" | \"$use_fgrep\" 'libstdc++'";
                           print DBGOUT "mki_stdcxxlib_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                           if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                              print DBGOUT "mki_stdcxxlib_version:    ...done\n" if $debugging;
                              if ( -f "konftest.out" ) {
                                 print DBGOUT "mki_stdcxxlib_version:    found \"konftest.out\"\n" if $debugging;
                                 if ( open(mki_OUTPUT, "< konftest.out") ) {
                                    print DBGOUT "mki_stdcxxlib_version: ...parse results\n" if $debugging;
                                    my $libVersion  = "";
                                    my $libPathname = "";
                                    my $count = 0;
                                    while (<mki_OUTPUT>) {
                                       chomp; s/\r$//;
                                       my $got = $_;
                                       if (256 < length $got) {
                                          print DBGOUT "mki_stdcxxlib_version:    got: <too-long-to-show>\n" if $debugging;
                                       }
                                       else {
                                          print DBGOUT "mki_stdcxxlib_version:    got: [$got]\n" if $debugging;
                                       }
                                       $_ = $got;
                                       parseResults: {
                                                       /^\s*(libstdc\+\+\.so(\.(\S+)))\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $3;
                                                             $libPathname   = $4;
                                                             print DBGOUT "mki_stdcxxlib_version:    ...case 1:\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libName     = [$libName]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count        += 1;
                                                             last parseResults;
                                                          };

                                                       /^\s*(libstdc\+\+-(\S+)\.so\S+)\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $2;
                                                             $libPathname   = $3;
                                                             print DBGOUT "mki_stdcxxlib_version:    ...case 2:\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libName     = [$libName]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count        += 1;
                                                             last parseResults;
                                                          };

                                                       /^(.*)$/

                                                          && do {
                                                             print DBGOUT "mki_stdcxxlib_version:    ...case 3:\n" if $debugging;
                                                             last parseResults;
                                                          };

                                                     }
                                    }
                                    close mki_OUTPUT;
                                    print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                                    if ($count <= 0) {
                                       print DBGOUT "mki_stdcxxlib_version:    didn't find a Standard C++ library pathname\n" if $debugging;
                                    }
                                    elsif ($count == 1) {
                                       print DBGOUT "mki_stdcxxlib_version:    found a Standard C++ library pathname\n" if $debugging;
                                       $CXX_stdcxxlib_pathname = $libPathname;
                                       print DBGOUT "mki_stdcxxlib_version:    cleanup a bit\n" if $debugging;
                                       unlink("konftest.out");
                                       unlink("konftest.log");
                                       print DBGOUT "mki_stdcxxlib_version: ...examine \"$libPathname\" using strings\n" if $debugging;
                                       my $cmd = "\"$use_strings\" \"$libPathname\"";
                                       print DBGOUT "mki_stdcxxlib_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                                       if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                                          print DBGOUT "mki_stdcxxlib_version:    ...done\n" if $debugging;
                                          if ( -f "konftest.out" ) {
                                             print DBGOUT "mki_stdcxxlib_version:    found \"konftest.out\"\n" if $debugging;
                                             if ( open(mki_OUTPUT, "< konftest.out") ) {
                                                print DBGOUT "mki_stdcxxlib_version: ...parse results\n" if $debugging;
                                                my $first_cxxabi_verNum = "";
                                                my $first_libcxx_verNum = "";
                                                my $first_libc_verNum   = "";
                                                while (<mki_OUTPUT>) {
                                                   chomp; s/\r$//;
                                                   my $got = $_;
                                                   if (256 < length $got) {
                                                      print DBGOUT "mki_stdcxxlib_version:    got: <too-long-to-show>\n" if $debugging;
                                                   }
                                                   else {
                                                      print DBGOUT "mki_stdcxxlib_version:    got: [$got]\n" if $debugging;
                                                   }
                                                   $_ = $got;
                                                   parseResults: {
                                                                   /^\s*GLIBCXX_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 1:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;
                                                                         my $idx                      = $#CXX_stdcxxlib_verList + 1;
                                                                         $CXX_stdcxxlib_verList[$idx] = $libcxxVersion;
                                                                         $isKnown                     = 1;
                                                                         $first_libcxx_verNum         = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBCPP_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 2:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;
                                                                         my $idx                      = $#CXX_stdcxxlib_verList + 1;
                                                                         $CXX_stdcxxlib_verList[$idx] = $libcxxVersion;
                                                                         $isKnown                     = 1;
                                                                         $first_libcxx_verNum         = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CXXABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 3:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx                         = $#CXX_stdcxxlib_abiVerList + 1;
                                                                         $CXX_stdcxxlib_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown                        = 1;
                                                                         $first_cxxabi_verNum            = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CPPABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 4:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx                         = $#CXX_stdcxxlib_abiVerList + 1;
                                                                         $CXX_stdcxxlib_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown                        = 1;
                                                                         $first_cxxabi_verNum            = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBC_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 5:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C libVersion    = [$libcVersion]\n" if $debugging;
                                                                         my $idx                          = $#CXX_stdcxxlib_libcVerList + 1;
                                                                         $CXX_stdcxxlib_libcVerList[$idx] = $libcVersion;
                                                                         $isKnown                         = 1;
                                                                         $first_libc_verNum               = $libcVersion if $first_libc_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^(.*)$/

                                                                      && do {
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 6:\n" if $debugging;
                                                                         last parseResults;
                                                                      };

                                                                 }
                                                }
                                                close mki_OUTPUT;
                                                print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                                                if ($isKnown) {
                                                   $answeredTheQuestion = 1;
                                                }
                                             }
                                             else {
                                                print DBGOUT "mki_stdcxxlib_version: ...can't read \"konftest.out\"\n" if $debugging;
                                             }
                                          }
                                          else {
                                             print DBGOUT "mki_stdcxxlib_version:    can't find \"konftest.out\"\n" if $debugging;
                                          }
                                       }
                                       else {
                                          print DBGOUT "mki_stdcxxlib_version:    ...failed\n" if $debugging;
#                                         mki_cxx_dump_src_log();
                                       }
                                    }
                                    else {
                                       print DBGOUT "mki_stdcxxlib_version:    found multiple Standard C++ library pathnames\n" if $debugging;
                                    }
                                 }
                                 else {
                                    print DBGOUT "mki_stdcxxlib_version: ...can't read \"konftest.out\"\n" if $debugging;
                                 }
                              }
                              else {
                                 print DBGOUT "mki_stdcxxlib_version:    can't find \"konftest.out\"\n" if $debugging;
                              }
                           }
                           else {
                              print DBGOUT "mki_stdcxxlib_version:    ...failed\n" if $debugging;
#                             mki_cxx_dump_src_log();
                           }
                           print DBGOUT "mki_stdcxxlib_version:    cleanup\n" if $debugging;
                           unlink("konftest.out");
                           unlink("konftest.log");
                           unlink("konftest");
                           unlink("konftest.o");
                        }
                        else {
                           print DBGOUT "mki_stdcxxlib_version:    but didn't produce a binary\n" if $debugging;
                        }
                     }
                     else {
                        print DBGOUT "mki_stdcxxlib_version:    failed\n" if $debugging;
#                       mki_cxx_dump_src_log();
                     }
                     #}--------------------------------------
                     mki_cxx_cleanup();
                  }
               }
               if ( ! $answeredTheQuestion) {
                  print DBGOUT "mki_stdcxxlib_version: ...initialize findings\n" if $debugging;
                  $CXX_stdcxxlib_pathname    = "";
                  @CXX_stdcxxlib_verList     = ( );
                  @CXX_stdcxxlib_libcVerList = ( );
                  @CXX_stdcxxlib_abiVerList  = ( );

                  #-------------------------------
                  #
                  #  Generate the alternate test file...
                  #
                  print DBGOUT "mki_stdcxxlib_version: ...generate alternate (simple) test code\n" if $debugging;
                  if ( ! open(mki_srcFile, "> konftest.cxx") ) {
                     print DBGOUT "mki_stdcxxlib_version:    can't create/write \"konftest.cxx\"\n" if $debugging;
                  }
                  else {
                     #
                     #  this test code can give trouble as it doesn't
                     #  actually require use of the Standard C++ library
                     #  and so the "ldd" utility may not detect its
                     #  use.
                     #
                     print mki_srcFile pKit_fixIndentStuff(<<"EOFc");
                     |// Generated by macro: mki_stdcxxlib_version()
                     |
                     |int main ( )
                     |{  return 0;
                     |}
                     |
EOFc
                     close mki_srcFile;
                     $ok = 1;
                     print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                  }
                  if ($ok) {
                     #{--------------------------------------
                     #
                     #  Try to compile and link it. Note
                     #  that if a binary executable is
                     #  successfully created then a copy
                     #  of it is tucked-away for future
                     #  reference.
                     #
                     if (mki_try_cxx_link()) {
                        if ( -f "konftest") {
                           print DBGOUT "mki_stdcxxlib_version: ...examine \"konftest\" using ldd and fgrep\n" if $debugging;
                           my $cmd = "\"$use_ldd\" \"./konftest\" | \"$use_fgrep\" 'libstdc++'";
                           print DBGOUT "mki_stdcxxlib_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                           if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                              print DBGOUT "mki_stdcxxlib_version:    ...done\n" if $debugging;
                              if ( -f "konftest.out" ) {
                                 print DBGOUT "mki_stdcxxlib_version:    found \"konftest.out\"\n" if $debugging;
                                 if ( open(mki_OUTPUT, "< konftest.out") ) {
                                    print DBGOUT "mki_stdcxxlib_version: ...parse results\n" if $debugging;
                                    my $libVersion  = "";
                                    my $libPathname = "";
                                    my $count       = 0;
                                    while (<mki_OUTPUT>) {
                                       chomp; s/\r$//;
                                       my $got = $_;
                                       if (256 < length $got) {
                                          print DBGOUT "mki_stdcxxlib_version:    got: <too-long-to-show>\n" if $debugging;
                                       }
                                       else {
                                          print DBGOUT "mki_stdcxxlib_version:    got: [$got]\n" if $debugging;
                                       }
                                       $_ = $got;
                                       parseResults: {
                                                       /^\s*(libstdc\+\+\.so(\.(\S+)))\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $3;
                                                             $libPathname   = $4;
                                                             print DBGOUT "mki_stdcxxlib_version:    ...case 1:\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libName     = [$libName]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count          += 1;
                                                             last parseResults;
                                                          };

                                                       /^\s*(libstdc\+\+-(\S+)\.so\S+)\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $2;
                                                             $libPathname   = $3;
                                                             print DBGOUT "mki_stdcxxlib_version:    ...case 2:\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libName     = [$libName]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print DBGOUT "mki_stdcxxlib_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count          += 1;
                                                             last parseResults;
                                                          };

                                                       /^(.*)$/

                                                          && do {
                                                             print DBGOUT "mki_stdcxxlib_version:    ...case 3:\n" if $debugging;
                                                             last parseResults;
                                                          };

                                                     }
                                    }
                                    close mki_OUTPUT;
                                    print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                                    if ($count <= 0) {
                                       print DBGOUT "mki_stdcxxlib_version:    didn't find a Standard C++ library pathname\n" if $debugging;

                                    }
                                    elsif ($count == 1) {
                                       print DBGOUT "mki_stdcxxlib_version:    found a Standard C++ library pathname\n" if $debugging;
                                       $CXX_stdcxxlib_pathname = $libPathname;
                                       print DBGOUT "mki_stdcxxlib_version:    cleanup a bit\n" if $debugging;
                                       unlink("konftest.out");
                                       unlink("konftest.log");
                                       print DBGOUT "mki_stdcxxlib_version: ...examine \"$libPathname\" using strings\n" if $debugging;
                                       my $cmd = "\"$use_strings\" \"$libPathname\"";
                                       print DBGOUT "mki_stdcxxlib_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                                       if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                                          print DBGOUT "mki_stdcxxlib_version:    ...done\n" if $debugging;
                                          if ( -f "konftest.out" ) {
                                             print DBGOUT "mki_stdcxxlib_version:    found \"konftest.out\"\n" if $debugging;
                                             if ( open(mki_OUTPUT, "< konftest.out") ) {
                                                print DBGOUT "mki_stdcxxlib_version: ...parse results\n" if $debugging;
                                                my $first_cxxabi_verNum = "";
                                                my $first_libcxx_verNum = "";
                                                my $first_libc_verNum   = "";
                                                while (<mki_OUTPUT>) {
                                                   chomp; s/\r$//;
                                                   my $got = $_;
                                                   if (256 < length $got) {
                                                      print DBGOUT "mki_stdcxxlib_version:    got: <too-long-to-show>\n" if $debugging;
                                                   }
                                                   else {
                                                      print DBGOUT "mki_stdcxxlib_version:    got: [$got]\n" if $debugging;
                                                   }
                                                   $_ = $got;
                                                   parseResults: {
                                                                   /^\s*GLIBCXX_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 1:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;

                                                                         my $idx                      = $#CXX_stdcxxlib_verList + 1;
                                                                         $CXX_stdcxxlib_verList[$idx] = $libcxxVersion;
                                                                         $isKnown                     = 1;
                                                                         $first_libcxx_verNum         = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBCPP_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 2:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;
                                                                         my $idx                      = $#CXX_stdcxxlib_verList + 1;
                                                                         $CXX_stdcxxlib_verList[$idx] = $libcxxVersion;
                                                                         $isKnown                     = 1;
                                                                         $first_libcxx_verNum         = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CXXABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 3:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx                         = $#CXX_stdcxxlib_abiVerList + 1;
                                                                         $CXX_stdcxxlib_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown                        = 1;
                                                                         $first_cxxabi_verNum            = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CPPABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 4:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx                         = $#CXX_stdcxxlib_abiVerList + 1;
                                                                         $CXX_stdcxxlib_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown                        = 1;
                                                                         $first_cxxabi_verNum            = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBC_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcVersion = $1;
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 5:\n" if $debugging;
                                                                         print DBGOUT "mki_stdcxxlib_version:          C libVersion    = [$libcVersion]\n" if $debugging;
                                                                         my $idx                          = $#CXX_stdcxxlib_libcVerList + 1;
                                                                         $CXX_stdcxxlib_libcVerList[$idx] = $libcVersion;
                                                                         $isKnown                         = 1;
                                                                         $first_libc_verNum               = $libcVersion if $first_libc_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^(.*)$/

                                                                      && do {
                                                                         print DBGOUT "mki_stdcxxlib_version:    ...case 6:\n" if $debugging;
                                                                         last parseResults;
                                                                      };

                                                                 }
                                                }
                                                close mki_OUTPUT;
                                                print DBGOUT "mki_stdcxxlib_version:    done\n" if $debugging;
                                                if ($isKnown) {
                                                   $answeredTheQuestion = 1;
                                                }
                                             }
                                             else {
                                                print DBGOUT "mki_stdcxxlib_version: ...can't read \"konftest.out\"\n" if $debugging;
                                             }
                                          }
                                          else {
                                             print DBGOUT "mki_stdcxxlib_version:    can't find \"konftest.out\"\n" if $debugging;
                                          }
                                       }
                                       else {
                                          print DBGOUT "mki_stdcxxlib_version:    ...failed\n" if $debugging;
#                                         mki_cxx_dump_src_log();
                                       }
                                    }
                                    else {
                                       print DBGOUT "mki_stdcxxlib_version:    found multiple Standard C++ library pathnames\n" if $debugging;
                                    }
                                 }
                                 else {
                                    print DBGOUT "mki_stdcxxlib_version: ...can't read \"konftest.out\"\n" if $debugging;
                                 }
                              }
                              else {
                                 print DBGOUT "mki_stdcxxlib_version:    can't find \"konftest.out\"\n" if $debugging;
                              }
                           }
                           else {
                              print DBGOUT "mki_stdcxxlib_version:    ...failed\n" if $debugging;
#                             mki_cxx_dump_src_log();
                           }
                           print DBGOUT "mki_stdcxxlib_version:    cleanup\n" if $debugging;
                           unlink("konftest.out");
                           unlink("konftest.log");
                           unlink("konftest");
                           unlink("konftest.o");
                        }
                        else {
                           print DBGOUT "mki_stdcxxlib_version:    but didn't produce a binary\n" if $debugging;
                        }
                     }
                     else {
#                       mki_cxx_dump_src_log();
                     }
                     #}--------------------------------------
                     mki_cxx_cleanup();
                  }
               }
            }
            else {
               print DBGOUT "mki_stdcxxlib_version: ...don't have \"strings\" utility\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_stdcxxlib_version: ...don't have \"fgrep\" utility\n" if $debugging;
         }
      }
      else {
         print DBGOUT "mki_stdcxxlib_version: ...don't have \"ldd\" utility\n" if $debugging;
      }

      if ($isKnown) {
         print DBGOUT "mki_stdcxxlib_version: ...found some library version number(s)\n" if $debugging;
         my $Ncxxabi = $#CXX_stdcxxlib_abiVerList + 1;
         if (1 <= $Ncxxabi) {
            @CXX_stdcxxlib_abiVerList = mki_sort_version_list("C++ ABI versions",@CXX_stdcxxlib_abiVerList);
            my $i;
            for ($i=0; $i<$Ncxxabi; ++$i) {
               my $versionNum = $CXX_stdcxxlib_abiVerList[$i];
               if ($i == 0) {
                  print DBGOUT "mki_stdcxxlib_version:    C++ ABI version ........................" if $debugging;
               }
               elsif ($i == 1) {
                  if ($Ncxxabi == 2) {
                     print DBGOUT "mki_stdcxxlib_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print DBGOUT "mki_stdcxxlib_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print DBGOUT "mki_stdcxxlib_version:          .................................." if $debugging;
               }
               print DBGOUT " $versionNum\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_stdcxxlib_version:    C++ ABI version ........................" if $debugging;
            print DBGOUT " unknown\n" if $debugging;
         }
         my $Nlibcxx = $#CXX_stdcxxlib_verList + 1;
         if (1 <= $Nlibcxx) {
            @CXX_stdcxxlib_verList = mki_sort_version_list("C++ lib versions",@CXX_stdcxxlib_verList);
            my $i;
            for ($i=0; $i<$Nlibcxx; ++$i) {
               my $versionNum = $CXX_stdcxxlib_verList[$i];
               if ($i == 0) {
                  print DBGOUT "mki_stdcxxlib_version:    Standard C++ library version ..........." if $debugging;
               }
               elsif ($i == 1) {
                  if ($Nlibcxx == 2) {
                     print DBGOUT "mki_stdcxxlib_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print DBGOUT "mki_stdcxxlib_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print DBGOUT "mki_stdcxxlib_version:          .................................." if $debugging;
               }
               print DBGOUT " $versionNum\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_stdcxxlib_version:    Standard C++ library version ..........." if $debugging;
            print DBGOUT " unknown\n" if $debugging;
         }
         my $Nlibc = $#CXX_stdcxxlib_libcVerList + 1;
         if (1 <= $Nlibc) {
            @CXX_stdcxxlib_libcVerList = mki_sort_version_list("C++ libc versions",@CXX_stdcxxlib_libcVerList);
            my $i;
            for ($i=0; $i<$Nlibc; ++$i) {
               my $versionNum = $CXX_stdcxxlib_libcVerList[$i];
               if ($i == 0) {
                  print DBGOUT "mki_stdcxxlib_version:    C library version ......................" if $debugging;
               }
               elsif ($i == 1) {
                  if ($Nlibc == 2) {
                     print DBGOUT "mki_stdcxxlib_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print DBGOUT "mki_stdcxxlib_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print DBGOUT "mki_stdcxxlib_version:          .................................." if $debugging;
               }
               print DBGOUT " $versionNum\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_stdcxxlib_version:    C library version ......................" if $debugging;
            print DBGOUT " unknown\n" if $debugging;
         }
         $result = 1;
      }
      else {
         print DBGOUT "mki_stdcxxlib_version: ...didn't find any library version numbers\n" if $debugging;
         $stdlibcxx_version_isKnown = 0;
      }

      if ($producedBinary ne "") {
         if ( -f $producedBinary) {
            print DBGOUT "mki_stdcxxlib_version: ...delete \"$producedBinary\"\n" if $debugging;
            unlink($producedBinary);
         }
         if ( -f "konftest.out") {
            unlink("konftest.out");
         }
         if ( -f "konftest.log") {
            unlink("konftest.log");
         }
      }

      print DBGOUT "mki_stdcxxlib_version] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an object file by using the C compiler.
   #  Note that by default it will try to form an object file from the
   #  "konftest.c" file. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_TRY_C_COMPILE macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to the
   #  original AK_TRY_C_COMPILE macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_c_compile
   #
   #----------------------------------------------------------------------------

   sub mki_try_c_compile {
      my @params  = @_;
      my $N       = $#params + 1;
      print DBGOUT "mki_try_c_compile[ starting...\n" if $debugging;
      my $result  = 0;

      my $srcname = "";
      my $objname = "";
      my $incOpts = "";
      if ($N == 0) {
         $srcname = "konftest.c";
         $objname = "konftest.o";
         $ok      = 1;
      }
      elsif (1 <= $N) {
         $srcname = "$params[0]";
         $objname = $srcname;
         $objname =~ s/\.c$/.o/;
         my $i = 0;
         for ($i=1; $i<=$#params; ++$i) {
            if ($params[$i]) {
               $incOpts = $incOpts." " if $incOpts;
               $incOpts = $incOpts."-I".$params[$i];
            }
         }
         $ok      = 1;
      }
      else {
         $ok      = 0;
      }
      if ($ok) {
         if ( -f "$objname" ) {
            print DBGOUT "mki_try_c_compile: ...delete existing \"\"\n" if $debugging;
            while ( -f "$objname" ) {
               unlink("$objname");
            }
         }
         print DBGOUT "mki_try_c_compile: ...using $CC_pathname for the C compiler\n" if $debugging;
         if ($CC_pathname ne "") {
            print DBGOUT "mki_try_c_compile: ...compile \"$srcname\" to produce \"$objname\"\n" if $debugging;
            my $cmd = "$CC_pathname $incOpts -c $srcname";
            $cmd    = "$cmd >konftest.log 2>&1";
            print DBGOUT "mki_try_c_compile:    run [$cmd]\n" if $debugging;
            if (mki_run_command($cmd)) {
               print DBGOUT "mki_try_c_compile:    ...done\n" if $debugging;
               if ( -f "$objname" ) {
                  print DBGOUT "mki_try_c_compile:    found \"$objname\"\n" if $debugging;
                  $result = 1;
               }
               else {
                  print DBGOUT "mki_try_c_compile:    can't find \"$objname\"\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_try_c_compile:    ...failed\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_try_c_compile: ...don't know what compiler to use\n" if $debugging;
         }
         if ( ! $result) {
#           mki_c_dump_src_log("$srcname") if $debugging;
         }
      }
      print DBGOUT "mki_try_c_compile: ...cleanup\n" if $debugging;
      if (-f "konftest.log") {
         print DBGOUT "mki_try_c_compile:    \"konftest.log\"\n" if $debugging;
         unlink "konftest.log";
      }
      print DBGOUT "mki_try_c_compile] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an executable by using the C linker.
   #  Note that by default it will try to form an executable from the
   #  "konftest.o" file. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_TRY_C_LINK macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to the
   #  original AK_TRY_C_LINK macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_c_link
   #
   #----------------------------------------------------------------------------

   sub mki_try_c_link {
      print DBGOUT "mki_try_c_link[ starting...\n" if $debugging;
      my $result = 0;
      print DBGOUT "mki_try_c_link: ...compile\n" if $debugging;
      if (mki_try_c_compile()) {
         print DBGOUT "mki_try_c_link:    done\n" if $debugging;
         if ($CC_pathname ne "") {
            if ( -f "konftest" ) {
               print DBGOUT "mki_try_c_link: ...delete existing \"konftest\"\n" if $debugging;
               while ( -f "konftest" ) {
                  unlink("konftest");
               }
            }
            print DBGOUT "mki_try_c_compile: ...link \"konftest.o\" to produce \"konftest\"\n" if $debugging;
            my $cmd = "$CC_pathname -o konftest konftest.o >konftest.log 2>&1";
            print DBGOUT "mki_try_c_link:    run [$cmd]\n" if $debugging;
            if (mki_run_command($cmd)) {
               print DBGOUT "mki_try_c_link:    ...done\n" if $debugging;
               if ( -f "konftest" ) {
                  print DBGOUT "mki_try_c_link:    found \"konftest\"\n" if $debugging;
                  if ( -x "konftest" ) {
                     $result = 1;
                  }
                  else {
                     print DBGOUT "mki_try_c_link:    which isn't executable\n" if $debugging;
                  }
               }
               else {
                  print DBGOUT "mki_try_c_link:    can't find \"konftest\"\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_try_c_link:    ...failed\n" if $debugging;
            }
         }
         if ( ! $result) {
#           mki_c_dump_src_log() if $debugging;
         }
      }
      else {
         print DBGOUT "mki_try_c_link:    failed\n" if $debugging;
      }
      print DBGOUT "mki_try_c_link: ...cleanup\n" if $debugging;
      if (-f "konftest.log") {
         print DBGOUT "mki_try_c_link:    \"konftest.log\"\n" if $debugging;
         unlink "konftest.log";
      }
      print DBGOUT "mki_try_c_link] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an output file by compiling, linking and
   #  running the konftest.c source file. This is only done on Linux hosts.
   #  Note that this function was derived from the AK_TRY_C_RUN macro/function
   #  supplied with autokonf. Changes made to this function should be propagated
   #  to the original AK_TRY_C_RUN macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_c_run
   #
   #----------------------------------------------------------------------------

   sub mki_try_c_run {
      print DBGOUT "mki_try_c_run[ starting...\n" if $debugging;
      my $result = 0;
      print DBGOUT "mki_try_c_run: ...compile\n" if $debugging;
      if (mki_try_c_link()) {
         print DBGOUT "mki_try_c_run:    done\n" if $debugging;
         if ( -f "konftest.out" ) {
            print DBGOUT "mki_try_c_run: ...delete existing \"konftest.out\"\n" if $debugging;
            while ( -f "konftest.out" ) {
               unlink("konftest.out");
            }
         }
         if ( -f "konftest.log" ) {
            print DBGOUT "mki_try_c_run: ...delete existing \"konftest.log\"\n" if $debugging;
            while ( -f "konftest.log" ) {
               unlink("konftest.log");
            }
         }
         my $cmd = "konftest >konftest.out 2>konftest.log";
         print DBGOUT "mki_try_c_run:    run [$cmd]\n" if $debugging;
         if (mki_run_command($cmd)) {
            print DBGOUT "mki_try_c_run:    ...done\n" if $debugging;
            if ( -f "konftest.out" ) {
               print DBGOUT "mki_try_c_run:    found \"konftest.out\"\n" if $debugging;
               $result = 1;
            }
            else {
               print DBGOUT "mki_try_c_run:    can't find \"konftest.out\"\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_try_c_run:    ...failed\n" if $debugging;
         }
         if ( ! $result) {
#           mki_c_dump_src_log() if $debugging;
         }
      }
      else {
         print DBGOUT "mki_try_c_run:    failed\n" if $debugging;
      }
      print DBGOUT "mki_try_c_run: ...cleanup\n" if $debugging;
      if (-f "konftest.log") {
         print DBGOUT "mki_try_c_run:    \"konftest.log\"\n" if $debugging;
         unlink "konftest.log";
      }
      print DBGOUT "mki_try_c_run] ...done(=$result)\n" if $debugging;
      return $result;
   }

#}--------------------------------------

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an object file by using the C++ compiler.
   #  Note that by default it will try to form an object file from the
   #  "konftest.cxx" file. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_TRY_CXX_COMPILE macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to the
   #  original AK_TRY_CXX_COMPILE macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_cxx_compile
   #
   #----------------------------------------------------------------------------

   sub mki_try_cxx_compile {
      my @params  = @_;
      my $N       = $#params + 1;
      my $result  = 0;
      print DBGOUT "mki_try_cxx_compile[ starting...\n" if $debugging;

      my $ok      = 0;
      my $srcname = "";
      my $objname = "";
      if ($N == 0) {
         $srcname = "konftest.cxx";
         $objname = "konftest.o";
         $ok      = 1;
      }
      elsif ($N == 1) {
         $srcname = "$params[0]";
         $objname = $srcname;
         $objname =~ s/\.cxx$/.o/;
         $ok      = 1;
      }
      else {
         $ok      = 0;
      }
      if ($ok) {
         if ( -f "$objname" ) {
            print DBGOUT "mki_try_cxx_compile: ...delete existing \"$objname\"\n" if $debugging;
            while ( -f "$objname" ) {
               unlink("$objname");
            }
         }
         print DBGOUT "mki_try_cxx_compile: ...using $CXX_pathname for the C++ compiler\n" if $debugging;
         if ($CXX_pathname ne "") {
            print DBGOUT "mki_try_cxx_compile: ...compile \"$srcname\" to produce \"$objname\"\n" if $debugging;
            my $cmd = "$CXX_pathname -c $CXX_options $srcname";
            $cmd    = "$cmd >konftest.log 2>&1";
            print DBGOUT "mki_try_cxx_compile:    run [$cmd]\n" if $debugging;
            if (mki_run_command($cmd)) {
               print DBGOUT "mki_try_cxx_compile:    ...done\n" if $debugging;
               if ( -f $objname ) {
                  print DBGOUT "mki_try_cxx_compile:    found \"$objname\"\n" if $debugging;
                  $result = 1;
               }
               else {
                  print DBGOUT "mki_try_cxx_compile:    can't find \"$objname\"\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_try_cxx_compile:    ...failed\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_try_cxx_compile: ...don't know what compiler to use\n" if $debugging;
         }
         if ( ! $result) {
#           mki_cxx_dump_src_log("$srcname");
         }
      }

      print DBGOUT "mki_try_cxx_compile] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an executable by using the C++ linker.
   #  Note that by default it will try to form an executable from the
   #  "konftest.o" file. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_TRY_CXX_LINK macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to the
   #  original AK_TRY_CXX_LINK macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_cxx_link
   #
   #----------------------------------------------------------------------------

   sub mki_try_cxx_link {
      my @params = @_;
      my $N      = $#params + 1;
      print DBGOUT "mki_try_cxx_link[ starting...\n" if $debugging;
      my $result = 0;

      print DBGOUT "mki_try_cxx_link: ...compile\n" if $debugging;
      if (mki_try_cxx_compile()) {
         print DBGOUT "mki_try_cxx_link:    done\n" if $debugging;
         if ( -f "konftest" ) {
            print DBGOUT "mki_try_cxx_link: ...delete existing \"konftest\"\n" if $debugging;
            while ( -f "konftest" ) {
               unlink("konftest");
            }
         }
         my $cmd = "$CXX_pathname $CXX_options -o konftest konftest.o -lm";
         $cmd    = "$cmd >konftest.log 2>&1";
         print DBGOUT "mki_try_cxx_link: ...run [$cmd]\n" if $debugging;
         if (mki_run_command($cmd)) {
            print DBGOUT "mki_try_cxx_link:    done\n" if $debugging;
            if ( -f "konftest" ) {
               print DBGOUT "mki_try_cxx_link:    found \"konftest\"\n" if $debugging;
               if ( -x "konftest" ) {
                  print DBGOUT "mki_try_cxx_link:    which is executable\n" if $debugging;
                  $result = 1;
               }
               else {
                  print DBGOUT "mki_try_cxx_link:    which isn't executable\n" if $debugging;
               }
            }
            else {
               print DBGOUT "mki_try_cxx_link:    can't find \"konftest\"\n" if $debugging;
            }
         }
         else {
            print DBGOUT "mki_try_cxx_link:    failed\n" if $debugging;
         }
         if ( ! $result) {
#           mki_cxx_dump_src_log();
         }
      }
      else {
         print DBGOUT "mki_try_cxx_link:    failed\n" if $debugging;
      }
      print DBGOUT "mki_try_cxx_link] ...done(=$result)\n" if $debugging;
      return $result;
   }

#}= cut here ========================================================================================================== cut here ===
}

# MyUniqueFileId: d1e4e179-f5ab-4da0-a4b3-3904cdc4feb2
#-------------------------------------------------------------------------------
#
#  This subroutine is used to translate a relative pathname to an absolute
#  pathname.
#
#  This function uses: pKit_fixpath(),
#                      pKit_getOSclass(),
#                      pKit_getWorkingDirectory(),
#                      pKit_joinpath()
#
#  see: totebag/src/pKit/absoluteOf.psub
#
#  Dated: 01Jul2020 pKit_absoluteOf
#
#-------------------------------------------------------------------------------

sub pKit_absoluteOf {
   my $pathname    = shift;
   print DBGOUT "pKit_absoluteOf[ pathname=\"$pathname\"...\n" if $debugging;
   my $result      = "";
   my $driveLetter = "";
   my $changed     = $pathname =~ tr/\\/\//;
   if ($debugging && (1 <= $changed)) {
      print DBGOUT "pKit_absoluteOf: ...adjusted slashing to \"$pathname\"\n" if $debugging;
   }
   #
   #  Remove and hold on to the drive letter if there is one (only on
   #  Windows of course).
   #
   if (pKit_getOSclass() eq "UNIX-like") {
      print DBGOUT "pKit_absoluteOf: ...UNIX-like\n" if $debugging;
      $driveLetter = "";
      print DBGOUT "pKit_absoluteOf:    without drive\"\n" if $debugging;
   }
   elsif (pKit_getOSclass() eq "Windows-like") {
      print DBGOUT "pKit_absoluteOf: ...Windows-like\n" if $debugging;
      if ($pathname =~ /^([a-zA-Z]):(.*)$/) {
         $driveLetter = $1;
         $pathname    = $2;
         print DBGOUT "pKit_absoluteOf:    with drive = \"$drive\"\n" if $debugging;
         print DBGOUT "pKit_absoluteOf:      pathname = \"$pathname\"\n" if $debugging;
      }
      elsif ($pathname =~ /^\/([a-zA-Z])(\/.*)$/) {
         $driveLetter = $1;
         $pathname    = $2;
         print DBGOUT "pKit_absoluteOf:    with drive = \"$drive\"\n" if $debugging;
         print DBGOUT "pKit_absoluteOf:      pathname = \"$pathname\"\n" if $debugging;
      }
      elsif ($pathname =~ /^\/cygdrive\/([a-zA-Z])(\/.*)$/) {
         $driveLetter = $1;
         $pathname    = $2;
         print DBGOUT "pKit_absoluteOf:    with drive = \"$drive\"\n" if $debugging;
         print DBGOUT "pKit_absoluteOf:      pathname = \"$pathname\"\n" if $debugging;
      }
      else {
         $driveLetter = "";
         print DBGOUT "pKit_absoluteOf:    without drive\"\n" if $debugging;
      }
   }
   else {
      print DBGOUT "pKit_absoluteOf: ...is neither UNIX- nor Windows-like\n" if $debugging;
      $driveLetter = "";
      print DBGOUT "pKit_absoluteOf:    assume no drive\"\n" if $debugging;
   }
   if ($pathname =~ /^\//) {
      print DBGOUT "pKit_absoluteOf: ...looks absolute\n" if $debugging;
      $result   = $pathname;
   }
   else {
      print DBGOUT "pKit_absoluteOf: ...looks relative\n" if $debugging;
      my $here  = pKit_getWorkingDirectory();
      print DBGOUT "pKit_absoluteOf:    to \"$here\"\n" if $debugging;
      $result   = pKit_joinpath($here,$pathname);
   }
   $result      = pKit_fixpath($result);
   #
   #  Re-attach drive letter if necessary.
   #
   if ($driveLetter ne "") {
      $result = $driveLetter.":".$result;
   }
   if ($changed) {
      $result =~ tr/\//\\/;
      print DBGOUT "pKit_absoluteOf: ...adjusted back to \"$result\"\n" if $debugging;
   }
   print DBGOUT "pKit_absoluteOf] ...done(=\"$result\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: b6ad466e-02ec-4fe0-d32d-770350efae70
#-------------------------------------------------------------------------------
#
#  Check if pathname is on the search path.
#
#  This function is used to check if a given pathname (string) is already in a
#  given array of pathnames (such as found in the PATH environment variable or
#  returned by the pKit_getTheSearchPATH() function). Note that the second parameter
#  is expected to be a reference to an array of strings (pathnames). Simple
#  example:
#
#     $myPATH = pKit_getTheSearchPATH();
#     @myPATH = pKit_splitTheSearchPATH($myPATH);
#     if ( ! pKit_alreadyOnSearchPATH($dirPathname,\@myPATH)) {
#        @myPATH = pKit_prependToSearchPATH($dirPathname,\@myPATH);
#        $myPATH = pKit_joinTheSearchPATH(\@myPATH);
#     }
#
#  calls: pKit_getOSclass(),
#         pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/alreadyOnSearchPATH.psub
#
#  Dated: 04Jul2020 pKit_alreadyOnSearchPATH
#
#-------------------------------------------------------------------------------

sub pKit_alreadyOnSearchPATH {
   my $pathname   = shift;   # A pathname to prepend.
   my $refMyPATH  = shift;   # A reference to an array of pathnames
   my $theOSclass = shift;   # ...an optional parameter
   print DBGOUT "pKit_alreadyOnSearchPATH[ pathname=\"$pathname\", refMyPATH=..., theOSclass=\"$theOSclass\"...\n" if $debugging;
   my $isOnPATH   = 0;
   if (ref($refMyPATH) eq "ARRAY") {
      if ($pathname ne "") {
         #
         #  Adjust pathname if necessary...
         #
         if ($theOSclass eq "") {
            $theOSclass = pKit_getOSclass();
            print DBGOUT "pKit_alreadyOnSearchPATH: ...assume \"$theOSclass\"\n" if $debugging;
         }
         if ($theOSclass eq "Windows-like") {
            $pathname = pKit_makePathWindowslike($pathname);
            print DBGOUT "pKit_alreadyOnSearchPATH: ...adjusted pathname to \"$pathname\"\n" if $debugging;
         }
         #
         #  ...then scan through the array...
         #
         print DBGOUT "pKit_alreadyOnSearchPATH: ...scan through PATH\n" if $debugging;
         my $Nelems = @$refMyPATH;
         my $i;
         for ($i=0; $i<$Nelems; ++$i) {
            print DBGOUT "pKit_alreadyOnSearchPATH:    \"".$$refMyPATH[$i]."\"\n" if $debugging;
            if ($$refMyPATH[$i] eq $pathname) {
               $isOnPATH = 1;
               print DBGOUT "pKit_alreadyOnSearchPATH:    ...found\n" if $debugging;
               last;
            }
         }
         print DBGOUT "pKit_alreadyOnSearchPATH:    ...NOT found\n" if ($debugging && ! $isOnPATH);
      }
   }
   print DBGOUT "pKit_alreadyOnSearchPATH] ...done(=$isOnPATH)\n" if $debugging;
   return $isOnPATH;
}

# MyUniqueFileId: c16cf2c9-02f4-48a7-bf6f-6d74697af801
#-------------------------------------------------------------------------------
#
#  Basename from pathname.
#
#  This function is used to extract the basename (the final component) from a
#  given pathname. Note that this kind of operation is generally available in
#  the File module.
#
#  This function uses: pKit_fixpath()
#
#  see: totebag/src/pKit/basename.psub
#
#  Dated: 04Jul2020 pKit_basename
#
#-------------------------------------------------------------------------------

sub pKit_basename {
   my $pathname = shift(@_);
   print DBGOUT "pKit_basename[ pathname=\"$pathname\"...\n" if $debugging;
   my $result   = "";
   my $adjusted = pKit_fixpath($pathname);
   if ($adjusted ne $pathname) {
      print DBGOUT "pKit_basename: ...normalized to \"$adjusted\"\n" if $debugging;
   }
   $_           = $adjusted;
   parse: {
             /^(.+)[\/\\]([^\/\\]*)$/

                && do {
                   $result = $2;
                   print DBGOUT "pKit_basename: ...case 1\n" if $debugging;
                   last;
                };

             /^[\/\\]([^\/\\]*)$/

                && do {
                   $result = $1;
                   print DBGOUT "pKit_basename: ...case 2\n" if $debugging;
                   last;
                };

             /^([^\/\\]*)$/

                && do {
                   $result = $1;
                   print DBGOUT "pKit_basename: ...case 3\n" if $debugging;
                   last;
                };

          }
   print DBGOUT "pKit_basename] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: a237e8e4-1371-49f0-da30-aad98b482e1f
#-------------------------------------------------------------------------------
#
#  pKit_convertTimeToDateTime
#
#  Converts a time number (seconds since epoc) to a date time string in one
#  of several standard formats. This function relies on the built-in gmtime()
#  and localtime() functions. Takes up to 3 parameters:
#
#     givenTime  The given time number (seconds since epoc).
#
#     format     One of:
#
#                   "dense"     YYYYMMDDhhmmss         similar to: zulu (with no options)
#                   "std"       DDMMMYYYY hh:mm:ss     similar to: zulu --revision
#                   "std-at"    DDMMMYYYY at hh:mm:ss  similar to: zulu --revision but with "at"
#                   "std-comma" DDMMMYYYY,hh:mm:ss     similar to: zulu --revision but with a comma
#                   "verbose"   YYYY-MM-DD,hh:mm:ss    similar to: zulu -v
#
#     asLocal    A "boolean", if 1 then the output string is to be in local
#                time. Default is UTC (aka zulu). You can use "gmt", "local",
#                "utc", or "zulu".
#
#  see: totebag/src/pKit/convertTimeToDateTime.psub
#
#  Dated: 01Jul2020 pKit_convertTimeToDateTime
#
#-------------------------------------------------------------------------------

sub pKit_convertTimeToDateTime {
   my $givenTime = shift;
   my $format    = shift;
   my $asLocal   = shift;

   my $result    = "";

   my @month     = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
   my $doingTime = int($givenTime);
   my $sec;
   my $min;
   my $hour;
   my $mday;
   my $mon;
   my $year;
   my $wday;
   my $yday;
   my $isdat;
   my $suffix;
   my $tz;

   my $ok;
   if ($asLocal =~ /^\d+$/) {
      if ($asLocal == 0) {
         $asLocal = 0;
      }
      else {
         $asLocal = 1;
      }
      $ok         = 1;
   }
   else {
      my $stringy = $asLocal;
      if ($stringy =~ /^local$/i) {
         $asLocal = 1;
         $ok      = 1;
      }
      elsif ($stringy =~ /^gmt$/i) {
         $asLocal = 0;
         $ok      = 1;
      }
      elsif ($stringy =~ /^utc$/i) {
         $asLocal = 0;
         $ok      = 1;
      }
      elsif ($stringy =~ /^zulu$/i) {
         $asLocal = 0;
         $ok      = 1;
      }
      else {
         $asLocal = 0;
         $ok      = 0;
      }
   }

   if ($asLocal) {
      ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdat) = localtime($doingTime);
      $tz = "";
   }
   else {
      ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdat) = gmtime($doingTime);
      $tz = "z";
   }
   my $theYear  = $year + 1900;
   my $theMonth = $month[$mon];

   if ($format =~ /^std$/i) {
      $result  = sprintf "%02d%3s%04d %02d:%02d:%02d$tz", $mday,$theMonth,$theYear, $hour,$min,$sec;
   }
   elsif ($format =~ /^std-at$/i) {
      $result  = sprintf "%02d%3s%04d at %02d:%02d:%02d$tz", $mday,$theMonth,$theYear, $hour,$min,$sec;
   }
   elsif ($format =~ /^std-comma$/i) {
      $result  = sprintf "%02d%3s%04d,%02d:%02d:%02d$tz", $mday,$theMonth,$theYear, $hour,$min,$sec;
   }
   elsif ($format =~ /^verbose$/i) {
      $result  = sprintf "%04d-%02d-%02d,%02d:%02d:%02d$tz", $theYear,$mon+1,$mday, $hour,$min,$sec;
   }
   else { # "dense" falls through to here
      $result  = sprintf "%04d%02d%02d%02d%02d%02d", $theYear,$mon+1,$mday, $hour,$min,$sec;
   }
   return $result;
}

# MyUniqueFileId: 57febf05-5939-4d9f-d57a-0d9531fe0948
#-------------------------------------------------------------------------------
#
#  This subroutine deletes one or more directories and all of the content.
#  Note that it is assumed that a directory tree only contains directories,
#  files, and/or symbolic-links. An array of pathnames that could not be
#  deleted is returned.
#
#  Note: This function appears to be a lot more complex than necessary. It
#        not only requests that given pathnames (and recursive contents) be
#        removed, it also checks to see that it's all gone (returning any
#        remaining pathnames). The real problem here is that NFS can get in
#        the way by inserting temporary .nfsXXX..XXX files. This can prevent
#        a what should be empty directory from being removed (it doesn't look
#        empty).
#
#  This function uses: pKit_basename(),
#                      pKit_getOSclass(),
#                      pKit_getWorkingDirectory(),
#                      pKit_joinpath()
#
#  see: totebag/src/pKit/deletePathnames.psub
#
#  Dated: 04Jul2020 pKit_deletePathnames
#
#-------------------------------------------------------------------------------

sub pKit_deletePathnames {
   my @failures  = ( );
   my $Nfailures = 0;
   my $dummy;
   my $rootPathname;
   foreach $rootPathname (@_) {
      my $oldCount = -1;
      my $newCount = 0;
      if ($rootPathname ne "") {
         #---------------------------------------
         #
         #  We first recursively crawl the directory
         #  tree forming a list of pathnames that
         #  appear to exist. The size of this list
         #  also serves as the initial pathname
         #  count; we'll be watching the pathname
         #  count -- looping while it continues
         #  to shrink or becomes empty
         #
         #---------------------------------------
         my @pathnames  = ();
         my $rootExists = 0;
         if ( -l $rootPathname) {
            $rootExists = 1;
         }
         elsif ( -e $rootPathname) {
            $rootExists = 1;
         }
         if ($rootExists) {
            my $idx          = $#pathnames + 1;
            $pathnames[$idx] = $rootPathname;
            my $i;
            for ($i=0; $i<=$#pathnames; ++$i) {
               my $pathname = $pathnames[$i];
               if ( -l $pathname) {
                  $dummy = 1;
               }
               elsif ( -f $pathname) {
                  $dummy = 1;
               }
               elsif ( -d $pathname ) {
                  if (! opendir(DIR,$pathname)) {
                     print STDERR $sponsor."can't read directory \"$pathname\"\n" if $sponsor;
                     $result = 0;
                  }
                  else {
                     while (defined($tmp = readdir(DIR))) {
                        if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                           my $idx          = $#pathnames + 1;
                           $pathnames[$idx] = pKit_joinpath($pathnames[$i],"$tmp");
                        }
                     }
                     closedir(DIR);
                  }
               }
            }
         }
         $oldCount = $#pathnames + 1;
         if ($oldCount == 1) {
            $dummy = 1;
         }
         else {
            $dummy = 1;
         }
         if (1 <= $oldCount) {
            my $cycle = 0;
            my $done  = 0;
            while ( ! $done) {
               my $haveNFS  = 0;
               $cycle      += 1;
               #---------------------------------------
               #
               #  Use the pathnames list to remove things.
               #  Once we've gone through the list, we'll
               #  rebuild the list and check for a change
               #  in the list size. We'll loop so long as
               #  the list shrinks or until it becomes
               #  empty.
               #
               #---------------------------------------
               if (pKit_getOSclass() eq "UNIX-like") {
                  #---------------------------------------
                  #
                  #  If this is a UNIX-like" system, try
                  #  using rm to delete each in the list.
                  #  Note that this is done in a bottom-up
                  #  fashion so that directory content is
                  #  removed before the directory.
                  #
                  #---------------------------------------
                  for ($i=$#pathnames; 0<=$i; $i--) {
                     my $pathname   = $pathnames[$i];
                     my $stillThere = 0;
                     if ( -l $pathname) {
                        $stillThere = 1;
                     }
                     elsif ( -e $pathname) {
                        $stillThere = 1;
                     }
                     else {
                        $stillThere = 0;
                     }
                     if ($stillThere) {
                        my $bn = pKit_basename($pathname);
                        if ($bn =~ /^\.nfs[^\/]*$/) {
                           $haveNFS = 1;
                        }
                        my $cmd      = "rm -rf \"$pathname\"";
                        my $status   = system "$cmd >/dev/null 2>&1";
                        if ($status != 0) {
                           my $code = $status >> 8;
                           if ($status & 127) {
                              my $signum = $status & 127;
                           }
                           if ($status & 127) {
                              $dummy = 1;
                           }
                        }
                     }
                  }
               }
               #---------------------------------------
               #
               #  Now we go through the list and use
               #  Perl rmdir() and/or unlink() functions
               #  to delete things. Note that this is
               #  done in a bottom-up fashion so that
               #  directory content is removed before
               #  the directory.
               #
               #---------------------------------------
               for ($i=$#pathnames; 0<=$i; $i--) {
                  my $pathname = $pathnames[$i];
                  my $bn       = pKit_basename($pathname);
                  if ($bn =~ /^\.nfs[^\/]*$/) {
                     $haveNFS = 1;
                  }
                  if ( -l $pathname) {
                     if ( ! unlink($pathname)) {
                        $dummy = 1;
                     }
                  }
                  elsif ( -d $pathname) {
                     if ( ! rmdir($pathname)) {
                        $dummy = 1;
                     }
                  }
                  elsif ( -f $pathname) {
                     if ( ! unlink($pathname)) {
                        $dummy = 1;
                     }
                  }
                  elsif ( -e $pathname) {
                     if ( ! unlink($pathname)) {
                        $dummy = 1;
                     }
                  }
               }
               if (2 <= $cycle) {
                  if ($haveNFS) {
                     my $moved = 0;
                     my $here  = pKit_getWorkingDirectory();
                     if ($here ne "") {
                        if (chdir("/")) {
                           $moved = 1;
                        }
                     }
                     sleep 61;
                     if ($moved) {
                        if ( ! chdir($here)) {
                           $dummy = 1;
                        }
                     }
                  }
               }
               #---------------------------------------
               #
               #  We again recursively crawl the directory
               #  tree to rebuild the list of pathnames
               #  that still appear to exist. We keep
               #  looping while it continues to shrink.
               #
               #---------------------------------------
               @pathnames     = ();
               my $rootExists = 0;
               if ( -l $rootPathname) {
                  $rootExists = 1;
               }
               elsif ( -e $rootPathname) {
                  $rootExists = 1;
               }
               if ($rootExists) {
                  my $idx          = $#pathnames + 1;
                  $pathnames[$idx] = $rootPathname;
                  my $i;
                  for ($i=0; $i<=$#pathnames; ++$i) {
                     my $pathname = $pathnames[$i];
                     if ( -l $pathname) {
                        $dummy = 1;
                     }
                     elsif ( -f $pathname) {
                        $dummy = 1;
                     }
                     elsif ( -d $pathname ) {
                        if (! opendir(DIR,$pathname)) {
                           print STDERR $sponsor."can't read directory \"$pathname\"\n" if $sponsor;
                           $result = 0;
                        }
                        else {
                           while (defined($tmp = readdir(DIR))) {
                              if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                                 my $idx          = $#pathnames + 1;
                                 $pathnames[$idx] = pKit_joinpath($pathnames[$i],"$tmp");
                              }
                           }
                           closedir(DIR);
                        }
                     }
                  }
               }
               $newCount = $#pathnames + 1;
               if (($newCount <= 0) || ($oldCount <= $newCount)) {
                  $done  = 1;
               }
               else {
                  $oldCount = $newCount;
                  $newCount = 0;
                  $done     = 0;
               }
            }
            #---------------------------------------
            #
            #  Add any leftovers to the failure list.
            #  This is the last chance to see if
            #  something has disappeared.
            #
            #---------------------------------------
            for ($i=0; $i<=$#pathnames; ++$i) {
               my $pathname    = $pathnames[$i];
               my $stillExists = 0;
               if ( -l $pathname) {
                  $stillExists = 1;
               }
               elsif ( -d $pathname) {
                  $stillExists = 1;
               }
               elsif ( -f $pathname) {
                  $stillExists = 1;
               }
               elsif ( -e $pathname) {
                  $stillExists = 1;
               }
               else {
                  $stillExists = 0;
               }
               if ($stillExists) {
                  my $idx         = $#failures + 1;
                  $failures[$idx] = $pathname;
                  $Nfailures     += 1;
               }
            }
         }
      }
   }
   return @failures;
}

# MyUniqueFileId: 8beb72f4-0e19-46e2-effb-336240c9fb42
#-------------------------------------------------------------------------------
#
#  Dirname of pathname.
#
#  This function is used to extract the directory name (all but the final
#  component) from a given pathname. Note that this kind of operation is
#  generally available in the File module.
#
#  This function uses: pKit_fixpath(),
#                      pKit_getOSclass()
#
#  see: totebag/src/pKit/dirname.psub
#
#  Dated: 04Jul2020 pKit_dirname
#
#-------------------------------------------------------------------------------

sub pKit_dirname {
   my $pathname    = shift;
   my $osClass     = shift;
   print DBGOUT "pKit_dirname[ pathname=\"$pathname\", osClass=\"$osClass\"...\n" if $debugging;
   if ($osClass eq "") {
      $osClass     = pKit_getOSclass();
      print DBGOUT "pKit_dirname: ...host is actually \"$osClass\"\n" if $debugging;
   }
   my $result      = "";
   my $driveLetter = "";
   my $changed     = $pathname =~ tr/\\/\//;
   if ($debugging && (1 <= $changed)) {
      print DBGOUT "pKit_dirname: ...adjusted slashing to \"$pathname\"\n" if $debugging;
   }
   if ($osClass eq "Windows-like") {
      print DBGOUT "pKit_dirname: ...host is \"Windows-like\"\n" if $debugging;
      #---------------------------------------
      #
      #  Remove drive name if there is one
      #
      if ($pathname =~ /^([a-zA-Z]):(.*)$/) {
         $driveLetter = $1;
         $pathname    = $2;
         print DBGOUT "pKit_dirname:    a Windows-style pathname\n" if $debugging;
         print DBGOUT "pKit_dirname:    ...with drive \"".$driveLetter."\"\n" if $debugging;
         print DBGOUT "pKit_dirname:         and path \"".$pathname."\"\n" if $debugging;
      }
      elsif ($pathname =~ /^[\/\\]([a-zA-Z])([\/\\].*)$/) {
         $driveLetter = $1;
         $pathname    = $2;
         print DBGOUT "pKit_dirname:    an \"A\" cygwin-style pathname\n" if $debugging;
         print DBGOUT "pKit_dirname:    ...with drive \"".$driveLetter."\"\n" if $debugging;
         print DBGOUT "pKit_dirname:         and path \"".$pathname."\"\n" if $debugging;
      }
      elsif ($pathname =~ /^[\/\\]cygdrive[\/\\]([a-zA-Z])([\/\\].*)$/) {
         $driveLetter = $1;
         $pathname    = $2;
         print DBGOUT "pKit_dirname:    a \"B\" cygwin-style pathname\n" if $debugging;
         print DBGOUT "pKit_dirname:    ...with drive \"".$driveLetter."\"\n" if $debugging;
         print DBGOUT "pKit_dirname:         and path \"".$pathname."\"\n" if $debugging;
      }
      else {
         print DBGOUT "pKit_dirname:    no drive letter\n" if $debugging;
      }
   }
   my $adjusted    = pKit_fixpath($pathname);
   if ($debugging && ($adjusted ne $pathname)) {
      print DBGOUT "pKit_dirname: ...normalized to \"$adjusted\"\n" if $debugging;
   }
   $_              = $adjusted;
   parse: {
             /^(.+)[\/\\]([^\/\\]*)$/

                && do {
                   $result = $1;
                   print DBGOUT "pKit_dirname: ...case 1\n" if $debugging;
                   last;
                };

             /^([\/\\])([^\/\\]*)$/

                && do {
                   $result = $1;
                   print DBGOUT "pKit_dirname: ...case 2\n" if $debugging;
                   last;
                };

             /^([^\/\\]*)$/

                && do {
                   $result = ".";
                   print DBGOUT "pKit_dirname: ...case 3\n" if $debugging;
                   last;
                };

          }
   #---------------------------------------
   #
   #  Restore drive name if there was one
   #  and change back to backslashes if
   #  we originally had backslashes.
   #
   if ($driveLetter ne "") {
      $result = $driveLetter.":".$result;
   }
   if (1 <= $changed) {
      $result =~ tr/\//\\/;
      print DBGOUT "pKit_dirname: ...adjusted back to \"$result\"\n" if $debugging;
   }
   print DBGOUT "pKit_dirname] ...done(=\"$result\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: 6bb0cd9e-b6df-45f6-f4be-5a02b981125c
#-------------------------------------------------------------------------------
#
#  Dumping a textfile to some open file handle (such as STDERR).
#
#  This function expects 3 parameters: A file handle, a pathname (the file
#  whose contents are to be "dumped" to the handle), and a string which is
#  to prefix each line from the file when sent to the file handle.
#
#  see: totebag/src/pKit/dumpTextfileToHandle.psub
#
#  Dated: 01Jul2020 pKit_dumpTextfileToHandle
#
#-------------------------------------------------------------------------------

sub pKit_dumpTextfileToHandle {
   local (*FH,$pathname,$prefix) = @_;
   my $result;
   if ( -f $pathname) {
      if (open(TEXTFILE,"< $pathname")) {
         while (<TEXTFILE>) {
            chomp; s/\r$//;
            print FH $prefix.$_."\n";
         }
         close TEXTFILE;
         $result = 1;
      }
      else {
         $result = 0;
      }
   }
   else {
      $result = 0;
   }
   return $result;
}

# MyUniqueFileId: 4c7957a2-61c8-4577-fb4f-1bc45e17d6c3
#-------------------------------------------------------------------------------
#
#  Dumping a textfile to <stderr>
#
#  This function uses: pKit_dumpTextfileToHandle()
#
#  see: totebag/src/pKit/dumpTextfileToSTDERR.psub
#
#  Dated: 01Jul2020 pKit_dumpTextfileToSTDERR
#
#-------------------------------------------------------------------------------

sub pKit_dumpTextfileToSTDERR {
   my $pathname  = shift;
   my $prefix    = shift;
   return pKit_dumpTextfileToHandle(*STDERR,$pathname,$prefix);
}

# MyUniqueFileId: 069ff9f8-9601-463c-ccd1-a1486a5cce42
#-------------------------------------------------------------------------------
#
#  Find all directories in a directory tree.
#
#  This function recursively traverses the directory tree rooted with the given
#  pathname locating and returning an array of small hashes (ie. structs) that
#  represent info about directories in the tree (including the root directory).
#  Note that the first element of this array isn't such a struct but an integer
#  value: 1 -- success, 0 -- failure.
#
#  Each element e of the returned array is a "struct" with 8 components:
#
#     $return[$e]{"name"}              The full pathname of the directory
#     $return[$e]{"type"}              The string "directory"
#     $return[$e]{"NbrokenSymLinks"}   An integer -- the number of broken symbolic-links in this directory
#     $return[$e]{"Ndirectories"}      An integer -- the number of sub-directories in this directory
#     $return[$e]{"Nfiles"}            An integer -- the number of files in this directory
#     $return[$e]{"Nothers"}           An integer -- the number of other things in this directory
#     $return[$e]{"NsymbolicLinks"}    An integer -- the number of symbolic-links in this directory
#     $return[$e]{"ok"}                An integer -- 0 or 1 (could directory be read?)
#
#  This function uses: pKit_fixpath(),
#                      pKit_getOSclass(),
#                      pKit_joinpath(),
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/findAllSubdirs.psub
#
#  Dated: 01Jul2020 pKit_findAllSubdirs
#
#-------------------------------------------------------------------------------

sub pKit_findAllSubdirs {
   my $pathname           = shift;
   my $sponsor            = shift;
   print DBGOUT "pKit_findAllSubdirs[ pathname=\"$pathname\", sponsor=\"$sponsor\"...\n" if $debugging;
   if (pKit_getOSclass() eq "Windows-like") {
      if ($pathname =~ /[\/\\]/) {
         my $p = pKit_makePathWindowslike($pathname);
         if ($p ne $pathname) {
            $pathname = $p;
            print DBGOUT "pKit_findAllSubdirs: ...adjusted pathname to \"$pathname\"\n" if $debugging;
         }
      }
   }
   my @result             = ( );
   $result[0]             = 1;
   print DBGOUT "pKit_findAllSubdirs: ...requirements appear ok\n";
   if ( ! -l $pathname) {
      if ( -d $pathname) {
         print DBGOUT "pKit_findAllSubdirs: ...\"$pathname\" is a directory\n" if $debugging;
         my @theRawList            = ( );

         print DBGOUT "pKit_findAllSubdirs:    scan directory tree\n" if $debugging;
         my $idx                              = $#theRawList + 1;
         $theRawList[$idx]{"name"}            = $pathname;
         $theRawList[$idx]{"type"}            = "directory";
         $theRawList[$idx]{"NbrokenSymLinks"} = 0;
         $theRawList[$idx]{"Ndirectories"}    = 0;
         $theRawList[$idx]{"Nfiles"}          = 0;
         $theRawList[$idx]{"Nothers"}         = 0;
         $theRawList[$idx]{"NsymbolicLinks"}  = 0;
         $theRawList[$idx]{"ok"}              = -1;
         {
            my $i;
            for ($i=0; $i<=$#theRawList; $i++) {
               my $thePathname = $theRawList[$i]{"name"};
               my $theType     = $theRawList[$i]{"type"};
               $thePathname    = pKit_fixpath($thePathname);
               print DBGOUT "pKit_findAllSubdirs:    ...consider \"$thePathname\"\n" if $debugging;
               if ( -l $thePathname ) {
                  $theRawList[$i]{"type"} = "symbolic-link";
                  if ( -e $thePathname ) {
                     $theRawList[$i]{"ok"}   = 1;
                     print DBGOUT "pKit_findAllSubdirs:       a symbolic-link\n" if $debugging;
                  }
                  else {
                     $theRawList[$i]{"ok"}   = 0;
                     print DBGOUT "pKit_findAllSubdirs:       a broken symbolic-link\n" if $debugging;
                  }
               }
               elsif ( -f $thePathname ) {
                  $theRawList[$i]{"type"} = "file";
                  $theRawList[$i]{"ok"}   = 1;
                  print DBGOUT "pKit_findAllSubdirs:       a file\n" if $debugging;
               }
               elsif ( -d $thePathname ) {
                  print DBGOUT "pKit_findAllSubdirs:       a directory\n" if $debugging;
                  $theRawList[$i]{"type"}  = "directory";
                  print DBGOUT "pKit_findAllSubdirs:       ...scan this sub-directory\n" if $debugging;
                  if (opendir(DIR,"$thePathname")) {
                     $theRawList[$i]{"ok"} = 1;
                     my $NbrokenSymLinks   = 0;
                     my $Ndirectories      = 0;
                     my $Nfiles            = 0;
                     my $Nothers           = 0;
                     my $NsymbolicLinks    = 0;
                     my $tmpName;
                     while (defined($tmpName = readdir(DIR))) {
                        if ($tmpName ne "" ) {
                           if (($tmpName ne ".") && ($tmpName ne "..")) {
                              print DBGOUT "pKit_findAllSubdirs:          \"$tmpName\"\n" if $debugging;
                              my $joinName                         = pKit_fixpath(pKit_joinpath($thePathname,$tmpName));
                              my $idx                              = $#theRawList + 1;
                              $theRawList[$idx]{"name"}            = $joinName;
                              $theRawList[$idx]{"type"}            = "unknown";
                              $theRawList[$idx]{"NbrokenSymLinks"} = 0;
                              $theRawList[$idx]{"Ndirectories"}    = 0;
                              $theRawList[$idx]{"Nfiles"}          = 0;
                              $theRawList[$idx]{"Nothers"}         = 0;
                              $theRawList[$idx]{"NsymbolicLinks"}  = 0;
                              $theRawList[$idx]{"ok"}              = -1;
                              if ( -l $joinName) {
                                 $theRawList[$idx]{"type"}         = "symbolic-link";
                                 if ( -e $joinName) {
                                    $NsymbolicLinks               += 1;
                                 }
                                 else {
                                    $NbrokenSymLinks              += 1;
                                 }
                              }
                              else {
                                 if ( -d $joinName) {
                                    $theRawList[$idx]{"type"}      = "directory";
                                    $Ndirectories                 += 1;
                                 }
                                 elsif ( -f $joinName) {
                                    $theRawList[$idx]{"type"}      = "file";
                                    $Nfiles                       += 1;
                                 }
                                 else {
                                    $theRawList[$idx]{"type"}      = "other";
                                    $Nothers                      += 1;
                                 }
                              }
                           }
                        }
                        else {
                           last;
                        }
                     }
                     closedir(DIR);
                     $theRawList[$i]{"NbrokenSymLinks"} = $NbrokenSymLinks;
                     $theRawList[$i]{"Ndirectories"}    = $Ndirectories;
                     $theRawList[$i]{"Nfiles"}          = $Nfiles;
                     $theRawList[$i]{"Nothers"}         = $Nothers;
                     $theRawList[$i]{"NsymbolicLinks"}  = $NsymbolicLinks;
                  }
                  else {
                     $theRawList[$i]{"ok"}             = 0;
                     if ($sponsor ne "") {
                        print STDERR $sponsor.": error: can't read \"$thePathname\"\n";
                     }
                     $result[0] = 0;
                  }
               }
               else {
                  $theRawList[$i]{"type"} = "other";
                  $theRawList[$i]{"ok"}   = 1;
                  print DBGOUT "pKit_findAllSubdirs:       not a file, directory or symbolic-link\n" if $debugging;
               }
            }
            print DBGOUT "pKit_findAllSubdirs:    ...done\n" if $debugging;
         }
         print DBGOUT "pKit_findAllSubdirs:    collect each directory\n" if $debugging;
         {
            my $i;
            for ($i=0; $i<=$#theRawList; $i++) {
               my $thePathname  = $theRawList[$i]{"name"};
               my $theType      = $theRawList[$i]{"type"};
               $thePathname     = pKit_fixpath($thePathname);
               if ($theType eq "directory") {
                  print DBGOUT "pKit_findAllSubdirs:       \"$thePathname\"\n" if $debugging;
                  my $idx       = $#result + 1;
                  $result[$idx] = $theRawList[$i];
               }
            }
         }
      }
      else {
         print DBGOUT "pKit_findAllSubdirs: ...\"$pathname\" is NOT a directory\n" if $debugging;
      }
   }
   else {
      print DBGOUT "pKit_findAllSubdirs: ...\"$pathname\" is a symbolic-link\n" if $debugging;
   }
   print DBGOUT "pKit_findAllSubdirs] ...done(=".$result[0].")\n" if $debugging;
   return @result;
}

# MyUniqueFileId: 5d2ae091-e40c-43d2-e81f-811e7bdf3ef7
#--------------------------------------------------------------------------------
#
#  Use the appropriate environment variable(s) to figure-out where the home
#  directory of the user is...
#
#     1) Try HOME environment variable
#     2) Try HOMEDRIVE and HOMEPATH environment variables
#     3) Try USERPROFILE environment variable
#
#  Note that last two cases: 2 and 3 are only applicable on Windows-like hosts.
#
#  This function uses: pKit_getOSclass(),
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/findHomeDirectory.psub
#
#  Dated: 04Jul2020 pKit_findHomeDirectory
#
#--------------------------------------------------------------------------------

sub pKit_findHomeDirectory {
   print DBGOUT "pKit_findHomeDirectory[ starting...\n" if $debugging;
   my $homeDir = "";
   #---------------------------------------
   #
   #  First try HOME environment variable...
   #
   if ($homeDir eq "") {
      if ( exists $ENV{'HOME'}) {
         my $HOME   = $ENV{'HOME'};
         print DBGOUT "pKit_findHomeDirectory: ...HOME is \"$HOME\"\n" if $debugging;
         my $trydir = $HOME;
         if (pKit_getOSclass() eq "Windows-like") {
            $trydir = pKit_makePathWindowslike($trydir);
         }
         print DBGOUT "pKit_findHomeDirectory: ...consider \"$trydir\"\n" if $debugging;
         if ( -d $trydir) {
            $homeDir = $trydir;
            print DBGOUT "pKit_findHomeDirectory:    found\n" if $debugging;
         }
         else {
            print DBGOUT "pKit_findHomeDirectory:    NOT found\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_findHomeDirectory: ...HOME is not defined\n" if $debugging;
      }
   }
   #---------------------------------------
   #
   #  ...then try HOMEDRIVE and HOMEPATH
   #     environment variables...
   #
   #     NOTE: The existence of HOMEDRIVE
   #           is optional here. If not
   #           defined we'll assume it is
   #           an empty string.
   #
   if ($homeDir eq "") {
      if (pKit_getOSclass() eq "Windows-like") {
         my $HOMEDRIVE;
         my $HOMEPATH;
         if ( exists $ENV{'HOMEDRIVE'}) {
            $HOMEDRIVE = $ENV{'HOMEDRIVE'};
            print DBGOUT "pKit_findHomeDirectory: ...HOMEDRIVE is \"$HOMEDRIVE\"\n" if $debugging;
         }
         else {
            $HOMEDRIVE = "";
            print DBGOUT "pKit_findHomeDirectory: ...HOMEDRIVE is not defined\n" if $debugging;
         }
         if ( exists $ENV{'HOMEPATH'}) {
            $HOMEPATH = $ENV{'HOMEPATH'};
            print DBGOUT "pKit_findHomeDirectory: ...HOMEPATH is \"$HOMEPATH\"\n" if $debugging;
            if ($HOMEPATH ne "") {
               my $trydir  = pKit_makePathWindowslike("$HOMEDRIVE$HOMEPATH");
               print DBGOUT "pKit_findHomeDirectory: ...consider \"$trydir\"\n" if $debugging;
               if ( -d $trydir) {
                  $homeDir = $trydir;
                  print DBGOUT "pKit_findHomeDirectory:    found\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_findHomeDirectory:    NOT found\n" if $debugging;
               }
            }
         }
         else {
            print DBGOUT "pKit_findHomeDirectory: ...HOMEPATH is not defined\n" if $debugging;
         }
      }
   }
   #---------------------------------------
   #
   #  ...finally try USERPROFILE environment
   #     variables...
   #
   if ($homeDir eq "") {
      if (pKit_getOSclass() eq "Windows-like") {
         if ( exists $ENV{'USERPROFILE'}) {
            my $USERPROFILE = $ENV{'USERPROFILE'};
            print DBGOUT "pKit_findHomeDirectory: ...USERPROFILE is \"$USERPROFILE\"\n" if $debugging;
            if ($USERPROFILE ne "") {
               my $trydir   = pKit_makePathWindowslike($USERPROFILE);
               print DBGOUT "pKit_findHomeDirectory: ...consider \"$trydir\"\n" if $debugging;
               if ( -d $trydir) {
                  $homeDir  = $trydir;
                  print DBGOUT "pKit_findHomeDirectory:    found\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_findHomeDirectory:    NOT found\n" if $debugging;
               }
            }
         }
         else {
            print DBGOUT "pKit_findHomeDirectory: ...USERPROFILE is not defined\n" if $debugging;
         }
      }
   }
   print DBGOUT "pKit_findHomeDirectory] ...done(=\"$homeDir\")\n" if $debugging;
   return $homeDir;
}

# MyUniqueFileId: c58e95af-7811-46b9-ba94-c63e6b2ed7ee
#-------------------------------------------------------------------------------
#
#  Decide where to place tempfiles.
#
#     0) Try the pathname in in the environment variable that
#        was passed as the single parameter.
#     1) Try the pathname in TMPDIR
#     2) Try the pathname in TMP
#     3) Try the pathname in TEMP
#     4) Try ~/tmp (tmp under home directory)
#     5) Try C:<usrProf>\AppData\Local\temp directory
#     6) Try /tmp
#     7) Try /var/tmp
#     8) Try C:\Temp
#     9) Try C:\Windows\Temp
#    10) Try .
#
#  Note that 5, 8, and 9 are only applicable on Windows-like hosts.
#
#  This function uses: pKit_findHomeDirectory(),
#                      pKit_getOSclass(),
#                      pKit_joinpath()
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/findTempDir.psub
#
#  Dated: 04Jul2020 pKit_findTempDir
#
#-------------------------------------------------------------------------------

sub pKit_findTempDir {
   my $envVarName = shift;
   print DBGOUT "pKit_findTempDir[ envVarName=\"$envVarName\"...\n" if $debugging;
   my $tmpdir     = "";

   #---------------------------------------
   #
   #  First try the given environment variable...
   #
   if ($tmpdir eq "") {
      if ($envVarName ne "") {
         if ( exists $ENV{$envVarName}) {
            my $envVarValue = $ENV{$envVarName};
            print DBGOUT "pKit_findTempDir: ...$envVarName is \"$envVarValue\"\n" if $debugging;
            my $trydir      = $envVarValue;
            if (pKit_getOSclass() eq "Windows-like") {
               $trydir      = pKit_makePathWindowslike($trydir);
            }
            print DBGOUT "pKit_findTempDir: ...consider \"$trydir\"\n" if $debugging;
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
                  print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
               }
            }
            else {
               print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
            }
         }
         else {
            print DBGOUT "pKit_findTempDir: ...$envVarName is not defined\n" if $debugging;
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try TMPDIR environment variable...
   #
   if ($tmpdir eq "") {
      if ( exists $ENV{'TMPDIR'}) {
         my $TMPDIR = $ENV{'TMPDIR'};
         print DBGOUT "pKit_findTempDir: ...TMPDIR is \"$TMPDIR\"\n" if $debugging;
         my $trydir = $TMPDIR;
         if (pKit_getOSclass() eq "Windows-like") {
            $trydir = pKit_makePathWindowslike($trydir);
         }
         print DBGOUT "pKit_findTempDir: ...consider \"$trydir\"\n" if $debugging;
         if ( -d $trydir) {
            if ( -w $trydir) {
               $tmpdir = $trydir;
               print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
            }
            else {
               print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
            }
         }
         else {
            print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_findTempDir: ...TMPDIR is not defined\n" if $debugging;
      }
   }

   #---------------------------------------
   #
   #  ...then try TMP environment variable...
   #
   if ($tmpdir eq "") {
      if ( exists $ENV{'TMP'}) {
         my $TMP    = $ENV{'TMP'};
         print DBGOUT "pKit_findTempDir: ...TMP is \"$TMP\"\n" if $debugging;
         my $trydir = $TMP;
         if (pKit_getOSclass() eq "Windows-like") {
            $trydir = pKit_makePathWindowslike($trydir);
         }
         print DBGOUT "pKit_findTempDir: ...consider \"$TMP\"\n" if $debugging;
         if ( -d $trydir) {
            if ( -w $trydir) {
               $tmpdir = $trydir;
               print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
            }
            else {
               print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
            }
         }
         else {
            print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_findTempDir: ...TMP is not defined\n" if $debugging;
      }
   }

   #---------------------------------------
   #
   #  ...then try TEMP environment variable...
   #
   if ($tmpdir eq "") {
      if ( exists $ENV{'TEMP'}) {
         my $TEMP   = $ENV{'TEMP'};
         print DBGOUT "pKit_findTempDir: ...TEMP is \"$TEMP\"\n" if $debugging;
         my $trydir = $TEMP;
         if (pKit_getOSclass() eq "Windows-like") {
            $trydir = pKit_makePathWindowslike($trydir);
         }
         print DBGOUT "pKit_findTempDir: ...consider \"$TEMP\"\n" if $debugging;
         if ( -d $trydir) {
            if ( -w $trydir) {
               $tmpdir = $trydir;
               print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
            }
            else {
               print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
            }
         }
         else {
            print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_findTempDir: ...TEMP is not defined\n" if $debugging;
      }
   }

   #---------------------------------------
   #
   #  ...then try tmp subdirectory of the
   #     user's home directory...
   #
   if ($tmpdir eq "") {
      #---------------------------------------
      #
      #  Find the user's home directory
      #
      my $theHomeDir = pKit_findHomeDirectory();
      print DBGOUT "pKit_findTempDir: ...the home directory is \"$theHomeDir\"\n" if $debugging;
      if ($theHomeDir ne "") {
         print DBGOUT "pKit_findTempDir: ...consider \"$theHomeDir\"\n" if $debugging;
         if ( -d $theHomeDir) {
            print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
            my $trydir = pKit_joinpath($theHomeDir,"tmp");
            if (pKit_getOSclass() eq "Windows-like") {
               $trydir = pKit_makePathWindowslike($trydir);
            }
            print DBGOUT "pKit_findTempDir: ...consider \"$trydir\"\n" if $debugging;
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
                  print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
               }
            }
            else {
               print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
            }
         }
         else {
            print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_findTempDir: ...can't find home directory\n" if $debugging;
      }
   }

   if ($tmpdir eq "") {
      if (pKit_getOSclass() eq "Windows-like") {

         #---------------------------------
         #
         #  ...then try "C:<usrProf>\AppData\Local\Temp"
         #     directory...
         #
         if ( exists $ENV{'USERPROFILE'} ) {
            my $USERPROFILE = $ENV{'USERPROFILE'};
            print DBGOUT "pKit_findTempDir: ...USERPROFILE is \"$USERPROFILE\"\n" if $debugging;
            if ($USERPROFILE ne "") {
               my $trydir = "$USERPROFILE\\AppData\\Local\\Temp";
               $trydir    = pKit_makePathWindowslike($trydir);
               print DBGOUT "pKit_findTempDir: ...consider \"${USERPROFILE}\\AppData\\Local\\Temp\"\n" if $debugging;
               if ( -d $trydir) {
                  if ( -w $trydir) {
                     $tmpdir = $trydir;
                     print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
                  }
                  else {
                     print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
                  }
               }
               else {
                  print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
               }
            }
         }
         else {
            print DBGOUT "pKit_findTempDir: ...USERPROFILE is not defined\n" if $debugging;
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try "/tmp" directory...
   #
   if ($tmpdir eq "") {
      my $trydir = "/tmp";
      if (pKit_getOSclass() eq "Windows-like") {
         $trydir = pKit_makePathWindowslike($trydir);
      }
      print DBGOUT "pKit_findTempDir: ...consider \"$trydir\"\n" if $debugging;
      if ( -d $trydir) {
         if ( -w $trydir) {
            $tmpdir = $trydir;
            print DBGOUT "pKit_findTempDir:    use it\n" if $debugging;
         }
      }
   }

   if ($tmpdir eq "") {
      if (pKit_getOSclass() eq "Windows-like") {

         #---------------------------------
         #
         #  ...then try "C:\Temp" directory...
         #
         if ($tmpdir eq "") {
            my $trydir = "C:\\Temp";
            print DBGOUT "pKit_findTempDir: ...consider \"$trydir\"\n" if $debugging;
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
                  print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
               }
            }
            else {
               print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
            }
         }

         #---------------------------------
         #
         #  ...then try "C:\Windows\Temp" directory...
         #
         if ($tmpdir eq "") {
            my $trydir = "C:\\Windows\\Temp";
            print DBGOUT "pKit_findTempDir: ...consider \"$trydir\"\n" if $debugging;
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
                  print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
               }
            }
            else {
               print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...finally try "." directory...
   #
   if ($tmpdir eq "") {
      my $trydir = ".";
      print DBGOUT "pKit_findTempDir: ...consider \".\"\n" if $debugging;
      if ( -d $trydir) {
         if ( -w $trydir) {
            $tmpdir = $trydir;
            print DBGOUT "pKit_findTempDir:    found\n" if $debugging;
         }
         else {
            print DBGOUT "pKit_findTempDir:    found, but not writable\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_findTempDir:    NOT found\n" if $debugging;
      }
   }

   print DBGOUT "pKit_findTempDir: ...can't find a directory for temporaries\n" if ($debugging && ($tmpdir eq ""));
   print DBGOUT "pKit_findTempDir] ...done(=\"$tmpdir\")\n" if $debugging;
   return $tmpdir;
}

# MyUniqueFileId: dde1497c-fc31-40f3-d176-bec0f0a9de83
#-------------------------------------------------------------------------------
#
#  This little function is used to deal with indented "here" documents. It
#  just strips away leading spaces/tabs up to and including a vertical bar.
#
#  see: totebag/src/pKit/fixIndentStuff.psub
#
#  Dated: 04Jul2020 pKit_fixIndentStuff
#
#-------------------------------------------------------------------------------

sub pKit_fixIndentStuff {
   my $tmp = shift;
   $tmp    =~ s/^\|?[ \t]*\|//gm;
   return $tmp;
}

# MyUniqueFileId: 2e9bd476-985f-408b-feb6-4fdb9639eed5
#-------------------------------------------------------------------------------
#
#  "Fixing" a pathname. This gets rid of excess dots and such that don't
#  make any difference but are hard to read. Note that the format of the
#  pathname is made proper for Windows-like hosts (to protect against
#  cygwin issues).
#
#  Note that this function uses: pKit_getOSclass(),
#                                pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/fixpath.psub
#
#  Dated: 04Jul2020 pKit_fixpath
#
#-------------------------------------------------------------------------------

sub pKit_fixpath {
   my $pathname = shift;
   print DBGOUT "pKit_fixpath[ pathname=\"$pathname\"...\n" if $debugging;
   my $result   = "";
   my $drive;
   #
   #  Decide on an appropriate pathname component separator (which kind
   #  of slash to use). Remove and hold on to the drive letter if there
   #  is one (only on Windows of course).
   #
   my $osClass = pKit_getOSclass();
   if ($osClass eq "UNIX-like") {
      print DBGOUT "pKit_fixpath: ...host looks UNIX-like\n" if $debugging;
      print DBGOUT "pKit_fixpath:    no drive\n" if $debugging;
      $drive   = "";
   }
   elsif ($osClass eq "Windows-like") {
      print DBGOUT "pKit_fixpath: ...host looks Windows-like\n" if $debugging;
      if ($pathname =~ /[\/\\]/) {
         print DBGOUT "pKit_fixpath:    pathname looks complex\n" if $debugging;
         $pathname = pKit_makePathWindowslike($pathname);
      }
      else {
         print DBGOUT "pKit_fixpath:    pathname looks simple\n" if $debugging;
      }
      if ($pathname =~ /^([a-zA-Z]):([\/\\].*)$/) {
         $drive    = $1;
         $pathname = $2;
         print DBGOUT "pKit_fixpath:    ...normal Windows-style pathname\n" if $debugging;
         print DBGOUT "pKit_fixpath:       with drive \"$drive\"\n" if $debugging;
         print DBGOUT "pKit_fixpath:         and path \"$pathname\"\n" if $debugging;
      }
      elsif ($pathname =~ /^[\/\\]([a-zA-Z])([\/\\].*)$/) {
         $drive    = $1;
         $pathname = $2;
         print DBGOUT "pKit_fixpath:    ...an \"A\" cygwin-style pathname\n" if $debugging;
         print DBGOUT "pKit_fixpath:       with drive \"$drive\"\n" if $debugging;
         print DBGOUT "pKit_fixpath:         and path \"$pathname\"\n" if $debugging;
      }
      elsif ($pathname =~ /^[\/\\]cygdrive[\/\\]([a-zA-Z])([\/\\].*)$/) {
         $drive    = $1;
         $pathname = $2;
         print DBGOUT "pKit_fixpath:    ...an \"B\" cygwin-style pathname\n" if $debugging;
         print DBGOUT "pKit_fixpath:       with drive \"$drive\"\n" if $debugging;
         print DBGOUT "pKit_fixpath:         and path \"$pathname\"\n" if $debugging;
      }
      else {
         print DBGOUT "pKit_fixpath:    ...easy pathname, with no drive\n" if $debugging;
         $drive    = "";
      }
   }
   else {
      print DBGOUT "pKit_fixpath: ...host looks neither UNIX- nor Windows-like\n" if $debugging;
      $drive    = "";
      $pathname = "";
   }
   if ($pathname ne "") {
      if ($pathname eq ".") {
         #---------------------------------------
         #
         #  Trivial "."
         #
         print DBGOUT "pKit_fixpath: ...trivial \".\"\n" if $debugging;
         $result = ".";
      }
      elsif (($pathname eq "/") || ($pathname eq "\\")) {
         #---------------------------------------
         #
         #  Trivial "/"
         #
         print DBGOUT "pKit_fixpath: ...trivial slash\n" if $debugging;
         $result = $pathname;
      }
      else {
         print DBGOUT "pKit_fixpath: ...is non-trivial\n" if $debugging;
         #---------------------------------------
         #
         #  If non-trivial first switch backslashes
         #  to forward slashes...
         #
         my $adjusted = $pathname;
         $adjusted    =~ tr/\\/\//;
         if ($adjusted ne $pathname) {
            print DBGOUT "pKit_fixpath:    adjusted slashing to \"$adjusted\"\n" if $debugging;
            $pathname = $adjusted;
         }
         #---------------------------------------
         #
         #  Then reduce repeated slashes...
         #
         $adjusted = $pathname;
         $adjusted =~ s![/][/]+!/!g;
         if ($adjusted ne $pathname) {
            print DBGOUT "pKit_fixpath:    eliminated repeated slashes giving \"$adjusted\"\n" if $debugging;
            $pathname = $adjusted;
         }
         #---------------------------------------
         #
         #  Note if absolute or relative. If absolute
         #  then toss the leading slash for and
         #  split the pathname up into components...
         #
         #  Note that this is much like that in
         #  the pKit_splitPathname() function.
         #
         my @components = ();
         if ($pathname =~ /^\/(.*)$/) {
            print DBGOUT "pKit_fixpath:    looks absolute, split on slashes\n" if $debugging;
            @components = split(/[\/]+/,$1);
            $absolute   = 1;
         }
         else {
            print DBGOUT "pKit_fixpath:    looks relative, split on slashes\n" if $debugging;
            @components = split(/[\/]+/,$pathname);
            $absolute   = 0;
         }
         if ($debugging) {
            my $j;
            for ($j=0; $j<=$#components; $j+=1) {
               my $component = $components[$j];
               if ($j == 0) {
                  print DBGOUT "pKit_fixpath:    ...giving: \"$component\"\n" if $debugging;
               }
               else {
                  print DBGOUT "pKit_fixpath:               \"$component\"\n" if $debugging;
               }
            }
         }
         #---------------------------------------
         #
         #  Scan for single dots and remove them...
         #
         print DBGOUT "pKit_fixpath:    remove single dots\n" if $debugging;
         {
            my $modified = 0;
            my $changed  = 1;
            while ($changed) {
               $changed = 0;
               my $j;
               for ($j=0; $j<=$#components; $j+=1) {
                  if ($components[$j] eq ".") {
                     splice(@components,$j,1);
                     $changed  = 1;
                     $modified = 1;
                  }
               }
            }
            if ($debugging) {
               if ($modified) {
                  my $j;
                  for ($j=0; $j<=$#components; $j+=1) {
                     my $component = $components[$j];
                     if ($j == 0) {
                        print DBGOUT "pKit_fixpath:    ...giving: \"$component\"\n" if $debugging;
                     }
                     else {
                        print DBGOUT "pKit_fixpath:               \"$component\"\n" if $debugging;
                     }
                  }
               }
               else {
                  print DBGOUT "pKit_fixpath:    ...none\n" if $debugging;
               }
            }
         }
         #---------------------------------------
         #
         #  Scan for double dots and resolve them...
         #
         print DBGOUT "pKit_fixpath:    resolve double dots\n" if $debugging;
         {
            if (1 <= $#components) {
               my $modified = 0;
               my $changed  = 1;
               while ($changed) {
                  $changed = 0;
                  if ($absolute && ($components[0] eq "..")) {
                     splice(@components,0,1);
                     $changed = 1;
                  }
                  else {
                     my $j;
                     for ($j=1; $j<=$#components; $j+=1) {
                        if (($components[$j] eq "..") && ($components[$j-1] ne "..")) {
                           splice(@components,$j-1,2);
                           $changed = 1;
                        }
                     }
                  }
               }
               if ($debugging) {
                  if ($modified) {
                     my $j;
                     for ($j=0; $j<=$#components; $j+=1) {
                        my $component = $components[$j];
                        if ($j == 0) {
                           print DBGOUT "pKit_fixpath:    ...giving: \"$component\"\n" if $debugging;
                        }
                        else {
                           print DBGOUT "pKit_fixpath:               \"$component\"\n" if $debugging;
                        }
                     }
                  }
                  else {
                     print DBGOUT "pKit_fixpath:    ...none\n" if $debugging;
                  }
               }
            }
            else {
               print DBGOUT "pKit_fixpath:    ...not worth it\n" if $debugging;
            }
         }
         #---------------------------------------
         #
         #  Output what we've found reintroducing
         #  the leading slash...
         #
         print DBGOUT "pKit_fixpath:    reassemble\n" if $debugging;
         if ($#components < 0) {
            print DBGOUT "pKit_fixpath:    ...but nothing left\n" if $debugging;
            if ($absolute) {
               print DBGOUT "pKit_fixpath:       was absolute\n" if $debugging;
               $result = "/";
            }
            else {
               print DBGOUT "pKit_fixpath:       was relative\n" if $debugging;
               $result = ".";
            }
         }
         else {
            print DBGOUT "pKit_fixpath:    ...from remaining components\n" if $debugging;
            if ($absolute) {
               print DBGOUT "pKit_fixpath:       was absolute\n" if $debugging;
               $result = "/";
            }
            else {
               print DBGOUT "pKit_fixpath:       was relative\n" if $debugging;
               $result = "";
            }
            my $j;
            for ($j=0; $j<=$#components; $j+=1) {
               if (0 < $j) {
                  $result = $result."/";
               }
               $result = $result.$components[$j];
            }
         }
      }
   }
   if (($result ne "") || ($drive ne "")) {
      #---------------------------------------
      #
      #  Finally re-attach drive letter if
      #  necessary and make sure format is
      #  proper if this is a Windows-like
      #  host.
      #
      if ($drive ne "") {
         print DBGOUT "pKit_fixpath: ...re-attach drive letter\n" if $debugging;
         $result = $drive.":".$result;
      }
      if ($osClass eq "Windows-like") {
         print DBGOUT "pKit_fixpath: ...a final adjustment\n" if $debugging;
         $result = pKit_makePathWindowslike($result);
      }
   }
   print DBGOUT "pKit_fixpath] ...done(=\"$result\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: 14888b4a-e281-4663-9f7c-63017caea3ca
#-------------------------------------------------------------------------------
#
#  Get the OS class.
#
#  This function is used to determine the OS class of of the host system. A
#  single optional parameter string may be specified: the caret-O value (the
#  default is to use the actual special $^O Perl special variable). Such a
#  parameter is almost never supplied.
#
#  Returns: One of:
#
#              "UNIX-like"
#              "Windows-like"
#              "unknown" (failure)
#
#  see: totebag/src/pKit/getOSclass.psub
#
#  Dated: 04Jul2020 pKit_getOSclass
#
#-------------------------------------------------------------------------------

sub pKit_getOSclass {
   my $osName = shift;
   print DBGOUT "pKit_getOSclass[ osName=\"".$osName."\"...\n" if $debugging;
   my $result;
   if ($osName eq "") {
      $osName = $^O;
      print DBGOUT "pKit_getOSclass: ...assume osName=\"".$osName."\"\n" if $debugging;
   }
   #---------------------------------------
   #
   #  First try to use a (fast) direct
   #  method...
   #
   if ($osName =~ /^linux$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^MSWin32$/i) {
      $result = "Windows-like";
   }
   elsif ($osName =~ /^darwin$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^freebsd$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^solaris$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^aix$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^dec_osf$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^hpux$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^irix$/i) {
      $result = "UNIX-like";
   }
   elsif ($osName =~ /^msys$/i) {
      $result = "Windows-like";
   }
   elsif ($osName =~ /^dos$/i) {
      $result = "Windows-like";
   }
   elsif ($osName =~ /^os2$/i) {
      $result = "Windows-like";
   }
   else {
      #---------------------------------------
      #
      #  The hard way...
      #
      #  If it isn't directly known, try to
      #  figure it out the hard way. UNIX-like
      #  hosts use colons (:) as the separator
      #  in PATH, but Windows-like hosts use
      #  semicolons (;).
      #
      #  Note: Must check for semicolons first
      #        (Windows) as Windows may have
      #        colons too as drive letter
      #        separators.
      #
      if ( defined $ENV{'PATH'} ) {
         my $tmpPath = $ENV{'PATH'};
         if ($tmpPath ne "") {
            if ($tmpPath =~ /;/) {
               $result = "Windows-like";
            }
            elsif ($tmpPath =~ /:/) {
               $result = "UNIX-like";
            }
            else {
               $result = "unknown";
            }
         }
         else {
            $result = "unknown";
         }
      }
      else {
         $result = "unknown";
      }
   }
   print DBGOUT "pKit_getOSclass] ...done(=\"".$result."\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: bcb07002-1092-4e3a-a5c2-bd7dc1bb207f
#-------------------------------------------------------------------------------
#
#  Get the OS name.
#
#  This function is used to determine the detailed OS name of of the host
#  system. It is recommended that this function be used rather than the
#  special scalar variable $^O supplied by Perl as this is not particularly
#  accurate for example it doesn't distinguish SunOS from Solaris).
#
#  The first parameter is a "level of detail" (number), passing 0 returns
#  either "Unix-like" or "Windows-like" much like the pKit_getOSclass() function.
#  Passing 1 or more gives a more specific name. The value should be in the
#  range 0..3 The default is 1
#
#  The second parameter is a name such as returned by $^O that is to be used.
#  This parameter is almost never supplied. Default is to use the value of
#  the special varable $^O (this default is almost always what is wanted).
#
#  The third parameter is a string (possibly multi-line) such as returned by
#  the:
#
#     uname -r    UNIX-like hosts
#
#  or the:
#
#     ver         Windows-like hosts
#
#  As with the second parameter this parameter is almost never supplied.
#  The default is to use the output of appropriate command.
#
#  The fourth parameter is a string (possibly multi-line) such as returned by
#  by the: systeminfo command (on Windows-like hosts). As with the second and
#  third parameters this parameter is almost never supplied and is only
#  appropriate for Windows-like hosts. Default is to use the output of the
#  systeminfo command.
#
#  NOTE: This code has only been tested on FreeBSD, Linux, MacOS, and Solaris
#        and a number of Windows desktop and server versions. Other other
#        implementations has been known to work but haven't been tested for
#        years.
#
#  This function uses: pKit_getOSclass()
#
#  see: totebag/src/pKit/getOSname.psub
#
#  Dated: 01Jul2020 pKit_getOSname
#
#-------------------------------------------------------------------------------

sub pKit_getOSname {
   my $levelOfDetail   = shift;
   my $givenCaretOh    = shift;
   my $givenCmd1Output = shift;
   my $givenCmd2Output = shift;
   print DBGOUT "pKit_getOSname[ levelOfDetail=\"".$levelOfDetail."\", givenCaretOh=[".$givenCaretOh."], givenCmd1Output=[".$givenCmd1Output."], givenCmd2Output=[".$givenCmd2Output."]...\n" if $debugging;
   my $result;
   #---------------------------------------
   #
   #  Defaults...
   #
   if ( ! ($levelOfDetail =~ /^\d+$/)) {
      $levelOfDetail = 1;
      print DBGOUT "pKit_getOSname: ...assume levelOfDetail=1\n" if $debugging;
   }
   if ($givenCaretOh eq "") {
      $givenCaretOh  = $^O;
      print DBGOUT "pKit_getOSname: ...assume givenCaretOh=[".$givenCaretOh."]\n" if $debugging;
   }
   $givenCaretOh     = lc $givenCaretOh;
   #---------------------------------------
   #
   #  Go to work...
   #
   if ($levelOfDetail <= 0) {
      print DBGOUT "pKit_getOSname: ...lowest fidelity\n" if $debugging;
      if ($givenCaretOh eq "") {
         $result = pKit_getOSclass();
      }
      else {
         $result = pKit_getOSclass($givenCaretOh);
      }
   }
   else {
      #---------------------------------------
      #
      #  AIX
      #
      #---------------------------------------
      if ($givenCaretOh =~ /^aix$/) {
         print DBGOUT "pKit_getOSname: ...is AIX\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major != "") {
                     if (3 <= $levelOfDetail && ($minor ne "")) {
                        $result = "AIX".$major.".".$minor;
                     }
                     else {
                        $result = "AIX".$major;
                     }
                  }
                  else {
                     $result = "AIX";
                  }
               }
               else {
                  $result = "AIX";
               }
            }
            else {
               $result = "AIX";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "AIX";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  MacOS
      #
      #---------------------------------------
      elsif ($givenCaretOh =~ /^darwin$/) {
         print DBGOUT "pKit_getOSname: ...is MacOS (aka. darwin)\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /^\s*18\.\d+/) {
                  $result = "MacOS X Mojave";
               }
               elsif ($gives =~ /^\s*17\.\d+/) {
                  $result = "MacOS X High Sierra";
               }
               elsif ($gives =~ /^\s*16\.\d+/) {
                  $result = "MacOS X Sierra";
               }
               elsif ($gives =~ /^\s*15\.\d+/) {
                  $result = "OS X El Capitan";
               }
               elsif ($gives =~ /^\s*14\.\d+/) {
                  $result = "OS X Yosemite";
               }
               elsif ($gives =~ /^\s*13\.\d+/) {
                  $result = "OS X Mavericks";
               }
               elsif ($gives =~ /^\s*12\.\d+/) {
                  $result = "OS X Mountain Lion";
               }
               elsif ($gives =~ /^\s*11\.\d+/) {
                  $result = "OS X Lion";
               }
               elsif ($gives =~ /^\s*10\.\d+/) {
                  $result = "OS X Snow Leopard";
               }
               elsif ($gives =~ /^\s*9\.\d+/) {
                  $result = "OS X Leopard";
               }
               elsif ($gives =~ /^\s*8\.\d+/) {
                  $result = "OS X Tiger";
               }
               elsif ($gives =~ /^\s*7\.\d+/) {
                  $result = "OS X Panther";
               }
               elsif ($gives =~ /^\s*6\.\d+/) {
                  $result = "OS X Jaguar";
               }
               elsif (($gives =~ /^\s*5\.\d+/) || ($gives =~ /^\s*1\.4\.\d+/)) {
                  $result = "OS X Puma";
               }
               elsif ($gives =~ /^\s*1\.3\.\d+/) {
                  $result = "OS X Cheetah";
               }
               elsif ($gives =~ /^\s*1\.2\.\d+/) {
                  $result = "OS X Kodiak";
               }
               else {
                  $result = "OS X";
               }
            }
            else {
               $result = "MacOS";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "MacOS";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  OSF/1 aka Tru64
      #
      #---------------------------------------
      elsif ($givenCaretOh =~ /^dec_osf$/) {
         print DBGOUT "pKit_getOSname: ...is Tru64 (aka. OSF/1)\n" if $debugging;
         if (1 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /^\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major ne "") {
                     if ($major <= 3) {
                        if ((3 <= $levelOfDetail) && ($minor ne "")) {
                           $result = "OSF-".$major.".".$minor;
                        }
                        elsif (2 <= $levelOfDetail) {
                           $result = "OSF-".$major;
                        }
                        else {
                           $result = "OSF";
                        }
                     }
                     elsif (4 <= $major) {
                        if ((3 <= $levelOfDetail) && ($minor ne "")) {
                           $result = "Tru64-".$major.".".$minor;
                        }
                        elsif (2 <= $levelOfDetail) {
                           $result = "Tru64-".$major;
                        }
                        else {
                           $result = "Tru64";
                        }
                     }
                     else {
                        $result = "Tru64";
                     }
                  }
                  else {
                     $result = "Tru64";
                  }
               }
               else {
                  $result = "Tru64";
               }
            }
            else {
               $result = "Tru64";
            }
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  FreeBSD
      #
      #---------------------------------------
      elsif ($givenCaretOh =~ /^freebsd$/) {
         print DBGOUT "pKit_getOSname: ...is FreeBSD\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major ne "") {
                     if ((3 <= $levelOfDetail) && ($minor ne "")) {
                        $result = "FreeBSD".$major.".".$minor;
                     }
                     else {
                        $result = "FreeBSD".$major;
                     }
                  }
                  else {
                     $result = "FreeBSD";
                  }
               }
               else {
                  $result = "FreeBSD";
               }
            }
            else {
               $result = "FreeBSD";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "FreeBSD";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  BeOS aka Haiku
      #
      #---------------------------------------
      elsif ($givenCaretOh =~ /^haiku$/) {
         print DBGOUT "pKit_getOSname: ...is Haiku (aka. BeOS)\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major ne "") {
                     if ((3 <= $levelOfDetail) && ($minor ne "")) {
                        $result = "Haiku".$major.".".$minor;
                     }
                     else {
                        $result = "Haiku".$major;
                     }
                  }
                  else {
                     $result = "Haiku";
                  }
               }
               else {
                  $result = "Haiku";
               }
            }
            else {
               $result = "Haiku";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "Haiku";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  HP/UX
      #
      #---------------------------------------
      elsif ($givenCaretOh =~ /^hpux$/) {
         print DBGOUT "pKit_getOSname: ...is HP/UX\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*[AB]\.(\d+)(\.(\d+))?/) {
                  $result = "HP/UX-$1";
               }
               else {
                  $result = "HP/UX";
               }
            }
            else {
               $result = "HP/UX";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "HP/UX";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  IRIX
      #
      #---------------------------------------
      elsif (($givenCaretOh =~ /^irix$/) || ($givenCaretOh =~ /^irix64$/)) {
         print DBGOUT "pKit_getOSname: ...is IRIX\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major ne "") {
                     if ((3 <= $levelOfDetail) && ($minor ne "")) {
                        $result = "Irix".$major.".".$minor;
                     }
                     else {
                        $result = "Irix".$major;
                     }
                  }
                  else {
                     $result = "Irix";
                  }
               }
               else {
                  $result = "Irix";
               }
            }
            else {
               $result = "Irix";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "Irix";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  Linux
      #
      #---------------------------------------
      elsif ($givenCaretOh =~ /^linux$/i) {
         print DBGOUT "pKit_getOSname: ...is LINUX\n" if $debugging;
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major ne "") {
                     if ((3 <= $levelOfDetail) && ($minor ne "")) {
                        $result = "Linux".$major.".".$minor;
                     }
                     else {
                        $result = "Linux".$major;
                     }
                  }
                  else {
                     $result = "Linux";
                  }
               }
               else {
                  $result = "Linux";
               }
            }
            else {
               $result = "Linux";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "Linux";
         }
         else {
            $result = "Unix-like";
         }
      }
      #---------------------------------------
      #
      #  Windows
      #
      #---------------------------------------
      elsif (($givenCaretOh =~ /^mswin32$/) || ($givenCaretOh =~ /^msys$/)) {
         print DBGOUT "pKit_getOSname: ...is Windows\n" if $debugging;
         $result = "";
         if (2 <= $levelOfDetail) {
            print DBGOUT "pKit_getOSname:    high fidelity\n" if $debugging;
            my $verOutput;
            if ($givenCmd1Output eq "") {
               my $cmd    = "ver";
               $verOutput = `$cmd`;
            }
            else {
               $verOutput = $givenCmd1Output;
               print DBGOUT "pKit_getOSname:    ...assume ver returns [".$verOutput."]\n" if $debugging;
            }
            chomp $gives; $gives =~ s/\r$//;
            print DBGOUT "pKit_getOSname:    ver returns [".$verOutput."]\n" if $debugging;
            if ($verOutput ne "") {
               #
               #  Server...
               #
               #  Note how the systeminfo command must be used to distinguish
               #  the server versions from the desktop versions.
               #
               if ($verOutput =~ /Microsoft Windows \[Version 10\.0\.14393\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  print DBGOUT "pKit_getOSname:    systeminfo gives [".$gives."]\n" if $debugging;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2016";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 6\.3\.9200\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  print DBGOUT "pKit_getOSname:    systeminfo gives [".$gives."]\n" if $debugging;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2012 R2";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 6\.2\.9200\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  print DBGOUT "pKit_getOSname:    systeminfo gives [".$gives."]\n" if $debugging;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2012";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 6\.1\.7601\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2008 R2 SP1";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     $result = "Windows 7 SP1";
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 6\.1\.7600(\.\d+)?\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2008 R2";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     $result = "Windows 7";
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 6\.0\.6002\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2008 SP1";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     $result = "Windows Vista SP2";
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 6\.0\.6001\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2008 SP1";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     $result = "Windows Vista SP1";
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 5\.2\.3790\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2003";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     $result = "Windows XP-64";
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               elsif ($verOutput =~ /\s*Microsoft Windows \[Version 5\.2\.3790\.1180\]/) {
                  print DBGOUT "pKit_getOSname:    ...might be server edition?\n" if $debugging;
                  my $gives;
                  if ($givenCmd1Output eq "") {
                     my $cmd = "systeminfo";
                     $gives  = `$cmd`;
                  }
                  else {
                     $gives  = $givenCmd2Output;
                  }
                  chomp $gives; $gives =~ s/\r$//;
                  if ($gives =~ /Windows Server/) {
                     $result = "Windows Server 2003 SP1";
                     print DBGOUT "pKit_getOSname:    ...and it is a server edition\n" if $debugging;
                  }
                  else {
                     $result = "Windows XP-64";
                     print DBGOUT "pKit_getOSname:    ...but it is a desktop edition\n" if $debugging;
                  }
               }
               if ($result eq "") {
                  print DBGOUT "pKit_getOSname:    ...probably a desktop edition?\n" if $debugging;
                  print DBGOUT "pKit_getOSname:       with ver output [".$verOutput."]\n" if $debugging;
                  #
                  #  Desktop...
                  #
                  #  We've already decided it is not a server version so it must be a
                  #  desktop version.
                  #
                  if ($verOutput =~ /Microsoft Windows \[Version 10\.0.\d+(.\d+)?\]/) {
                     $result = "Windows 10";
                  }
                  elsif ($verOutput =~ /Microsoft Windows \[Version 6\.3(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows 8.1";
                  }
                  elsif ($verOutput =~ /Microsoft Windows \[Version 6\.2(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows 8";
                  }
                  elsif ($verOutput =~ /Microsoft Windows \[Version 6\.1(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows 7";
                  }
                  elsif ($verOutput =~ /Microsoft Windows \[Version 6\.0(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows Vista";
                  }
                  elsif ($verOutput =~ /Microsoft Windows \[Version 5\.2(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows XP-64";
                  }
                  elsif ($verOutput =~ /Microsoft Windows XP \[Version 5\.1(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows XP";
                  }
                  elsif ($verOutput =~ /Microsoft Windows 2000 \[Version 5\.00?(\.\d+(\.\d+)?)?\]/) {
                     $result = "Windows 2000";
                  }
                  else {
                     $result = "Windows";
                  }
               }
            }
            else {
               $result = "Windows";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "Windows";
         }
         else {
            $result = "Windows-like";
         }
      }
      #---------------------------------------
      #
      #  SunOS aka Solaris
      #
      #---------------------------------------
      elsif (($givenCaretOh =~ /^solaris$/) || ($givenCaretOh =~ /^sunos$/)) {
         if (2 <= $levelOfDetail) {
            my $gives;
            if ($givenCmd1Output eq "") {
               my $cmd = "uname -r";
               $gives  = `$cmd`;
            }
            else {
               $gives  = $givenCmd1Output;
            }
            chomp $gives; $gives =~ s/\r$//;
            if ($gives ne "") {
               if ($gives =~ /\s*((\d+)(\.(\d+))?)/) {
                  my $major = $2;
                  my $minor = $4;
                  if ($major ne "") {
                     if ($major <= 4) {
                        if ((3 <= $levelOfDetail) && ($minor ne "")) {
                           $result = "SunOS".$major.".".$minor;
                        }
                        else {
                           $result = "SunOS".$major;
                        }
                     }
                     else {
                        $result = "Solaris".$minor;
                     }
                  }
                  else {
                     $result = "Solaris";
                  }
               }
               else {
                  $result = "Solaris";
               }
            }
            else {
               $result = "Solaris";
            }
         }
         elsif (1 <= $levelOfDetail) {
            $result = "Solaris";
         }
         else {
            $result = "Unix-like";
         }
      }
      else {
         $result = "Unix-like";
      }
   }
   print DBGOUT "pKit_getOSname] ...done(=\"".$result."\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: 8bfa6d6a-377a-4d1e-84f3-7235c5ae0877
#-------------------------------------------------------------------------------
#
#  Retrieve the command search path.
#
#  This is simply the value of the given environment variable. Note that the
#  value retrieved from the given environment variable is split then rejoined
#  in order to force the individual pathnames in to the proper form (this is
#  particularly important when cygwin is involved). The optional parameter is
#  the name of the environment variable to get (which is PATH by default).
#
#  calls: pKit_getOSclass(),
#         pKit_splitTheSearchPATH()
#
#  see: totebag/src/pKit/getTheSearchPATH.psub
#
#  Dated: 04Jul2020 pKit_getTheSearchPATH
#
#-------------------------------------------------------------------------------

sub pKit_getTheSearchPATH {
   my $varName = shift;
   print DBGOUT "pKit_getTheSearchPATH[ varName=\"".$varName."\"...\n" if $debugging;
   if ($varName eq "") {
      $varName = "PATH";
   }
   my $theValue;
   if ( exists $ENV{$varName}) {
      print DBGOUT "pKit_getTheSearchPATH: ...\"".$varName."\" is defined\n" if $debugging;
      $theValue     = $ENV{$varName};
      print DBGOUT "pKit_getTheSearchPATH: ...value is \"".$theValue."\"\n" if $debugging;
      print DBGOUT "pKit_getTheSearchPATH:    split value\n" if $debugging;
      my @tmpVals   = pKit_splitTheSearchPATH($theValue);
      print DBGOUT "pKit_getTheSearchPATH:    rejoin value\n" if $debugging;
      my $myOSclass = pKit_getOSclass();
      if ($myOSclass eq "UNIX-like") {
         print DBGOUT "pKit_getTheSearchPATH:    ...host appears UNIX-like, use colons\n" if $debugging;
         $theValue  = join ':', @tmpVals;
      }
      elsif ($myOSclass eq "Windows-like") {
         print DBGOUT "pKit_getTheSearchPATH:    ...host appears Windows-like, use semicolons\n" if $debugging;
         $theValue  = join ';', @tmpVals;
      }
   }
   else {
      print DBGOUT "pKit_getTheSearchPATH: ...\"".$varName."\" is NOT defined\n" if $debugging;
      $theValue = "";
   }
   print DBGOUT "pKit_getTheSearchPATH] ...done(=\"".$theValue."\")\n" if $debugging;
   return $theValue;
}

# MyUniqueFileId: c01f73fc-3153-477a-c68b-cbb74bc9526f
#-------------------------------------------------------------------------------
#
#  Get the current working directory.
#
#  This function is used to determine the current working directory. The
#  actual work is done using the getcwd() function supplied by the standard
#  Cwd module.
#
#  This function uses: pKit_getOSclass(),
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/getWorkingDirectory.psub
#
#  Dated: 04Jul2020 pKit_getWorkingDirectory
#
#-------------------------------------------------------------------------------

use Cwd;

sub pKit_getWorkingDirectory {
   print DBGOUT "pKit_getWorkingDirectory[ starting...\n" if $debugging;
   my $gives    = getcwd();
   print DBGOUT "pKit_getWorkingDirectory: ...getcwd() returns \"".$gives."\"\n" if $debugging;
   if (pKit_getOSclass() eq "Windows-like") {
      print DBGOUT "pKit_getWorkingDirectory: ...host looks Windows-like\n" if $debugging;
      $gives    = pKit_makePathWindowslike($gives);
   }
   print DBGOUT "pKit_getWorkingDirectory] ...done(=\"$gives\")\n" if $debugging;
   return $gives;
}

# MyUniqueFileId: 477e6650-8b5e-4ac5-b54c-d139c369545f
#-------------------------------------------------------------------------------
#
#  Get a reasonable type name for the hardware.
#
#  COllect, map, and return the hardware type. Mapping the string reported
#  by [uname -m] to something more reasonable...
#
#     UNIX-like (uses uname)
#
#        alpha    alpha
#        amd64    x86_64
#        armv7*   arm_32
#        armv8*   arm_64
#        BeBox    ppc_32
#        BeMac    ppc_32
#        BePC     x86_32
#        hp7??    hppa
#        hp8??    hppa
#        i?86     x86_32
#        i86*     x86_32
#        ia64     ia64
#        m68k     m68k
#        mips     mips_32
#        mips64   mips_64
#        Motorola mips_32
#        parisc   hppa
#        powerpc  ppc_32
#        ppc      ppc_32
#        ppc64    ppc_64
#        RISC*    m68k
#        sparc    sparc
#        sun3*    m68k
#        sun4*    sparc
#        tadpole* sparc
#        vax*     vax
#        x86_64   x86_64
#
#     Windows-like (look at %PROCESSOR_ARCHITECTURE%)
#
#        amd64    x86_64
#        x86      x86_32
#
#  This function uses: pKit_getOSclass()
#
#  see: totebag/src/pKit/idTheHardware.psub
#
#  Dated: 04Jul2020 pKit_idTheHardware
#
#-------------------------------------------------------------------------------

sub pKit_idTheHardware {
   my $reported = shift;
   print DBGOUT "pKit_idTheHardware[ reported=\"$reported\"...\n" if $debugging;
   my $HWtype   = "";
   my $osClass  = pKit_getOSclass();
   if ($osClass eq "UNIX-like") {
      print DBGOUT "pKit_idTheHardware: ...is UNIX-like\n" if $debugging;
      if ($reported eq "") {
         print DBGOUT "pKit_idTheHardware:    run [uname -m 2>/dev/null]\"\n" if $debugging;
         $reported = `uname -m 2>/dev/null`; chomp $reported; $reported =~ s/\r$//;
         print DBGOUT "pKit_idTheHardware:    ...gives [$reported]\"\n" if $debugging;
         print DBGOUT "pKit_idTheHardware:    assume reported=\"$reported\"\n" if $debugging;
      }
      if ($reported ne "") {
         $_ = $reported;
         parseArch: {
                       /^\s*9000\/[34]\d\d/

                          && do {
                             $HWtype = "m68k";
                             last parseArch;
                          };

                       /^\s*9000\/[678]\d\d/

                          && do {
                             $HWtype = "hppa";
                             last parseArch;
                          };

                       /^\s*alpha/

                          && do {
                             $HWtype = "alpha";
                             last parseArch;
                          };

                       /^\s*amd64/

                          && do {
                             $HWtype = "x86_64";
                             last parseArch;
                          };

                       /^\s*armv7/

                          && do {
                             $HWtype = "arm_32";
                             last parseArch;
                          };

                       /^\s*armv8/

                          && do {
                             $HWtype = "arm_64";
                             last parseArch;
                          };

                       /^\s*BeBox/

                          && do {
                             $HWtype = "ppc_32";
                             last parseArch;
                          };

                       /^\s*BeMac/

                          && do {
                             $HWtype = "ppc_32";
                             last parseArch;
                          };

                       /^\s*BePC/

                          && do {
                             $HWtype = "x86_32";
                             last parseArch;
                          };

                       /^\s*hp[34]\d\d/

                          && do {
                             $HWtype = "m68k";
                             last parseArch;
                          };

                       /^\s*hp[678]\d\d/

                          && do {
                             $HWtype = "hppa";
                             last parseArch;
                          };

                       /^\s*i\d86/

                          && do {
                             $HWtype = "x86_32";
                             last parseArch;
                          };

                       /^\s*i86/

                          && do {
                             $HWtype = "x86_32";
                             last parseArch;
                          };

                       /^\s*ia64/

                          && do {
                             $HWtype = "ia64";
                             last parseArch;
                          };

                       /^\s*m68k/

                          && do {
                             $HWtype = "m68k";
                             last parseArch;
                          };

                       /^\s*mips32/

                          && do {
                             $HWtype = "mips_32";
                             last parseArch;
                          };

                       /^\s*mips64/

                          && do {
                             $HWtype = "mips_64";
                             last parseArch;
                          };

                       /^\s*mips/

                          && do {
                             $HWtype = "mips_32";
                             last parseArch;
                          };

                       /^\s*Motorola/

                          && do {
                             $HWtype = "mips_32";
                             last parseArch;
                          };

                       /^\s*parisc/

                          && do {
                             $HWtype = "hppa";
                             last parseArch;
                          };

                       /^\s*powerpc/

                          && do {
                             $HWtype = "ppc_32";
                             last parseArch;
                          };

                       /^\s*ppc64/

                          && do {
                             $HWtype = "ppc_64";
                             last parseArch;
                          };

                       /^\s*ppc/

                          && do {
                             $HWtype = "ppc_32";
                             last parseArch;
                          };

                       /^\s*RISC/

                          && do {
                             $HWtype = "m68k";
                             last parseArch;
                          };

                       /^\s*sparc/

                          && do {
                             $HWtype = "sparc";
                             last parseArch;
                          };

                       /^\s*sun3/

                          && do {
                             $HWtype = "m68k";
                             last parseArch;
                          };

                       /^\s*sun4/

                          && do {
                             $HWtype = "sparc";
                             last parseArch;
                          };

                       /^\s*tadpole/

                          && do {
                             $HWtype = "sparc";
                             last parseArch;
                          };

                       /^\s*vax/

                          && do {
                             $HWtype = "vax";
                             last parseArch;
                          };

                       /^\s*x86_64/

                          && do {
                             $HWtype = "x86_64";
                             last parseArch;
                          };

                       /^\s*\S/

                          && do {
                             $HWtype = $reported;
                             last parseArch;
                          };

                    }
      }
      else {
         $HWtype = "";
      }
   }
   elsif ($osClass eq "Windows-like") {
      print DBGOUT "pKit_idTheHardware: ...is Windows-like\n" if $debugging;
      if ($reported eq "") {
         $reported = $ENV{'PROCESSOR_ARCHITECTURE'};
         print DBGOUT "pKit_idTheHardware:    assume reported=\"$reported\"\n" if $debugging;
      }
      if ($reported ne "") {
         $_ = $reported;
         parseArch: {
                       /^\s*amd64/

                          && do {
                             $HWtype = "x86_64";
                             last parseArch;
                          };

                       /^\s*x86/

                          && do {
                             $HWtype = "x86_32";
                             last parseArch;
                          };

                       /^\s*\S/

                          && do {
                             $HWtype = $reported;
                             last parseArch;
                          };

                    }
      }
   }
   else {
      $HWtype = "";
   }
   print DBGOUT "pKit_idTheHardware] ...done(=\"$HWtype\")\n" if $debugging;
   return $HWtype;
}

# MyUniqueFileId: 6ec18705-10ae-4ed7-8eb4-7253b02f5e63
#-------------------------------------------------------------------------------
#
#  Is the pathname an empty directory?
#
#  Note that this is much the same as the pKit_directoryIsEmpty() function but
#  this function only takes a pathname. It also is pretty verbose with its
#  debugging output.
#
#  see: totebag/src/pKit/isDirEmpty.psub
#
#  Dated: 01Jul2020 pKit_isDirEmpty
#
#-------------------------------------------------------------------------------

sub pKit_isDirEmpty {
   my $pathname  = shift;
   print DBGOUT "pKit_isDirEmpty[ pathname=\"$pathname\"...\n" if $debugging;
   my $result    = 0;
   if ( -d $pathname) {
      print DBGOUT "pKit_isDirEmpty: ...\"$pathname\" is a directory\n" if $debugging;
      if (opendir(DIR,$pathname)) {
         print DBGOUT "pKit_isDirEmpty: ...reading directory \"$pathname\"\n" if $debugging;
         $result = 1;
         my $tmpName;
         while (defined($tmpName = readdir(DIR))) {
            if (($tmpName ne "" ) && ($tmpName ne ".") && ($tmpName ne "..")) {
               print DBGOUT "pKit_isDirEmpty:    found \"$tmpName\"\n" if $debugging;
               $result = 0;
               last;
            }
         }
         closedir DIR;
      }
      else {
         print DBGOUT "pKit_isDirEmpty: ...can't open directory \"$pathname\"\n" if $debugging;
      }

   }
   else {
      if ( -e $pathname) {
         print DBGOUT "pKit_isDirEmpty: ...\"$pathname\" is not a directory\n" if $debugging;
      }
      else {
         if ( -l $pathname) {
            print DBGOUT "pKit_isDirEmpty: ...\"$pathname\" is a broken symbolic-link\n" if $debugging;
         }
         else {
            print DBGOUT "pKit_isDirEmpty: ...\"$pathname\" doesn't exist\n" if $debugging;
         }
      }
   }
   print DBGOUT "pKit_isDirEmpty] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: a30ce79a-7b13-4a8c-ae43-593ddb98a85e
#-------------------------------------------------------------------------------
#
#  Does the given tar implementation appear to be GNU tar?
#
#  This function uses: pKit_findTempDir(),
#                      pKit_makePathNative(),
#                      pKit_nullPathname(),
#                      pKit_quoteIfReqd()
#
#  see: totebag/src/pKit/isGNUtar.psub
#
#  Dated: 01Jul2020 pKit_isGNUtar
#
#-------------------------------------------------------------------------------

sub pKit_isGNUtar {
   my $toolname = shift;
   print DBGOUT "pKit_isGNUtar[ toolname=\"$toolname\"...\n" if $debugging;
   if ($toolname eq "") {
      $toolname = "tar";
   }
   my $result   = 0;
   my $TMPDIR   = pKit_findTempDir("");
   if ($TMPDIR ne "") {
      print DBGOUT "pKit_isGNUtar: ...place temporaries in \"$TMPDIR\"\n" if $debugging;
      my $TMPFILE = "$TMPDIR/igm$$.tmp";
      print DBGOUT "pKit_isGNUtar:    use \"$TMPFILE\" as a tempfile\n" if $debugging;
      my $nullDev = pKit_nullPathname();
      print DBGOUT "pKit_isGNUtar: ...\"$nullDev\" is the null device\n" if $debugging;
      my $cmd     = pKit_quoteIfReqd(pKit_makePathNative($toolname))." --version 1>".pKit_quoteIfReqd(pKit_makePathNative($TMPFILE))." 2>".pKit_quoteIfReqd(pKit_makePathNative($nullDev));
      print DBGOUT "pKit_isGNUtar: ...run [$cmd]\n" if $debugging;
      my $status  = system $cmd;
      if ($status == 0) {
         print DBGOUT "pKit_isGNUtar:    suceeded\n" if $debugging;
         if (open(GMAKEOUT,"< $TMPFILE")) {
            print DBGOUT "pKit_isGNUtar: ...reading \"$TMPFILE\"\n" if $debugging;
      scan: while (<GMAKEOUT>) {
               chomp; s/\r$//;
               my $got = $_;
               print DBGOUT "pKit_isGNUtar:    [$got]\n" if $debugging;
               $_      = $got;
               parse: {
                         /^.*GNU.*$/

                            && do {
                               print DBGOUT "pKit_isGNUtar:    ...found it\n" if $debugging;
                               $result = 1;
                               last scan;
                            };

                         /^(.*)$/

                            && do {
                               last parse;
                            };

                      }
            }
            close(GMAKEOUT);
            print DBGOUT "pKit_isGNUtar: ...cleanup\n" if $debugging;
            unlink $TMPFILE;
         }
         else {
            print DBGOUT "pKit_isGNUtar: ...can't find/read \"$TMPFILE\"\n" if $debugging;
         }
      }
      else {
         if ($debugging) {
            if ($status == -1) {
               print DBGOUT "pKit_isGNUtar:    failed to execute\n";
            }
            else {
               print DBGOUT "pKit_isGNUtar:    failed";
               my $code = $status >> 8;
               print DBGOUT ", code $code";
               if ($status & 127) {
                  my $signum = $status & 127;
                  print DBGOUT ", signal $signum";
               }
               if ($status & 128) {
                  print DBGOUT ", core dumped";
               }
               print DBGOUT "\n";
            }
         }
      }
   }
   else {
      print DBGOUT "pKit_isGNUtar: ...don't know where to place temporaries\n" if $debugging;
   }
   print DBGOUT "pKit_isGNUtar] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: c46cebad-4c13-4c40-e425-038ec4e722bc
#-------------------------------------------------------------------------------
#
#  Is the pathname a root pathname.
#
#  This function uses: pKit_fixpath(),
#                      pKit_getOSclass()
#
#  see: totebag/src/pKit/isRoot.psub
#
#  Dated: 04Jul2020 pKit_isRoot
#
#-------------------------------------------------------------------------------

sub pKit_isRoot {
   my $pathname = shift;
   print DBGOUT "pKit_isRoot[ pathname=\"$pathname\"...\n" if $debugging;
   my $result   = 0;
   my $adjusted = tr/\\/\//;
   $adjusted    = pKit_fixpath($pathname);
   if ($adjusted ne $pathname) {
      $pathname = $adjusted;
      print DBGOUT "pKit_isRoot: ...adjusted to \"$pathname\"\n" if $debugging;
   }
   my $osClass  = pKit_getOSclass();
   if ($osClass eq "UNIX-like") {
      print DBGOUT "pKit_isRoot: ...host is UNIX-like\n" if $debugging;
      if ($pathname eq "/") {
         $result = 1;
      }
      else {
         $result = 0;
      }
   }
   elsif ($osClass eq "Windows-like") {
      print DBGOUT "pKit_isRoot: ...host is Windows-like\n" if $debugging;
      if ($pathname =~ /^([a-zA-Z]):(.*)$/) {
         print DBGOUT "pKit_isRoot:    with a Windows-style drive letter\n" if $debugging;
         my $path = $2;
         if ($path =~ /^\//) {
            print DBGOUT "pKit_isRoot:    ...and slash\n" if $debugging;
            $result = 1;
         }
         else {
            print DBGOUT "pKit_isRoot:    ...but no slash\n" if $debugging;
            $result = 0;
         }
      }
      elsif ($pathname =~ /^\/([a-zA-Z])(\/.*)$/) {
         print DBGOUT "pKit_isRoot:    with an \"A\" cygwin-style drive letter (has slash)\n" if $debugging;
         $result = 1;
      }
      elsif ($pathname =~ /^\/cygdrive\/([a-zA-Z])(\/.*)$/) {
         print DBGOUT "pKit_isRoot:    with a \"B\" cygwin-style drive letter (has slash)\n" if $debugging;
         $result = 1;
      }
      elsif ($pathname =~ /^\//) {
         print DBGOUT "pKit_isRoot:    with a leading slash\n" if $debugging;
         $result = 1;
      }
      else {
         print DBGOUT "pKit_isRoot:    without a drive letter or leading slash\n" if $debugging;
         $result = 0;
      }
   }
   else {
      print DBGOUT "pKit_isRoot: ...host is neither UNIX- nor Windows-like\n" if $debugging;
      $result = 0;
   }
   print DBGOUT "pKit_isRoot] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: bc1edfe8-6348-4c37-c288-485eaa0085fd
#-------------------------------------------------------------------------------
#
#  Is the given pathname simple (without directory components).
#
#  This function uses: pKit_basename(),
#                      pKit_dirname()
#
#  see: totebag/src/pKit/isSimple.psub
#
#  Dated: 01Jul2020 pKit_isSimple
#
#-------------------------------------------------------------------------------

sub pKit_isSimple {
   my $pathname = shift;
   print DBGOUT "pKit_isSimple[ pathname=\"$pathname\"...\n" if $debugging;
   my $result   = 0;
   my $bn       = pKit_basename($pathname);
   if ($pathname eq $bn) {
      print DBGOUT "pKit_isSimple: ...no directory components\n" if $debugging;
      $result   = 1;
   }
   else {
      print DBGOUT "pKit_isSimple: ...has directory components\n" if $debugging;
      my $dn    = pKit_dirname($pathname);
      print DBGOUT "pKit_isSimple:    \"$dn\"\n" if $debugging;
   }
   print DBGOUT "pKit_isSimple] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: d9ff6301-50cf-45f8-ec93-88caac284048
#-------------------------------------------------------------------------------
#
#  This function is used to join pathname fragments or component to form a
#  single pathname. The result is normalized.
#
#  This function uses: pKit_basename(),
#                      pKit_fixpath(),
#                      pKit_getOSclass(),
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/joinpath.psub
#
#  Dated: 04Jul2020 pKit_joinpath
#
#-------------------------------------------------------------------------------

sub pKit_joinpath {
   my @theComponents  = @_;
   my $Ncomponents    = $#theComponents + 1;
   if ($debugging) {
      print DBGOUT "pKit_joinpath[ theComponents={" if $debugging;
      my $i;
      for ($i=0; $i<=$#theComponents; ++$i) {
         my $pathname = $theComponents[$i];
         if ($i == 0) {
            print DBGOUT "\"$pathname\"" if $debugging;
         }
         else {
            print DBGOUT ", \"$pathname\"" if $debugging;
         }
      }
      print DBGOUT "}...\n" if $debugging;
   }
   my $result;
   my $osClass        = pKit_getOSclass();
   my $wasSpecialCase = 0;

   if (1 <= $Ncomponents) {
      if ($osClass eq "UNIX-like") {
         print DBGOUT "pKit_joinpath: ...looks \"UNIX-like\"\n" if $debugging;
      }
      elsif ($osClass eq "Windows-like") {
         print DBGOUT "pKit_joinpath: ...looks \"Windows-like\"\n" if $debugging;
         print DBGOUT "pKit_joinpath:    adjust the components\"\n" if $debugging;
         my $i;
         for ($i=0; $i<$Ncomponents; $i+=1) {
            if ($theComponents[$i] =~ /[\/\\]/) {
               $theComponents[$i] = pKit_makePathWindowslike($theComponents[$i]);
            }
         }
      }
   }
   if ($Ncomponents == 2) {
      my $Lpart = $theComponents[0];
      my $Rpart = $theComponents[1];
      if ($Lpart eq ".") {
         my $bn = pKit_basename($Rpart);
         if ($Rpart eq $bn) {
            if ($osClass eq "UNIX-like") {
               $result      = $Lpart."/".$Rpart;     # implementing pKit_joinpath()
            }
            else {
               $result      = $Lpart."\\".$Rpart;     # implementing pKit_joinpath()
            }
            $wasSpecialCase = 1;
         }
      }
   }

   if ( ! $wasSpecialCase) {
      print DBGOUT "pKit_joinpath: ...not the special case\n" if $debugging;
      $result = $theComponents[0];
      if (0 < $#theComponents) {
         my $i;
         for ($i=1; $i<=$#theComponents; ++$i) {
            my $component = $theComponents[$i];
            if ($osClass eq "UNIX-like") {
               if ($component =~ "^/") {
                  $result = $component;
               }
               else {
                  $result = $result."/".$component;  # implementing pKit_joinpath()
               }
            }
            else {
               if ($component =~ '^\\\\') {
                  $result = $component;
               }
               else {
                  $result = $result."\\".$component;
               }
            }
            $result = pKit_fixpath($result);
         }
      }
      else {
         $result = pKit_fixpath($result);
      }
   }
   else {
      print DBGOUT "pKit_joinpath: ...was the special case\n" if $debugging;
   }
   if ($osClass eq "Windows-like") {
      my $tmpPathname = pKit_makePathWindowslike($result);
      if ($tmpPathname ne $result) {
         $result      = $tmpPathname;
         print DBGOUT "pKit_joinpath: ...adjusted to \"$result\"\n" if $debugging;
      }
   }
   print DBGOUT "pKit_joinpath] ...done(=\"$result\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: 08af42dd-91a9-4ff7-bda5-47f0147eb1f2
#-------------------------------------------------------------------------------
#
#  Rejoin search path array to form PATH string.
#
#  Rejoin the given search path (array) to form a PATH (string) appropriate for
#  the host OS. On a UNIX-like host colons (:) are used, on a Windows-like host
#  semicolons (;) are used.
#
#     my $myPATH = pKit_getTheSearchPATH();
#     my @myPATH = pKit_splitTheSearchPATH();
#     if ( ! pKit_alreadyOnSearchPATH($dirPathname,\@myPATH)) {
#        @myPATH = pKit_prependToSearchPATH($dirPathname,\@myPATH);
#        $myPATH = pKit_joinTheSearchPATH(\@myPATH);
#     }
#
#  Note the peculiar way the array is passed in to pKit_joinTheSearchPATH(). This
#  is a Perl pass array by reference.
#
#  This function uses: pKit_getOSclass()
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/joinTheSearchPATH.psub
#
#  Dated: 04Jul2020 pKit_joinTheSearchPATH
#
#-------------------------------------------------------------------------------

sub pKit_joinTheSearchPATH {
   my $refMyPATH = shift;   # A reference to an array of pathnames
   my $osClass   = shift;   # ...an optional parameter
   if ($osClass eq "") {
      $osClass = pKit_getOSclass();
   }
   if ($osClass eq "UNIX-like") {
      $myPATH = join ':', @$refMyPATH;
   }
   elsif ($osClass eq "Windows-like") {
      my $Nelems = @$refMyPATH;
      my $i;
      for ($i=0; $i<$Nelems; $i+=1) {
         my $thisPathname = $$refMyPATH[$i];
         if ($thisPathname =~ /[\/\\]/) {
            $$refMyPATH[$i] = pKit_makePathWindowslike($thisPathname);
         }
      }
      $myPATH = join ';', @$refMyPATH;
   }
   else {
      $myPATH = "";
   }
   return $myPATH;
}

# MyUniqueFileId: 1bcb3952-6c59-4cbf-b8de-fb66028261f3
#-------------------------------------------------------------------------------
#
#  Use the path to locate an executable.
#
#  This function uses the array of directory pathnames that had been previously
#  extracted from the PATH environment variable to locate an executable with
#  the given name. The caller is expected to supply the name of the executable
#  (a reference to) the @myPath array, and the osClass (see pKit_getOSclass()
#  function).
#
#  Parameters: The executable name (basename with or without .exe extension)
#              A reference to an array of directory pathnames (from PATH).
#              The OS class ("UNIX-like" or "Windows-like").
#
#  This function uses: pKit_getOSclass(),
#                      pKit_joinpath()
#
#  see: totebag/src/pKit/lookForExecutable.psub
#
#  Dated: 04Jul2020 pKit_lookForExecutable
#
#-------------------------------------------------------------------------------

sub pKit_lookForExecutable {
   my ($theName,$myPathRef,$osClass) = @_;
   my @myPath                        = @{$myPathRef};
   if ($debugging) {
      print DBGOUT "pKit_lookForExecutable[ theName=[$theName], myPath=..., osClass=[$osClass]...\n" if $debugging;
      my $i;
      for ($i=0; $i<=$#myPath; $i+=1) {
         my $pathname = $myPath[$i];
         if ($i == 0) {
            print DBGOUT "pKit_lookForExecutable: ...myPath is: \"$pathname\"\n" if $debugging;
         }
         else {
            print DBGOUT "pKit_lookForExecutable:               \"$pathname\"\n" if $debugging;
         }
      }
   }
   if ($osClass eq "") {
      $osClass = pKit_getOSclass();
      print STDERR "pKit_lookForExecutable: ...OS class not supplied, assume \"$osClass\"\n" if $debugging;
   }
   my $usePathname = "";
   if ($osClass eq "Windows-like") {
      print STDERR "pKit_lookForExecutable: ...host is Windows-like\n" if $debugging;
      if ( ! (($theName =~ /\.exe$/i) || ($theName =~ /\.bat$/i))) {
         print STDERR "pKit_lookForExecutable:    doesn't end with either .exe or .bat\n" if $debugging;
         my $i;
         for ($i=0; $i<=$#myPath; $i+=1) {
            my $pathname = pKit_joinpath($myPath[$i],$theName.".exe");
            print STDERR "pKit_lookForExecutable:    ...consider [$pathname]\n" if $debugging;
            if (-f $pathname) {
               print STDERR "pKit_lookForExecutable:    ...found\n" if $debugging;
               $usePathname = $pathname;
               last;
            }
         }
         if ($usePathname eq "") {
            for ($i=0; $i<=$#myPath; $i+=1) {
               my $pathname = pKit_joinpath($myPath[$i],$theName.".bat");
               print STDERR "pKit_lookForExecutable:    ...consider [$pathname]\n" if $debugging;
               if (-f $pathname) {
                  print STDERR "pKit_lookForExecutable:       found\n" if $debugging;
                  $usePathname = $pathname;
                  last;
               }
            }
         }
      }
      else {
         print STDERR "pKit_lookForExecutable:    already ends with .exe or .bat\n" if $debugging;
         my $i;
         for ($i=0; $i<=$#myPath; $i+=1) {
            my $pathname = pKit_joinpath($myPath[$i],$theName);
            print STDERR "pKit_lookForExecutable:    ...consider [$pathname]\n" if $debugging;
            if (-f $pathname) {
               print STDERR "pKit_lookForExecutable:       found\n" if $debugging;
               $usePathname = $pathname;
               last;
            }
         }
      }
      if ($usePathname eq "") {
         print STDERR "pKit_lookForExecutable:       NOT found\n" if $debugging;
      }
   }
   elsif ($osClass eq "UNIX-like") {
      print STDERR "pKit_lookForExecutable: ...host is UNIX-like\n" if $debugging;
      my $i;
      for ($i=0; $i<=$#myPath; $i+=1) {
         my $pathname = pKit_joinpath($myPath[$i],$theName);
         print STDERR "pKit_lookForExecutable:    consider [$pathname]\n" if $debugging;
         if (-f $pathname) {
            if (-x $pathname) {
               print STDERR "pKit_lookForExecutable:    ...found\n" if $debugging;
               $usePathname = $pathname;
               last;
            }
         }
      }
      if ($usePathname eq "") {
         print STDERR "pKit_lookForExecutable:    ...NOT found\n" if $debugging;
      }
   }
   else {
      print STDERR "pKit_lookForExecutable: ...host is not Windows- or UNIX-like\n" if $debugging;
      $usePathname = "";
   }
   print STDERR "pKit_lookForExecutable] ...done(=[$usePathname]\n" if $debugging;
   return $usePathname;
}

# MyUniqueFileId: 207bb6dd-57d8-4f8c-e73c-0626eba9e6b4
#-------------------------------------------------------------------------------
#
#  Create a directory...
#
#  This function uses: pKit_dirname(),
#                      pKit_makeDirectory(),    <---  is recuresive!
#
#  see: totebag/src/pKit/makeDirectory.psub
#
#  Dated: 01Jul2020 pKit_makeDirectory
#
#-------------------------------------------------------------------------------

sub pKit_makeDirectory {
   my $makingPathname = shift;
   my $fullPathname   = shift;
   my $makeParents    = shift;
   my $translated     = shift;
   my $sponsor        = shift;
   my $result;
   if (($fullPathname eq "/") || ($fullPathname eq ".") || ($fullPathname eq "..")) {
      $result = 1;
   }
   else {
      my $parentDir = pKit_dirname($fullPathname);
      if ( ! -d $parentDir) {
         if ($makeParents) {
            $result = pKit_makeDirectory($makingPathname,$parentDir,$makeParents,$translated,$sponsor);
         }
         else {
            print STDERR "$sponsor: can't create \"$makingPathname\", \"$parentDir\" doesn't exist\n" if $sponsor ne "";
            $result = 0;
         }
      }
      else {
         $result = 1;
      }
      if ($result) {
         if (mkdir($fullPathname,0777)) {
            my $createdPathname;
            if ($translated) {
               $createdPathname = $fullPathname;
               $createdPathname =~ tr/\//\\/;
            }
            else {
               $createdPathname = $fullPathname;
            }
            $result = 1;
         }
         else {
            print STDERR "$sponsor: can't create \"$makingPathname\"\n" if $sponsor ne "";
            $result = 0;
         }
      }
   }
   return $result;
}

# MyUniqueFileId: 28f944a3-7816-48a9-ece1-7c8281e5cf68
#-------------------------------------------------------------------------------
#
#  Convert pathname to a native form.
#
#  This function is used to convert the given pathname to a form appropriate
#  for this class of system (UNIX- or Windows-like).
#
#  This function uses: pKit_getOSclass(),
#                      pKit_makePathUNIXlike(),
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/makePathNative.psub
#
#  Dated: 04Jul2020 pKit_makePathNative
#
#-------------------------------------------------------------------------------

sub pKit_makePathNative {
   my $pathname = shift;
   print DBGOUT "pKit_makePathNative[ pathname=\"$pathname\"...\n" if $debugging;
   my $result;
   my $osClass  = pKit_getOSclass();
   if ($osClass eq "UNIX-like") {
      print DBGOUT "pKit_makePathNative: ...host looks UNIX-like\n" if $debugging;
      $result = pKit_makePathUNIXlike($pathname);
   }
   elsif ($osClass eq "Windows-like") {
      print DBGOUT "pKit_makePathNative: ...host looks Windows-like\n" if $debugging;
      $result = pKit_makePathWindowslike($pathname);
   }
   else {
      print DBGOUT "pKit_makePathNative: ...host doesn't look UNIX- or Windows-like\n" if $debugging;
      $result = "";
   }
   print DBGOUT "pKit_makePathNative] ...done(=\"$result\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: eae774dc-5ad0-4907-c3cc-2118873fdcb7
#-------------------------------------------------------------------------------
#
#  Translate all backslashes in the given pathname to forward slashes. Thus
#  converting it to a UNIX-like style. Note that drive letters will be
#  translated using an "A" cygwin-like style (resembling /x/something where
#  "x" is a letter).
#
#  This function uses: pKit_fixpath()
#
#  see: totebag/src/pKit/makePathUNIXlike.psub
#
#  Dated: 04Jul2020 pKit_makePathUNIXlike
#
#-------------------------------------------------------------------------------

sub pKit_makePathUNIXlike {
   my $pathname = shift;
   print DBGOUT "pKit_makePathUNIXlike[ pathname=\"$pathname\"...\n" if $debugging;
   my $changed  = $pathname =~ tr/\\/\//;
   if ($debugging && (1 <= $changed)) {
      print DBGOUT "pKit_makePathUNIXlike: ...adjusted slashing to \"$pathname\"\n" if $debugging;
   }
   if ($pathname =~ /^([a-zA-Z]):(\/.*)$/) {
      print DBGOUT "pKit_makePathUNIXlike: ...with drive (absolute)\n" if $debugging;
      my $drive = $1;
      my $path  = $2;
      $path     = pKit_fixpath($path);
      $pathname = "/".$drive.$path;
   }
   elsif ($pathname =~ /^([a-zA-Z]):(.+)$/) {
      print DBGOUT "pKit_makePathUNIXlike: ...with drive (relative -- shame)\n" if $debugging;
      my $drive = $1;
      my $path  = $2;
      $path     = pKit_fixpath($path);
      $pathname = "/".$drive."/".$path;
   }
   elsif ($pathname =~ /^([a-zA-Z]):$/) {
      print DBGOUT "pKit_makePathUNIXlike: ...just drive\n" if $debugging;
      my $drive = $1;
      $pathname = "/".$drive;
   }
   else {
      print DBGOUT "pKit_makePathUNIXlike: ...just path\n" if $debugging;
      $pathname = pKit_fixpath($pathname);
   }
   print DBGOUT "pKit_makePathUNIXlike] ...done(=\"$pathname\")\n" if $debugging;
   return $pathname;
}

# MyUniqueFileId: b27b57d9-57b2-4cfe-aa34-1af9efb86152
#-------------------------------------------------------------------------------
#
#  Translate all forward slashes in the given pathname to backslashes. Thus
#  converting it to a Windows-like style. Note that it also handles Cygwin-like
#  encoding of a drive letter (where C:\... is encoded as /C/... or /cygdrive/C/...).
#
#  see: totebag/src/pKit/makePathWindowslike.psub
#
#  Dated: 04Jul2020 pKit_makePathWindowslike
#
#-------------------------------------------------------------------------------

sub pKit_makePathWindowslike {
   my $pathname = shift;
   print DBGOUT "pKit_makePathWindowslike[ pathname=\"$pathname\"...\n" if $debugging;
   my $changed  = $pathname =~ tr/\\/\//;
   if (1 <= $changed) {
      print DBGOUT "pKit_makePathWindowslike: ...adjusted to \"$pathname\"\n" if $debugging;
   }
   if ($pathname =~ /^\/([a-zA-Z])(\/.*)$/) {
      print DBGOUT "pKit_makePathWindowslike: ...looks \"A\" cygwin-like\n" if $debugging;
      my $driveLetter = $1;
      my $remainder   = $2;
      print DBGOUT "pKit_makePathWindowslike:    has a drive letter(=\"$driveLetter\")\n" if $debugging;
      print DBGOUT "pKit_makePathWindowslike:    and \"$remainder\"\n" if $debugging;
      $pathname       = $driveLetter.":".$remainder
   }
   elsif ($pathname =~ /^\/cygdrive\/([a-zA-Z])(\/.*)$/) {
      print DBGOUT "pKit_makePathWindowslike: ...looks \"B\" cygwin-like\n" if $debugging;
      my $driveLetter = $1;
      my $remainder   = $2;
      print DBGOUT "pKit_makePathWindowslike:    has a drive letter(=\"$driveLetter\")\n" if $debugging;
      print DBGOUT "pKit_makePathWindowslike:    and \"$remainder\"\n" if $debugging;
      $pathname       = $driveLetter.":".$remainder
   }
   $pathname    =~ tr/\//\\/;
   if (1 <= $changed) {
      print DBGOUT "pKit_makePathWindowslike: ...adjusted back to \"$pathname\"\n" if $debugging;
   }
   print DBGOUT "pKit_makePathWindowslike] ...done(=\"$pathname\")\n" if $debugging;
   return $pathname;
}

# MyUniqueFileId: b90a4088-bb21-40f6-a8be-7ef0f940fb1b
#-------------------------------------------------------------------------------
#
#  This function is used to create a directory...
#
#     pKit_mkDirectory($pathname,$pflag)
#
#        $pathname
#
#           The pathname of the directory which is to be created.
#
#        $pflag
#
#           A flag, set if the parent (grandparent, ...) is to be created
#           if necessary. Analogous to mkdir's -p option.
#
#        $sponsor
#
#           Optional name of caller.
#
#  This function uses: pKit_dirname(),
#                      pKit_makePathNative(),
#                      pKit_mkDirectory() -- is recursive
#
#  see: totebag/src/pKit/mkDirectory.psub
#
#  Dated: 04Jul2020 pKit_mkDirectory
#
#-------------------------------------------------------------------------------

sub pKit_mkDirectory {
   my $pathname = shift;
   my $pFlag    = shift;
   my $sponsor  = shift;

   $pathname    = pKit_makePathNative($pathname);
   my $result;
   if ( -e $pathname) {
      if ( -d $pathname) {
         $result = 1;
      }
      else {
         $result = 0;
      }
   }
   else {
      if ($pFlag) {
         my $haveParent;
         my $Dname = pKit_dirname(pathname);
         if ( -d $Dname) {
            $haveParent = 1;
         }
         else {
            $haveParent = pKit_mkDirectory($Dname);
         }
         if ($haveParent) {
            $result = mkdir($pathname,0777);
         }
         else {
            $result = 0;
         }
      }
      else {
         $result = mkdir($pathname,0777);
      }
   }
   return $result;
}

# MyUniqueFileId: 6af5ed70-509a-46e3-c366-c864743c9ac3
#-------------------------------------------------------------------------------
#
#  This subroutine deletes a single pathname (directory, file, or symbolic-link)
#  If it exists but can't be properly deleted then it will fail with an error
#  message. Returns 1 on success, 0 on failure.
#
#  This function uses: pKit_deletePathnames()
#
#  see: totebag/src/pKit/mustDeletePathname.psub
#
#  Dated: 04Jul2020 pKit_mustDeletePathname
#
#  NOTE: This function is silent if there is no problem.
#
#-------------------------------------------------------------------------------

sub pKit_mustDeletePathname {
   my $callerIs  = shift;   # Something like: "tarup: "
   my $pathname  = shift;   # The pathname to be deleted.
   my $noisy     = shift;   # Pass 0 if silent failures.
   my $result    = 1;
   if ($pathname ne "") {
      my $exists = 0;
      if ( -l $pathname) {
         $exists = 1;
      }
      elsif ( -e $pathname) {
         $exists = 1;
      }
      if ($exists) {
         my @failures  = pKit_deletePathnames($pathname);
         my $Nfailures = $#failures + 1;
         if (1 <= $Nfailures) {
            $result = 0;
            if ($noisy) {
               my $count;
               my $failedOn;
               foreach $failedOn (@failures) {
                  $count += 1;
                  print STDERR $callerIs."error: can't delete \"$failedOn\"\n";
                  if (10 <= $count) {
                     print STDERR $callerIs."  :        :     :\n";
                     my $lastOne = $failures[$#failures];
                     print STDERR $callerIs."error: can't delete \"$lastOne\"\n";
                     last;
                  }
               }
            }
         }
      }
   }
   return $result;
}

# MyUniqueFileId: 5ff433a4-57d8-46b9-fd0c-b4cdb3cc330d
#-------------------------------------------------------------------------------
#
#  Convert canonical pathname to native pathname.
#
#     This function is used to convert the given pathname from the UNIX-style
#     canonical form (with forward slashes) to the native form (which on
#     Windows-like systems uses backslashes). It will also strip unneeded
#     enclosing quotes but will not add enclosing quotes even if they're
#     needed or were originally supplied. Use pKit_quoteIfReqd() to add
#     quoting when it could be needed.
#
#  This function uses: pKit_makePathNative()
#
#  see: totebag/src/pKit/nativePathname.psub
#
#  Dated: 04Jul2020 pKit_nativePathname
#
#-------------------------------------------------------------------------------

sub pKit_nativePathname {
   my $canonical = shift;
   my $native    = $canonical;
   #
   #  Strip enclosing quotes (if any)
   #
   while ($native =~ /^"(.*)"$/) {
      $native = $1;
   }
   while ($native =~ /^'(.*)'$/) {
      $native = $1;
   }
   #
   #  Translate to the native form
   #
   $native    = pKit_makePathNative($native);
   return $native;
}

# MyUniqueFileId: 37ea004f-1e46-4707-d3fd-2f830492fbae
#-------------------------------------------------------------------------------
#
#  Return pathname of null device.
#
#  This is the pseudo-file which absorbs but doesn't preserve characters. When
#  read it always returns EOF. On UNIX-like systems this is "/dev/null" but on
#  Windows-like systems this is simply "nul" (case insensitive). On any other
#  system (not UNIX- or Windows-like) an empty string is returned. In reality
#  the returned pathname is already in native form and never needs quoting.
#
#  This function uses: pKit_getOSclass()
#
#  see: totebag/src/pKit/nullPathname.psub
#
#  Dated: 01Jul2020 pKit_nullPathname
#
#-------------------------------------------------------------------------------

sub pKit_nullPathname {
   my $result;
   my $theOSclass = pKit_getOSclass();
   if ($theOSclass eq "UNIX-like") {
      $result = "/dev/null";
   }
   elsif ($theOSclass eq "Windows-like") {
      $result = "nul";
   }
   else {
      $result = "";
   }
   return $result;
}

# MyUniqueFileId: e2fca5a7-5675-40b1-b2a8-4aba77b8d94e
#-------------------------------------------------------------------------------
#
#  Check if pathname exists.
#
#  This function is used to check if the given pathname exists. Note that no
#  other information may be implied from this (the function doesn't particularly
#  care about what it is -- directory, file, symbolic-link, ...).
#
#  see: totebag/src/pKit/pathExists.psub
#
#  Dated: 04Jul2020 pKit_pathExists
#
#-------------------------------------------------------------------------------

sub pKit_pathExists {
   my $pathname = shift;
   print DBGOUT "pKit_pathExists[ pathname=\"$pathname\"...\n" if $debugging;
   my $result;
   if ($osClass eq "UNIX-like") {
      if ( -l $pathname) {
         print DBGOUT "pKit_pathExists: ...\"$pathname\" is a symbolic-link\n" if $debugging;
         $result = 1;
      }
      elsif ( -e $pathname) {
         print DBGOUT "pKit_pathExists: ...\"$pathname\" exists\n" if $debugging;
         $result = 1;
      }
      else {
         print DBGOUT "pKit_pathExists: ...\"$pathname\" doesn't exist\n" if $debugging;
         $result = 0;
      }
   }
   else {
      if ( -e $pathname) {
         print DBGOUT "pKit_pathExists: ...\"$pathname\" exists\n" if $debugging;
         $result = 1;
      }
      else {
         print DBGOUT "pKit_pathExists: ...\"$pathname\" doesn't exist\n" if $debugging;
         $result = 0;
      }
   }
   print DBGOUT "pKit_pathExists] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: a9e6b24e-5f72-4998-a4f9-e5345d2187c6
#-------------------------------------------------------------------------------
#
#  Prepend a pathname to the search path.
#
#  Prepend a pathname (string) to an array of pathnames (such as found in the
#  PATH environment variable or returned by the pKit_getTheSearchPATH() function).
#  Note that the first parameter is expected to be a reference to an array of
#  strings (pathnames). Simple example:
#
#     my $myPATH = pKit_getTheSearchPATH();
#     my @myPATH = pKit_splitTheSearchPATH($myPATH);
#     if ( ! pKit_alreadyOnSearchPATH($dirPathname,\@myPATH)) {
#        @myPATH = pKit_prependToSearchPATH($dirPathname,\@myPATH);
#        $myPATH = pKit_joinTheSearchPATH(\@myPATH);
#     }
#
#  calls: pKit_getOSclass(),
#         pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/prependToSearchPATH.psub
#
#  Dated: 04Jul2020 pKit_prependToSearchPATH
#
#-------------------------------------------------------------------------------

sub pKit_prependToSearchPATH {
   my $pathname   = shift;   # A pathname to prepend.
   my $refMyPATH  = shift;   # A reference to an array of pathnames
   my $theOSclass = shift;   # ...an optional parameter
   print DBGOUT "pKit_prependToSearchPATH[ pathname=\"$pathname\"...\n" if $debugging;
   if ($pathname ne "") {
      #
      #  Adjust pathname if necessary
      #
      if ($theOSclass eq "") {
         $theOSclass = pKit_getOSclass();
      }
      if ($theOSclass eq "Windows-like") {
         if ($pathname =~ /[\/\\]/) {
            my $p = pKit_makePathWindowslike($pathname);
            if ($p ne $pathname) {
               $pathname = $p;
               print DBGOUT "pKit_prependToSearchPATH: ...adjusted to \"$pathname\"\n" if $debugging;
            }
         }
      }
      #
      #  Check if pathname is already in array
      #
      print DBGOUT "pKit_prependToSearchPATH: ...looking for \"$pathname\"\n" if $debugging;
      my $alreadyKnown = 0;
      my $size         = @$refMyPATH;
      my $i;
      for ($i=0; $i<$size; ++$i) {
         if ($$refMyPATH[$i] eq $pathname) {
            $alreadyKnown = 1;
            print DBGOUT "pKit_prependToSearchPATH:    found\n" if $debugging;
            last;
         }
      }
      #
      #  ...if not then prepend it to start of
      #     the array (as first element).
      #
      if ( ! $alreadyKnown) {
         print DBGOUT "pKit_prependToSearchPATH: ...prepend \"$pathname\"\n" if $debugging;
         unshift @$refMyPATH, $pathname;
         if ($debugging) {
            my $size = @$refMyPATH;
            my $i;
            for ($i=0; $i<$size; ++$i) {
               my $thisPathname = $$refMyPATH[$i];
               if ($i == 0) {
                  print DBGOUT "pKit_prependToSearchPATH: ...gives: \"$thisPathname\"\n";
               }
               else {
                  print DBGOUT "pKit_prependToSearchPATH:           \"$thisPathname\"\n";
               }
            }
         }
      }
   }
   print DBGOUT "pKit_prependToSearchPATH] ...done\n" if $debugging;
   return @$refMyPATH;
}

# MyUniqueFileId: 3c057bb8-8eba-4030-b741-8d0a25a3b1f5
#-------------------------------------------------------------------------------
#
#  "Quoting" a pathname. This function returns a copy of the given pathname
#  with quotes if the given pathname contains any "special" characters.
#  Note that the content between the added quotes is the same as what was
#  given except embedded quotes are backslashed on UNIX-like hosts. On
#  Windows-like hosts if the given pathname contains a double-quote then
#  enclosing single-quotes will be used.
#
#  This function uses: pKit_getOSclass()
#
#  see: totebag/src/pKit/quoteIfReqd.psub
#
#  Dated: 04Jul2020 pKit_quoteIfReqd
#
#-------------------------------------------------------------------------------

sub pKit_quoteIfReqd {
   my $pathname     = shift;
   my $told_osStyle = shift;
   my $result       = "";
   if ($pathname ne "") {
      if ($pathname =~ /^".*"$/) {
         $result = $pathname;
      }
      else {
         if ($told_osStyle eq "") {
            $told_osStyle = pKit_getOSclass();
         }
         if ($told_osStyle eq "UNIX-like") {
            if ($pathname =~ /['"`<>|;\s()\[\]\?\#\$^&\*=\\]/) {
               $_      = $pathname;
                         s/(")/\\$1/g;
               $result = "\"".$_."\"";
            }
            else {
               $result = $pathname;
            }
         }
         else {
            if ($pathname =~ /['"<>|\s()^&@]/) {
               if ($pathname =~ /"/) {
                  $_      = $pathname;
                            s/(")/\\$1/g;
                  $result = "'".$_."'";
               }
               else {
                  $_      = $pathname;
                            s/(")/\\$1/g;
                  $result = "\"".$_."\"";
               }
            }
            else {
               $result = $pathname;
            }
         }
      }
   }
   return $result;
}

# MyUniqueFileId: 46ad3315-c658-44e1-dd11-0380e9da8bc3
#-------------------------------------------------------------------------------
#
#  Follow/expand symbolic-links in pathname.
#
#  All symbolic-links in the given pathname are resolved (followed) constructing
#  a new return pathname that is "real" (without symbolic-links). An empty string
#  is returned on failure. On Windows-like hosts
#
#  The parameters are: pathname (a string)
#                      optional OS class
#                      optional count (limit on hops)
#
#  This function uses: pKit_basename(),
#                      pKit_dirname(),
#                      pKit_fixpath(),
#                      pKit_getOSclass(),
#                      pKit_isRoot(),
#                      pKit_joinpath(),
#                      pKit_pathExists()
#
#  see: totebag/src/pKit/realpath.psub
#
#  Dated: 04Jul2020 pKit_realpath
#
#-------------------------------------------------------------------------------

sub pKit_realpath {
   my $pathname = shift;
   my $osClass  = shift; # optional
   my $count    = shift; # optional
   print DBGOUT "pKit_realpath[ pathname=\"$pathname\", osClass=\"$osClass\", count=[$count]...\n" if $debugging;
   if ($osClass eq "") {
      $osClass  = pKit_getOSclass();
      print DBGOUT "pKit_realpath: ...OS class is actually \"$osClass\"\n" if $debugging;
   }
   if ( ! ($count =~ /^\d+$/)) {
      $count    = 32;
      print DBGOUT "pKit_realpath: ...assume count is $count\n" if $debugging;
   }
   my $result   = "";
   if (pKit_pathExists($pathname,$osClass)) {
      print DBGOUT "pKit_realpath: ...\"$pathname\" actually exists\n" if $debugging;
      my $adjusted = pKit_fixpath($pathname);
      if ($adjusted ne $pathname) {
         $pathname = $adjusted;
         print DBGOUT "pKit_realpath:    pathname adjusted to \"$pathname\"\n" if $debugging;
      }
      if ($osClass eq "UNIX-like") {
         print DBGOUT "pKit_realpath: ...host is UNIX-like\n" if $debugging;
         if ( ! pKit_isRoot($pathname)) {
            print DBGOUT "pKit_realpath:    \"$pathname\" isn't root directory\n" if $debugging;
            my $bn = pKit_basename($pathname);
            if ($bn ne $pathname) {
               print DBGOUT "pKit_realpath:    \"$pathname\" is complex\n" if $debugging;
               #{---------------------------------------------------------------
               #
               #  Recursively consider the directory part.
               #
               #----------------------------------------------------------------
               my $dn = pKit_dirname($pathname);
               my $rp = pKit_realpath($dn,$osClass);
               if ($rp ne $dn) {
                  $pathname = pKit_joinpath($rp,$bn);
                  print DBGOUT "pKit_realpath:    ...adjusted to \"$pathname\"\n" if $debugging;
               }
               #}---------------------------------------------------------------
            }
            else {
               print DBGOUT "pKit_realpath:    \"$pathname\" is simple\n" if $debugging;
            }
            #{------------------------------------------------------------------
            #
            #  Problem looks like it is worth doing.
            #
            #-------------------------------------------------------------------
            my $startedWith = $pathname;
            print DBGOUT "pKit_realpath: ...starting with \"$startedWith\"\n" if $debugging;
            my $count       = 32;
            while ( -l $pathname) {
               print DBGOUT "pKit_realpath:    \"$pathname\" is a symbolic-link\n" if $debugging;
               my $target = readlink($pathname);
               my $dn     = pKit_dirname($pathname);
               $pathname  = pKit_joinpath($dn,$target);
               $count    -= 1;
               if ($count <= 0) {
                  print DBGOUT "pKit_realpath:    ...symbolic-link chain is too long\n" if $debugging;
                  $pathname = $startedWith;
                  print DBGOUT "pKit_realpath:       back to \"$pathname\"\n" if $debugging;
                  last;
               }
            }
            print DBGOUT "pKit_realpath:    done\n" if $debugging;
            $result = pKit_fixpath($pathname);
            #}------------------------------------------------------------------
         }
         else {
            print DBGOUT "pKit_realpath: ...is root directory\n" if $debugging;
         }
      }
      else {
         print DBGOUT "pKit_realpath: ...host is not UNIX-like\n" if $debugging;
         $result = $pathname;
      }
   }
   else {
      print DBGOUT "pKit_realpath: ...\"$pathname\" doesn't actually exist\n" if $debugging;
      $result = "";
   }
   print DBGOUT "pKit_realpath] ...done(=\"$result\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: cc8ac2e4-bd0d-4c17-c64a-e852bed0d90f
#-------------------------------------------------------------------------------
#
#  This subroutine deletes a single pathname (directory, file, or symbolic-link)
#  Returns an array of those pathnames that couldn't be deleted.
#
#  This function uses: pKit_deletePathnames(),
#                      pKit_makePathNative()
#
#  see: totebag/src/pKit/shouldDeletePathname.psub
#
#  Dated: 04Jul2020 pKit_shouldDeletePathname
#
#-------------------------------------------------------------------------------

sub pKit_shouldDeletePathname {
   my $pathname = shift;
   $pathname    = pKit_makePathNative($pathname);
   my @failures = ();
   if ($pathname ne "") {
      my $exists = 0;
      if ( -l $pathname) {
         $exists = 1;
      }
      elsif ( -e $pathname) {
         $exists = 1;
      }
      if ($exists) {
         @failures = pKit_deletePathnames($pathname);
      }
   }
   return @failures;
}

# MyUniqueFileId: 7b1bd298-6cb1-478a-8d02-9eee62a15d0a
#-------------------------------------------------------------------------------
#
#  This function is used to read a given file returning the contents of
#  the ENTIRE FILE as an array of strings (retaining all embedded whitespace).
#
#  see: totebag/src/pKit/slurpPathnameIntoArray.psub
#
#  Dated: 01Jul2020 pKit_slurpPathnameIntoArray
#
#-------------------------------------------------------------------------------

sub pKit_slurpPathnameIntoArray {
   my $pathname  = shift;
   my $sponsor   = shift;
   my @contents;
   if ( open(F, "< $pathname") ) {
      while (<F>) {
         chomp; s/\r$//;
         $contents[$#contents+1] = $_;
      }
      close F;
   }
   else {
      if ($sponsor ne "") {
         print STDERR $sponsor.": can't find/read \"$pathname\"\n" if $sponsor ne "";
         exit 1;
      }
   }
   return @contents;
}

# MyUniqueFileId: 8c4752ad-7b22-47ab-8eb8-8d684d548421
#-------------------------------------------------------------------------------
#
#  Split the command search path.
#
#  Returns an array of pathnames found in the given search path string (such
#  as found in the PATH environment variable or from the pKit_getTheSearchPATH()
#  function. Note that the division markers typically depend on the OS hosting
#  this script. UNIX-like hosts normally split on colons (:) and Windows-like
#  hosts split on semicolons (;) but cygwin may complicate things on Windows-like
#  hosts as cygwin split on colons. However since directory pathnames should
#  never contain semicolons just the fact that PATH environment variable
#  contains semicolons normally indicates that it is a Windows-style pathname
#  and should be split on semicolons.
#
#  Note that this function doesn't treat empty components in any special fashion.
#
#  This function uses: pKit_getOSclass(),
#                      pKit_makePathWindowslike()
#
#  see: totebag/src/pKit/splitTheSearchPATH.psub
#
#  Dated: 04Jul2020 pKit_splitTheSearchPATH
#
#-------------------------------------------------------------------------------

sub pKit_splitTheSearchPATH {
   my $thePATH    = shift;   # Such as from pKit_getTheSearchPATH()
   my $theOSclass = shift;   # ...an optional parameter
   print DBGOUT "pKit_splitTheSearchPATH[ thePATH=\"$thePATH\", theOSclass=\"$theOSclass\"...\n" if $debugging;
   my @splitPATH  = ( );
   if ($theOSclass eq "") {
      $theOSclass = pKit_getOSclass();
      print DBGOUT "pKit_splitTheSearchPATH: ...detected theOSclass=\"$theOSclass\"\n" if $debugging;
   }
   if ($theOSclass eq "UNIX-like") {
      print DBGOUT "pKit_splitTheSearchPATH: ...host is \"UNIX-like\", split on colons\n" if $debugging;
      @splitPATH = split /:/, $thePATH;
   }
   elsif ($theOSclass eq "Windows-like") {
      print DBGOUT "pKit_splitTheSearchPATH: ...host is \"Windows-like\"\n" if $debugging;
      #
      #  Count number of semicolons...
      #
      my $s       = $thePATH;
      my $Nsemi   = $s =~ tr/;//;
      $s          = $thePATH;
      my $Ncolons = $s =~ tr/://;
      if ($debugging) {
         print DBGOUT "pKit_splitTheSearchPATH:    $thePATH contains no semicolons\n" if ($debugging && ($Nsemi == 0));
         print DBGOUT "pKit_splitTheSearchPATH:    $thePATH contains 1 semicolon\n" if ($debugging && ($Nsemi == 1));
         print DBGOUT "pKit_splitTheSearchPATH:    $thePATH contains $Nsemi semicolons\n" if ($debugging && (2 <= $Nsemi));
         print DBGOUT "pKit_splitTheSearchPATH:    $thePATH contains no colons\n" if ($debugging && ($Ncolons == 0));
         print DBGOUT "pKit_splitTheSearchPATH:    $thePATH contains 1 colon\n" if ($debugging && ($Ncolons == 1));
         print DBGOUT "pKit_splitTheSearchPATH:    $thePATH contains $Ncolons colons\n" if ($debugging && (2 <= $Ncolons));
      }
      if (1 <= $Nsemi) {
         print DBGOUT "pKit_splitTheSearchPATH:    ...looks \"Windows-like\", split on semicolons\n" if $debugging;
         @splitPATH = split /;/, $thePATH;
      }
      else {
         print DBGOUT "pKit_splitTheSearchPATH:    ...looks \"UNIX-like\" split on colons\n" if $debugging;
         @splitPATH = split /:/, $thePATH;
      }
      print DBGOUT "pKit_splitTheSearchPATH:    ...repair individual pathnames\n" if $debugging;
      my $i;
      for ($i=0; $i<=$#splitPATH; $i+=1) {
         my $component = $splitPATH[$i];
         if ($component ne "") {
            my $repaired = pKit_makePathWindowslike($component);
            if ($repaired ne $component) {
               $splitPATH[$i] = $repaired;
               print DBGOUT "pKit_splitTheSearchPATH:       \"".$component."\" ---> \"".$splitPATH[$i]."\"\n" if $debugging;
            }
         }
      }
   }
   else {
      print DBGOUT "pKit_splitTheSearchPATH: ...host is neither \"UNIX-like\" nor \"Windows-like\"\n" if $debugging;
      @splitPATH  = ( );
   }
   if ($debugging) {
      my $i;
      for ($i=0; $i<=$#splitPATH; $i+=1) {
         my $pathname = $splitPATH[$i];
         if ($i == 0) {
            print DBGOUT "pKit_splitTheSearchPATH: ...gives: \"$pathname\"\n" if $debugging;
         }
         else {
            print DBGOUT "pKit_splitTheSearchPATH:           \"$pathname\"\n" if $debugging;
         }
      }
      print DBGOUT "pKit_splitTheSearchPATH] ...done\n" if $debugging;
   }
   return @splitPATH;
}

# MyUniqueFileId: d10a2ee1-2593-4a09-fd40-f6314a9dd348
#-------------------------------------------------------------------------------
#
#  This function is used to extract the suffix from a given pathname. Note
#  that this kind of operation is generally available in the File module.
#
#  see: totebag/src/pKit/suffix.psub
#
#  Dated: 04Jul2020 pKit_suffix
#
#-------------------------------------------------------------------------------

sub pKit_suffix {
   my $pathname = shift(@_);
   print DBGOUT "pKit_suffix[ pathname=\"$pathname\"...\n" if $debugging;
   my $result   = "";
   if ( $pathname =~ /^(.+)(\.[^\/\\.]+)$/ ) {
      $result = $2;
   }
   else {
      $result = "";
   }
   print DBGOUT "pKit_suffix] ...done(=\"$pathname\")\n" if $debugging;
   return $result;
}

# MyUniqueFileId: dfa6bae9-850b-4793-8ae2-816ce3c0fde8
#-------------------------------------------------------------------------------
#
#  Touch a file...
#
#     This function is used to set the modification time of the given pathname
#     to the current time. Note that it will create an empty file of the given
#     pathname if it doesn't already exist.
#
#  This function uses: pKit_dirname(),
#                      pKit_makeDirectory()
#
#  see: totebag/src/pKit/touchPathname.psub
#
#  Dated: 01Jul2020 pKit_touchPathname
#
#-------------------------------------------------------------------------------

sub pKit_touchPathname {
   my $pathname = shift;
   my $sponsor  = shift;
   my $result   = 1;
   my $underDir = pKit_dirname($pathname);
   if ($underDir ne "") {
      if ( ! -e $underDir) {
         if ( ! pKit_makeDirectory($underDir,$underDir,1,0,$sponsor)) {
            print STDERR "$sponsor: can't create \"$underDir\"\n" if $sponsor ne "";
            $result = 0;
         }
      }
      elsif ( ! -d $underDir) {
         print STDERR "$sponsor: \"$underDir\" already exists but is not a directory\n" if $sponsor ne "";
         $result = 0;
      }
   }
   if ($result) {
      if ( ! -e $pathname) {
         if (open(THEFILE,"> $pathname")) {
            close(THEFILE);
         }
         else {
            print STDERR "$sponsor: can't create/write \"$pathname\"\n" if $sponsor ne "";
            $result = 0;
         }
      }
      elsif ( ! -f $pathname) {
         print STDERR "$sponsor: \"$pathname\" exists but is not a file\n" if $sponsor ne "";
         $result = 0;
      }
   }
   if ($result) {
      my $useTime = time();
      if ( ! utime($useTime,$useTime,$pathname)) {
         print STDERR "$sponsor: can't set modification time of \"$pathname\"\n" if $sponsor ne "";
         $result = 0;
      }
   }
   return $result;
}

# MyUniqueFileId: 20123055-0c01-4dbb-e091-86664b652380
#-------------------------------------------------------------------------------
#
#  This subroutine is used to translate a shell-style globbing pattern to a
#  regular expression.
#
#  see: totebag/src/pKit/translateGlobPatternToRegExp.psub
#
#  Dated: 01Jul2020 pKit_translateGlobPatternToRegExp
#
#-------------------------------------------------------------------------------

sub pKit_translateGlobPatternToRegExp {
   my $given = shift;
   print DBGOUT "pKit_translateGlobPatternToRegExp[ given=\"$given\"...\n" if $debugging;
   my $gives = "\^";
   my @chars = split(//,$given);
   my $state = 0;
   print DBGOUT "pKit_translateGlobPatternToRegExp: ...scan\n" if $debugging;
   my $i;
   for ($i=0; $i<=$#chars; $i+=1) {
      my $c = $chars[$i];
      print DBGOUT "pKit_translateGlobPatternToRegExp:    state $state -- got \'$c\'\n" if $debugging;
      $_    = $state;
      switch: {
                /0/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...zero\n" if $debugging;
                       $_ = $c;
                       switch_0: {
                                   /^\*$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading star\n" if $debugging;
                                             $gives = $gives."\.\*";
                                             $state = 1;
                                             last switch_0;
                                          };
                                   /^\?$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading question\n" if $debugging;
                                             $gives = $gives."\.";
                                             $state = 1;
                                             last switch_0;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 1;
                                             last switch_0;
                                          };
                                   /^\[$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading square\n" if $debugging;
                                             $gives = $gives."[";
                                             $state = 6;
                                             last switch_0;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']'\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading curly\n" if $debugging;
                                             $gives = $gives."(";
                                             $state = 3;
                                             last switch_0;
                                          };
                                   /^,$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading comma\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 1;
                                             last switch_0;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}'\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...leading normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 1;
                                             last switch_0;
                                          };
                       }
                       last switch;
                    };
                /1/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...one\n" if $debugging;
                       $_ = $c;
                       switch_1: {
                                   /^\*$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal star\n" if $debugging;
                                             $gives = $gives."\.\*";
                                             $state = 1;
                                             last switch_1;
                                          };
                                   /^\?$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal question\n" if $debugging;
                                             $gives = $gives."\.";
                                             $state = 1;
                                             last switch_1;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 1;
                                             last switch_1;
                                          };
                                   /^\[$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal square\n" if $debugging;
                                             $gives = $gives."[";
                                             $state = 6;
                                             last switch_1;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']'\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal curly\n" if $debugging;
                                             $gives = $gives."(";
                                             $state = 3;
                                             last switch_1;
                                          };
                                   /^,$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal comma\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 1;
                                             last switch_1;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}'\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 1;
                                             last switch_1;
                                          };
                       }
                       last switch;
                    };
                /2/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...two\n" if $debugging;
                       $_ = $c;
                       switch_2: {
                                   /^\*$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal star\n" if $debugging;
                                             $gives = $gives."\.\*";
                                             $state = 1;
                                             last switch_2;
                                          };
                                   /^\?$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal question\n" if $debugging;
                                             $gives = $gives."\.";
                                             $state = 1;
                                             last switch_2;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 1;
                                             last switch_2;
                                          };
                                   /^\[$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal square\n" if $debugging;
                                             $gives = $gives."[";
                                             $state = 6;
                                             last switch_2;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']'\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal curly\n" if $debugging;
                                             $gives = $gives."(";
                                             $state = 3;
                                             last switch_2;
                                          };
                                   /^,$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal comma\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 1;
                                             last switch_2;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}'\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...internal normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 1;
                                             last switch_2;
                                          };
                       }
                       last switch;
                    };
                /3/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...three\n" if $debugging;
                       $_ = $c;
                       switch_3: {
                                   /^\*$/ && do {
                                             print STDERR "p-grep: unexpected '*' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\?$/ && do {
                                             print STDERR "p-grep: unexpected '?' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 4;
                                             last switch_3;
                                          };
                                   /^\[$/ && do {
                                             print STDERR "p-grep: unexpected '[' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print STDERR "p-grep: unexpected '{' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^,$/  && do {
                                             print STDERR "p-grep: unexpected ',' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 4;
                                             last switch_3;
                                          };
                       }
                       last switch;
                    };
                /4/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...four\n" if $debugging;
                       $_ = $c;
                       switch_4: {
                                   /^\*$/ && do {
                                             print STDERR "p-grep: unexpected '*' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\?$/ && do {
                                             print STDERR "p-grep: unexpected '?' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 4;
                                             last switch_4;
                                          };
                                   /^\[$/ && do {
                                             print STDERR "p-grep: unexpected '[' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print STDERR "p-grep: unexpected '{' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^,$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly comma\n" if $debugging;
                                             $gives = $gives."|";
                                             $state = 5;
                                             last switch_4;
                                          };
                                   /^\}$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly curly\n" if $debugging;
                                             $gives = $gives.")";
                                             $state = 1;
                                             last switch_4;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 4;
                                             last switch_4;
                                          };
                       }
                       last switch;
                    };
                /5/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...five\n" if $debugging;
                       $_ = $c;
                       switch_5: {
                                   /^\*$/ && do {
                                             print STDERR "p-grep: unexpected '*' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\?$/ && do {
                                             print STDERR "p-grep: unexpected '?' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 4;
                                             last switch_5;
                                          };
                                   /^\[$/ && do {
                                             print STDERR "p-grep: unexpected '[' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print STDERR "p-grep: unexpected '{' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^,$/  && do {
                                             print STDERR "p-grep: unexpected ',' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}' in {...} construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                             last switch_5;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...curly normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 4;
                                             last switch_5;
                                          };
                       }
                       last switch;
                    };
                /6/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...six\n" if $debugging;
                       $_ = $c;
                       switch_6: {
                                   /^\*$/ && do {
                                             print STDERR "p-grep: unexpected '*' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\?$/ && do {
                                             print STDERR "p-grep: unexpected '?' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 7;
                                             last switch_6;
                                          };
                                   /^\[$/ && do {
                                             print STDERR "p-grep: unexpected '[' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\]$/ && do {
                                             print STDERR "p-grep: unexpected ']' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\{$/ && do {
                                             print STDERR "p-grep: unexpected '{' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^,$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square comma\n" if $debugging;
                                             $gives = $gives.",";
                                             $state = 7;
                                             last switch_6;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 7;
                                             last switch_6;
                                          };
                       }
                       last switch;
                    };
                /7/ && do {
                       print DBGOUT "pKit_translateGlobPatternToRegExp:    ...siz\n" if $debugging;
                       $_ = $c;
                       switch_7: {
                                   /^\*$/ && do {
                                             print STDERR "p-grep: unexpected '*' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\?$/ && do {
                                             print STDERR "p-grep: unexpected '?' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\.$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square dot\n" if $debugging;
                                             $gives = $gives."\\\.";
                                             $state = 7;
                                             last switch_7;
                                          };
                                   /^\[$/ && do {
                                             print STDERR "p-grep: unexpected '[' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^\]$/ && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square square\n" if $debugging;
                                             $gives = $gives."]";
                                             $state = 1;
                                             last switch_7;
                                          };
                                   /^\{$/ && do {
                                             print STDERR "p-grep: unexpected '{' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^,$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square comma\n" if $debugging;
                                             $gives = $gives.",";
                                             $state = 7;
                                             last switch_7;
                                          };
                                   /^\}$/ && do {
                                             print STDERR "p-grep: unexpected '}' in [...] construct\n";
                                             close DBGOUT if $dbgOutToPathname ne "";
                                             exit 1;
                                          };
                                   /^.$/  && do {
                                             print DBGOUT "pKit_translateGlobPatternToRegExp:    ...square normal\n" if $debugging;
                                             $gives = $gives.$c;
                                             $state = 7;
                                             last switch_7;
                                          };
                       }
                       last switch;
                    };
      }
   }
   print DBGOUT "pKit_translateGlobPatternToRegExp:    done in state $state\n" if $debugging;
   if ($state != 1 && $state != 2) {
      print STDERR "p-grep: unexpected <end-of-string>\n";
      close DBGOUT if $dbgOutToPathname ne "";
      exit 1;
   }
   $gives = $gives."\$";
   print DBGOUT "pKit_translateGlobPatternToRegExp] ...done(=\"$gives\")\n" if $debugging;
   return $gives;
}

# MyUniqueFileId: 31fb3037-130d-4150-fe5e-d0e8e636135e
#-------------------------------------------------------------------------------
#
#  Unquote a string (generally a pathname). Returns a copy of the given string
#  with any enclosing quotes (double or single) removed.
#
#  see: totebag/src/pKit/unquote.psub
#
#  Dated: 01Jul2020 pKit_unquote
#
#-------------------------------------------------------------------------------

sub pKit_unquote {
   my $given  = shift;
   my $result = "";
   if ($given =~ /^"(.*)"$/) {
      $result = $1;
   }
   elsif ($given =~ /^'(.*)'$/) {
      $result = $1;
   }
   else {
      $result = $given;
   }
   return $result;
}

# MyUniqueFileId: 4a1ca40a-2769-45a8-dd88-74686e4806a7
#-------------------------------------------------------------------------------
#
#  This is the subroutine which generates help output for the mkinstaller
#  tool itself. Somehow we've got to merge common functionality with html
#  the replicated work is just awful.
#
#-------------------------------------------------------------------------------

sub help {
   print STDOUT pKit_fixIndentStuff(<<"EOF1");
   |
   |mkinstaller(1x)                                                  mkinstaller(1x)
   |
   |NAME
   |    mkinstaller -- Generate self-extracting installer.
   |
   |USAGE
   |    mkinstaller --copyright
   |    mkinstaller --help
   |    mkinstaller --html <pathname>
   |    mkinstaller --vernum
   |    mkinstaller --version
   |
   |    mkinstaller [<options> ...] <pathname> ...
   |
   |DESCRIPTION
   |    This script is used to generate an "installer" script implemented as
   |    a Bourne-shell script on UNIX-like systems (such as Linux, MacOS, or
   |    Solaris) or as a binary executable on Windows-like systems. A wide
   |    assortment of options are provided by mkinstaller to specify what is
   |    to be included for installation by the generated installer script.
   |    This generated installer itself supports a number of options for
   |    specifying the where the various directories are to be installed
   |    (prefix directory pathnames).
   |
   |    There are 2 separate computer systems involved in this process:
   |
   |       1) The "source" system. This is where the software to be installed
   |          is found and where the mkinstaller script (the generator) is
   |          used. On Windows-like hosts the NSIS software package must
   |          have been properly installed on the "source" system.
   |
   |       2) The "target" system. This is where the generated installer
   |          script is run, where the software is to be installed. Note
   |          that the NSIS software package is NOT required on the "target"
   |          system.
   |
   |    There are 3 pieces of software involved:
   |
   |       1) The software to be installed. This is the software (binaries
   |          and/or text) located on the "source" system whose components
   |          have been built and is deemed ready for distribution.
   |
   |       2) The mkinstaller script. Note that on a Windows-like host
   |          the NSIS software must be properly installed. The mkinstaller
   |          script requires NSIS to generate the desired installer. NSIS
   |          will NOT be required on the "target" system.
   |
   |       3) The generated installer script. On a UNIX-like host this is
   |          a Bourne-shell script generated by the mkinstaller script.
   |          On a Windows-like host this is a binary executable (a .exe
   |          file) that is generated by the mkinstaller script using the
   |          NSIS package under the covers.
   |
   |    There are 4 distinct phases or times involved in this process:
   |
   |       1) "Build-time". This is the time when the software (binaries
   |          and/or text files) is built and installed on the "source" system.
   |          How this software is built and installed is not discussed here.
   |
   |       2) "Generation-time". This is the time when mkinstaller is used
   |          to collect the software that was produced in phase 1 and generate
   |          the installer script. Like phase 1, this is also done on the
   |          "source" system.
   |
   |       3) "Transport". This is the process of taking a copy of the
   |          generated installer script that was generated in phase 2 from
   |          the "source" system to the "target" system. The details of this
   |          are not discussed here however such transport generally
   |          involves scp, ftp, curl, CD, DVD, USB-drive, or a download from
   |          a web site.
   |
   |       4) "Installation-time". this is the time when the installer
   |          script that was generated by mkinstaller in phase 2 is executed
   |          on the "target" system.
   |
   |    UNIX-like host
   |
   |       On a UNIX-like host such as Linux, MacOS, or Solaris the generated
   |       installer script is implemented as a self-extracting Bourne-shell
   |       script carrying a tarball as a payload. Note that mkinstaller
   |       requires tar on UNIX-like hosts. This is normally not a problem
   |       as almost every UNIX-like system provides tar. On some UNIX-like
   |       hosts (most notably Solaris) tar doesn't support compression. On
   |       such systems mkinstaller will require gzcat and gzip to support
   |       compression.
   |
   |       The installation process on a UNIX-like target system is done by
   |       simply running the generated installer script using the --prefix
   |       option to supply the installation directory. For example:
   |
   |           ./banana-installer -v --prefix=/opt/banana
   |
   |       Note that on UNIX-like hosts the --prefix=<pathname> option isn't
   |       really optional, it is required. Also note that use of the -v
   |       option (verbose mode) is recommended as the generated installer
   |       normally produces no output other than remarks, warnings, and/or
   |       error messages.
   |
   |    Windows-like host
   |
   |       On a Windows-like host (such as Windows 7 or Windows 10) the
   |       generated installer is implemented as a binary executable which
   |       is actually generated under the covers by NSIS (Nullsoft Scripted
   |       Install System). NSIS is required by mkinstaller on Windows-like
   |       hosts. Note that NSIS is open source and is freely available at:
   |
   |           https://sourceforge.net/projects/nsis
   |
   |       The installation process on a Windows-like target system is done by
   |       simply running the generated installer binary executable. Unlike an
   |       installer produced for UNIX-like hosts, an installer for Windows-like
   |       hosts may perform the installation to a default location; the user's
   |       desktop:
   |
   |          banana-installer.exe
   |
   |       The installer executable puts-up a dialog box resembling:
   |
   |                       [ see installer-dialog.gif ]
   |
   |                      Typical installation dialog box
   |
   |       The installation dialog box allows the user to specify the installation
   |       "prefix" directory by replacing the default pathname with the desired
   |       pathname or using the browser button to locate and select a pathname.
   |
   |       To specify an installation prefix on the command line the /D=<pathname>
   |       option may be used:
   |
   |          banana-installer.exe /D=E:\\opt\\banana
   |
   |OPTIONS
   |    "mkinstaller" supports the following options:
   |
   |        --copyright
   |
   |            Output copyright and license info to <stdout> and quit.
   |
   |        --help
   |
   |            Output this man page to <stdout> and quit.
   |
   |        --html <pathname>
   |
   |            Output this man page as HTML to the given file pathname and quit.
   |
   |        --vernum
   |
   |            Output version number to <stdout> and quit.
   |
   |        --version
   |
   |            Output version number and revision date to <stdout> and quit.
   |
   |        -c <name>
   |        --create=<name>
   |
   |            The name of the script to generate. It is generally not advisable
   |            to include a suffix (aka. extension) as part of the script name.
   |            Also note that this is not a pathname, is is the simple name of
   |            the script file which is to be created in the current directory.
   |            By default the script will be named "installer".
   |
   |        --cc=<name>
   |
   |            This option has been obsoleted. Use CC=<name> and CC-options=<string>
   |            instead.
   |
   |        --cxx=<name>
   |
   |            This option has been obsoleted. Use CXX=<name> and CXX-options=<string>
   |            instead.
   |
   |        CC=<name>
   |        CC=[<pathname>,<name>]
   |        --CC=<name>
   |        --CC=[<pathname>,<name>]
   |
   |            Used to specify the name of the C compiler used. For historical
   |            reasons the leading double-dashes are optional.
   |
   |            Note that there are 2 forms accepted for the option's argument:
   |
   |            1) A simple compiler name such as "gcc" or "icc". This is the
   |               name of the C compiler that was used to produce the binaries
   |               to be installed. For example:
   |
   |                   CC=gcc
   |
   |               In this case the gcc GNU C compiler was used to produce the
   |               binaries (executables and libraries). Note that if <name> has
   |               directory components only the basename will be used.
   |
   |            2) A comma separated pair enclosed in square brackets. The first
   |               component is the actual pathname of the C compiler that was
   |               used to produce the binaries to be installed. The second
   |               component is a name by which the compiler will be considered.
   |               For example:
   |
   |                   CC='[/usr/lib64/ccache/cc,gcc]'
   |
   |               In this case a C compiler with the pathname "/usr/lib64/ccache/cc"
   |               was actually used but consider it to be "gcc".
   |
   |            The first form is really a special case where the basename of the
   |            pathname is the same as the simple name of the C compiler.
   |
   |            This option almost always needs quoting as shown above since the
   |            square-brackets are considered to have special meaning by the shell.
   |
   |        CC-options=<string>
   |        --CC-options=<string>
   |
   |            Used to specify the options to be used with the C compiler used.
   |            Only special options such as the language standard assumed are
   |            to be specified. Define -D<name>, include pathname -I<pathname>,
   |            and library pathname -L<pathname> (along with library names) are
   |            not normally used. The normal compile-only option -c is used by
   |            default. Note that the <string> of options should be quoted.
   |            For historical reasons the leading double-dash is optional.
   |
   |        CXX=<name>
   |        CXX=[<pathname>,<name>]
   |        --CXX=<name>
   |        --CXX=[<pathname>,<name>]
   |
   |            Used to specify the name of the C++ compiler used. For historical
   |            reasons the leading double-dashes are optional.
   |
   |            Note that there are 2 forms accepted for the option's argument:
   |
   |            1) A simple C++ compiler name such as "g++" or "icpc". This is the
   |               name of the C++ compiler that was used to produce the binaries
   |               to be installed. For example:
   |
   |                   CXX=g++
   |
   |               In this case the g++ GNU C++ compiler was used to produce the
   |               binaries (executables and libraries). Note that if <name> has
   |               directory components only the basename will be used.
   |
   |            2) A comma separated pair enclosed in square brackets. The first
   |               component is the actual pathname of the C++ compiler that was
   |               used to produce the binaries to be installed. The second
   |               component is a simple name by which the compiler will be considered.
   |               For example:
   |
   |                   CXX='[/usr/lib64/ccache/c++,g++]'
   |
   |               In this case a C++ compiler with the pathname "/usr/lib64/ccache/c++"
   |               was actually used but consider it to be "g++".
   |
   |            The first form is really a special case where the basename of the
   |            pathname is the same as the simple name of the C++ compiler.
   |
   |            This option almost always needs quoting as shown above since the
   |            square-brackets are considered to have special meaning by the shell.
   |
   |        CXX-options=<string>
   |        --CXX-options=<string>
   |
   |            Used to specify the options to be used with the C++ compiler used.
   |            Only special options such as the language standard assumed are
   |            to be specified. Define -D<name>, include pathname -I<pathname>,
   |            and library pathname -L<pathname> (along with library names) are
   |            not normally used. The normal compile-only option -c is used by
   |            default. Note that the <string> of options should be quoted.
   |
   |        --contact=<address>
   |
   |            A contact email address. There is no default contact address.
   |
   |        --debug
   |        --debug=<pathname>
   |
   |            Produce extra output useful when debugging the "mkinstaller"
   |            script itself. Output will be sent to <stderr> if no pathname
   |            is provided.
   |
   |        --default-prefix=<pathname>
   |
   |            Uses to set a default installation prefix in the generated
   |            script. Note that by default there is no default installation
   |            prefix in the generated script and so the user of that script
   |            must supply a pathname for the installation prefix.
   |
   |        --exclude=<pattern>
   |
   |            Exclude files whose basenames match the given globbing pattern.
   |            Note that the pattern almost always needs to be quoted as such
   |            patterns typically contain characters that are significant to
   |            the shell. For example: --exclude='*.a'
   |
   |            This option is not well supported on Windows-like hosts at this
   |            time.
   |
   |        --fill
   |
   |            On Windows-like platforms the underlying NSIS tool will fail
   |            if it encounters an empty directory to be installed. This
   |            option works around this limitation by adding a dummy file to
   |            such directories (named "dummy.txt"). Note that subdirectories
   |            and symbolic-links don't count when checking if a directory is
   |            empty.
   |
   |            NOTE: Use of this option isn't necessary on UNIX-like systems.
   |
   |        --follow
   |
   |            Follow symbolic links for directory pathnames to will be
   |            embedded as tarballs within the generated installer script.
   |            By default such symbolic links are not permitted.
   |
   |            Note that Windows-like systems do not support symbolic-links.
   |
   |        --intermediate-dir=<name>
   |        --version-dir=<name>
   |
   |            Use the given simple name as an intermediate directory name
   |            (aka. a version directory name) to be added under the PREFIX
   |            directory pathname as given to the installer at installation
   |            time in to which the directories will be installed. The
   |            default is no such intermediate directory, the installations
   |            will be done in the PREFIX directory as given at installation
   |            time.
   |
   |        --is-gnu-tar
   |
   |            Assume the tar utility is GNU tar and so supports the z option
   |            (compress). By default the tar utility is located and tested.
   |
   |        --keep
   |
   |            The mkinstaller script normally recursively deletes the various
   |            temporary directories that it creates and fills in the process
   |            of constructing an installer script. Use of this option prevents
   |            this deletion preserving it for a postmortem analysis.
   |
   |        --nofill
   |
   |            Don't add a dummy file (named "dummy.txt") to empty directories.
   |            See the --fill option.
   |
   |        --nofollow
   |
   |            Don't follow symbolic links for directory pathnames to will be
   |            embedded as tarballs within the generated installer script.
   |            When such symbolic-links are detected and error message will
   |            be produced and the script will terminate (after cleaning-up).
   |            This is the default behavior.
   |
   |            Note that Windows-like systems do not support symbolic-links.
   |
   |        --nokeep
   |
   |            Recursively delete the various temporary directories that are
   |            created and filled in the process of constructing an installer
   |            script. This is the default behavior (see the --keep option).
   |
   |        --nosha
   |
   |            Don't generate a SHA hash file for the generated script. This
   |            is the default behaviour.
   |
   |        --nonstd
   |
   |            Don't bother with any search for standard directory names such
   |            as bin, lib, or include, (see the --std option). Instead just
   |            simply use the directory pathname as given. Note that such a
   |            search would only done when the given directory pathnames don't
   |            include those with standard base names as bin, lib, or include.
   |
   |        --not-gnu-tar
   |
   |            Assume the tar utility is not GNU tar and doesn't support the
   |            z option (can't compress). By default the tar utility is located
   |            and tested.
   |
   |        --os=<string>
   |
   |            The OS on the system on which the installer is being generated.
   |            This string is encoded in the installer script as an aid in
   |            determining if the generated script is applicable to the
   |            system where it is run. The default is to use uname -s and
   |            uname -r to determine this string.
   |
   |        --postinstall-bin=<pathname>
   |
   |            The pathname of a binary executable which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |        --postinstall-perl=<pathname>
   |
   |            The pathname of a Perl script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |            Such post-install Perl scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --postinstall-python=<pathname>
   |
   |            The pathname of a Python script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |            Such post-install Python scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --postinstall-sh=<pathname>
   |
   |            The pathname of a Bourne-shell script which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |            Such post-install Bourne-shell scripts are not generally
   |            supported on Windows systems as the Bourne-shell is not
   |            generally found on Windows systems.
   |
   |        --preinstall-bin=<pathname>
   |
   |            The pathname of a binary executable which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |        --preinstall-perl=<pathname>
   |
   |            The pathname of a Perl script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |            Such preinstall Perl scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --preinstall-python=<pathname>
   |
   |            The pathname of a Python script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |            Such pre-install Python scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --preinstall-sh=<pathname>
   |
   |            The pathname of a Bourne-shell script which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |            Such pre-install Bourne-shell scripts are not generally
   |            supported on Windows systems as the Bourne-shell is not
   |            generally found on Windows systems.
   |
   |        --prjnam=<name>
   |        --project-name=<name>
   |
   |            The name of the project to be installed by the generated
   |            installer script. There is no default project name.
   |
   |        --prjver=<A>.<B>[.<C>[.<D>]][<suffix>]
   |        --project-version=<A>.<B>[.<C>[.<D>]][<suffix>]
   |
   |            The version number of the project to be installed by the
   |            generated installer script. Note that the given version number
   |            is expected to have 2, 3, or 4 dot-separated numeric components
   |            and an optional suffix. If the --project-version option is used
   |            then the --project-version option must also be used. There is
   |            no default project version number.
   |
   |        --sha-1
   |        --sha-160
   |        --sha-256
   |        --sha-384
   |        --sha-512
   |
   |            Generate a SHA hash of the generated script. The hash file
   |            will have the same name as the generated script but with an
   |            added ".sha-nnn" suffix (where nnn is one of 1, 160, 256,
   |            384, or 512). Note that --sha-1 and --sha-160 are synonymous.
   |            It is almost always a good idea to generate such a hash and
   |            the SHA 256 hash is generally preferred.
   |
   |        --std
   |
   |            If none of the given directory pathnames have basenames such
   |            as bin, lib, or include then look for immediate subdirectories
   |            of the given directory pathnames with such basenames. If any
   |            have such standard base names then replace the given directory
   |            pathname with all of the immediate subdirectory pathnames. See
   |            the --nonstd option.
   |
   |        -v[<digit>]
   |        --verbose[<digit>]
   |
   |            Operate in a verbose mode.
   |
   |            Repeating this option increases the amount of output produced.
   |            Note that the option may end with an optional digit which
   |            indicates a repetition count. Thus the option:
   |
   |               -v3
   |
   |            is equivalent to:
   |
   |               -v -v -v
   |
   |        -w <pathname>
   |        --with-notice=<pathname>
   |
   |            The pathname of a textfile which contains the copyright
   |            notice that is to be output by the generated installer script
   |            when the installer's --copyright option is used. By default
   |            the generated installer doesn't support a --copyright option.
   |
   |        --with-payload
   |
   |            Include the payload with the generated script. This results
   |            in a useful installer script that will actually install the
   |            supplied directories under the indicated prefix directory (see
   |            the --prefix=... and the --intermediate-dir=... options. This
   |            is the default behavior.
   |
   |        --with-<name>-file=<pathname>
   |
   |            A file with the specified <pathname> is to be included in the
   |            specified installation directory with the given basename (see
   |            the <pathname> description below (actually a parameter) for
   |            how directories to be installed are to be specified. Note that
   |            <name> in the option name is typically something like bin,
   |            include, lib, ... and like <pathname> below, may not contain
   |            any spaces, tabs, or dashes. If such an installation directory
   |            hasn't been specified then the appropriate work will be done
   |            so that the installer will have such a directory containing
   |            the specified file.
   |
   |        --without-payload
   |
   |            Don't include the payload with the generated script. This
   |            results in an ineffective installer script that won't actually
   |            install anything. It does however go through much of the other
   |            parts of the process and so may be an aid when debugging the
   |            generated installer.
   |
   |        <pathname>
   |
   |            The pathnames of one or more directories and/or files which will
   |            be installed in the installation prefix directory at installation
   |            time (when the generated installer is run). Note that such
   |            directories may share basenames with other directories (they'll
   |            be merged) but the basenames of files must be unique (otherwise
   |            they'd collide in the installation prefix directory). Typical
   |            directory basenames are: bin, include, lib, ... Typical file
   |            basenames are: README, LICENSE, ... Note that at least one such
   |            directory pathname is required.
   |
   |            Note that if such a pathname given on the command line contains
   |            any symbolic-links they will be expanded (by following) in order
   |            to form a pathname without symbolic-links. This is only done to
   |            pathnames on the command line, not those found down in directory
   |            trees (where symbolic-links are not permitted by the mkinstaller
   |            script).
   |
   |            The basename of this pathname may not contain any spaces, tabs,
   |            or dashes however the directory components (if any) may.
   |
   |            Note that a file pathname is much like a file pathname given
   |            in a --with-<name>-file=<pathname> option but is to be placed
   |            in the the top-level installation prefix directory.
   |
   |EXAMPLE
   |    The following is an annotated example of the use of mkinstaller by the
   |    ROSE project to form a binary installer. Note that it is assumed that
   |    both the boost and ROSE libraries have been built and "installed" on
   |    this system.
   |
   |    Assuming:
   |
   |        Unix-like environment
   |
   |        mkinstaller installed under /opt/totebag/bin
   |                                and /opt/totebag/lib
   |
   |        Boost installed in /opt/boost/include
   |                       and /opt/boost/lib
   |
   |        ROSE installed in /opt/ROSE/bin
   |                      and /opt/ROSE/include
   |                      and /opt/ROSE/lib
   |                      and /opt/ROSE/share
   |
   |    Example command:
   |
   |        /opt/totebag/bin/mkinstaller -v2 \\
   |                                     -c ROSE-rh6-4.8.5-installer \\
   |                                     CC=gcc \\
   |                                     CXX=g++ \\
   |                                     /opt/boost/{include,lib} \\
   |                                     /opt/ROSE/{bin,include,lib,share} \\
   |                                     --postinstall-perl=/opt/totebag/lib/mkinstaller/rose-post-install
   |
   |    Annotated command:
   |
   |       From the above example command:
   |
   |           -v2 \\
   |
   |       The -v2 option indicates (enhanced) verbose output is desired.
   |       Note that verbose output is generally beneficial. Also note that
   |       the trailing backslash was the continuation mark from the above
   |       very long command above (an honest cut/paste), it is not part
   |       of this option or any of the following options and parameters.
   |
   |           -c ROSE-rh6-4.8.5-installer \\
   |
   |       The -c <name> option is used to give a meaningful name to the
   |       generated installer. Note that the generated installer (a
   |       Bourne-shell script) will end-up in the current directory. It is
   |       suggested (but not required) that the mkinstaller command be run
   |       from an empty directory.
   |
   |           CC=gcc \\
   |
   |       Used to specify the name of the C compiler. Note that this is just
   |       the compiler name, not a pathname. This will encode information
   |       in the generated installer that indicates how the binaries to be
   |       installed were built. Not really an option, it is required.
   |
   |           CXX=g++ \\
   |
   |       Used to specify the name of the C++ compiler. Note that this is
   |       just the compiler name, not a pathname. This will be encoded
   |       in the generated installer that indicates how the binaries to be
   |       installed were built. Not really an option, it is required.
   |
   |           /opt/boost/{include,lib} \\
   |
   |       The pathnames where the boost headers and libraries were installed
   |       when they were built. Note that the example uses a curious form
   |       of wildcard notation. It actually expands to 2 separate directory
   |       pathnames: /opt/boost/include and /opt/boost/lib
   |
   |           /opt/ROSE/{bin,include,lib,share} \\
   |
   |       The pathnames where the various ROSE executables, headers, and
   |       libraries were installed when they were built. This actually expands
   |       to 4 separate directory pathnames: /opt/ROSE/bin /opt/ROSE/include
   |       /opt/ROSE/lib and /opt/ROSE/share
   |
   |           --postinstall-perl=/opt/totebag/lib/mkinstaller/rose-post-install
   |
   |       The --postinstall-perl=<pathname> option indicates the pathname of
   |       a Perl script (a file) which is to be carried in the generated
   |       installer. Once all of the directories have been put in place during
   |       the installation this script will be executed. Note that a ROSE
   |       specific post-install Perl script is included with mkinstaller.
   |
   |RETURNS
   |    "mkinstaller" returns the standard exit codes:
   |
   |       0 -- success
   |       1 -- failure
   |
   |ENVIRONMENT
   |    "mkinstaller" refers to the following environment variables:
   |
   |        DEBUG
   |        DEBUG_mkinstaller
   |
   |            This environment variable controls the production of additional
   |            output intended as an aid in debugging the script itself. When
   |            set to a non-zero integer value additional output will be
   |            generated and sent to <stderr>. If set to a pathname additional
   |            output will sent to a file with the given pathname. If set to
   |            a value of 0 (zero) or left unset then no additional debugging
   |            output will be produced.
   |
   |        INEFFECTIVE_mkinstaller
   |
   |            If this environment variable has been set then the generated
   |            script will lack a payload and may not even be runnable. Note
   |            that this feature is almost never used except when debugging
   |            the script generation process.
   |
   |        MKINSTALLER_TMPDIR
   |
   |            Consider this pathname before considering TMPDIR (see
   |            step (0) in the NOTES section below).
   |
   |INPLEMENTATION
EOF1
   if ($OSclass eq "Windows-like") {
      print STDOUT "    \"mkinstaller\" is implemented as a Perl script that is wrapped in\n";
      print STDOUT "    a binary executable to avoid any Windows registry entanglements.\n";
   }
   else {
      print STDOUT "    \"mkinstaller\" is implemented as a Perl script.\n";
   }
   print STDOUT pKit_fixIndentStuff(<<"EOF2");
   |
   |SEE ALSO
   |    Note that the following tools may be used by mkinstaller:
   |
   |        cp(1),
   |        fgrep(1),
   |        gzcat(1),
   |        gzip(1),
   |        ldd(1),
   |        makensis(1),
   |        NSIS,
   |        pshaw(1x),
   |        sh(1),
   |        sha1sum(1),
   |        sha256sum(1),
   |        sha384sum(1),
   |        sha512sum(1),
   |        strings(1),
   |        tar(1),
   |        uname(1)
   |
   |    Some of these may be required and if not found mkinstaller may
   |    fail with an error message.
   |
   |NOTES
   |    The script has no significant differences between hosts. Host specific
   |    details are determined at mkinstaller script run time. Note that on
   |    Windows-like hosts the script will fail with an error message if it
   |    can't find/run makensis (make sure makensis is reachable through the
   |    PATH environment variable).
   |
   |    The directory where temporary files are to be placed is determined
   |    as follows:
   |
   |        0) If MKINSTALLER_TMPDIR is defined and is not empty then
   |           consider its value as a directory pathname. If this pathname
   |           exists and is a directory and is writable then temporary
   |           files will be placed in this directory. Otherwise...
   |        1) If TMPDIR is defined and is not empty then consider its
   |           value as a directory pathname. If this pathname exists
   |           and is a directory and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        2) If TMP is defined and is not empty then consider its
   |           value as a directory pathname. If this pathname exists
   |           and is a directory and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        3) If TEMP is defined and is not empty then consider its
   |           value as a directory pathname. If this pathname exists
   |           and is a directory and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        4) If the user's home directory can be determined and if
   |           this home directory contains a subdirectory named tmp
   |           that is itself writable then temporary files will be
   |           placed in this directory. Otherwise...
   |        5) If "C:<userProfile>\\AppData\\Local\\temp" exists and
   |           is a writable directory then temporary files will be
   |           placed in this directory. Otherwise...
   |        6) If "/tmp" exists and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        7) If "/var/tmp" exists and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        8) If "C:\\Temp" exists and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        9) If "C:\\Windows\\Temp" exists and is writable then temporary
   |           files will be placed in this directory. Otherwise...
   |       10) If the current directory is writable then temporary files
   |           will be placed in the current directory. Otherwise...
   |       11) A fatal error message will be sent to <stderr> and
   |           the program will exit with a non-zero exit code.
   |
   |    Note that 5, 8, and 9 are only applicable on Windows-like hosts.
   |
   |    Support on cygwin and mingw system is rather experimental.
   |
   |DETAILS
   |    The installer construction process is implemented in a different
   |    fashion on UNIX-like systems such as Linux, MacOS, and Solaris
   |    from that on a Windows-like system. The mkinstaller command line
   |    use is identical between UNIX- and Windows-like hosts.
   |
   |    UNIX-like host
   |
   |       On a UNIX-like host the generated installer script is implemented
   |       as a self-extracting Bourne-shell script carrying a tarball as
   |       a payload.
   |
   |       Details of the installer construction process on UNIX:
   |
   |          Aside from initialization and command line processing the UNIX
   |          implementation of mkinstaller goes through the following steps:
   |
   |          1) Determination of a suitable temp directory. Much of the work
   |             done by the mkinstaller script is done in a temp directory.
   |          2) Creation of a top level temporary directory under which all
   |             other temporaries will be created. Creation of an "accumulator",
   |             an "intermediate" and a "wrapper" directory in the top level
   |             temp directory. A tarup/untar process will use both the
   |             "intermediate" and "accumulator" directories to merge given
   |             directories with the same basename. The "wrapper" directory
   |             will be used to carry the individual directory tarballs.
   |          3) From each of the specified directories to be installed such
   |             as .../bin, .../lib, specified on the mkinstaller command line
   |             tarup the individual directory forming tarballs in the wrapper
   |             directory in the temp directory.
   |          4) Tarup the temporary wrapper directory for eventual inclusion
   |             in the generated installer.
   |          5) Generate the text of the "installer" script in the temporary
   |             directory customizing it with with options for specifying an
   |             overall prefix directory and individual prefixes for each of
   |             the directories specified on the mkinstaller command line.
   |          6) Add the tarball built in (4) to the end of the script generated
   |             in (5) forming the distribution self-extracting installation
   |             script in the directory where mkinstaller was run.
   |          7) Cleanup.
   |
   |          In the end the only product is the desired distribution self-
   |          extracting installation script in the directory where the
   |          mkinstaller command was run. Everything else produced along
   |          the way (directories and files) is considered temporary and
   |          is destroyed.
   |
   |          Note that the name of the generated installer script is specified
   |          using the -c <name> or --create=<name> option to mkinstaller.
   |          However if the -c <name> or --create=<name> option is not used
   |          then mkinstaller will try to come-up with a reasonable name:
   |
   |             1) If the --project-name=<name> and --project-version=<version>
   |                options were used then the name of the generated installer
   |                will resemble:
   |
   |                   <name>-<version>-installer
   |
   |             2) If the --project-name=<name> option was used but not the
   |                --project-version option the name of the generated
   |                installer will resemble:
   |
   |                   <name>-installer
   |
   |             3) If neither the --project-name nor the --project-version
   |                options were used the name of the generated installer will
   |                simply be:
   |
   |                   installer
   |
   |          As is typical for a UNIX-like environment, the generated script
   |          has no extension.
   |
   |       How the generated installer script works on a UNIX-like target:
   |
   |          1) The installer script locates itself. This may seem to be an
   |             obvious and or silly question but the actual location of the
   |             script file is necessary for the actual extraction (the script
   |             file must be read by the standard "tail" utility).
   |          2) Determination of a suitable temp directory. Much of the work
   |             done by the generated installer script is done in a temp
   |             directory. Creation of a top level temporary directory under
   |             which all other temporaries will be created. This temp
   |             directory is created under the standard temp directory
   |             determined at the start of this step (see NOTES).
   |          3) PREFIX and PREFIX_xxx values are established from command
   |             line options. If appropriate options aren't supplied to
   |             install all directories then the installer script will prompt
   |             for the necessary pathname(s). The installer script will
   |             create the directories if necessary.
   |          4) The tarball embedded in the installer script is extracted from
   |             the installer script into the temp directory created in (2).
   |          5) The tarball in (4) is unwrapped revealing one or more tarballs
   |             (one for each installation directory such as bin.tar.gz/
   |             include.tar.gz/ lib.tar.gz/ ...). If a pre-install script was
   |             supplied to mkinstaller when the generated installer script
   |             was produced then it will be revealed at this time. Similarly
   |             if a post-install script was supplied to mkinstaller when the
   |             generated installer script was produced then it will also be
   |             revealed at this time. Note that neither of these scripts if
   |             supplied and revealed are actually executed in this step. See
   |             steps (6) and (8).
   |          6) If (5) revealed a pre-install script then it will be executed
   |             by the appropriate interpreter. Note that each of the PREFIX
   |             and/or PREFIX_xxx directories will be supplied as an option to
   |             this pre-install script (such as --prefix_bin=<pathname>). Also
   |             note at this time the individual tarballs representing the
   |             directories to install have NOT be unwrapped.
   |          7) Each individual tarball revealed in (5) is unwrapped into
   |             the appropriate PREFIX directory overlying anything already
   |             there.
   |          8) If (5) revealed a post-install script then it will be executed
   |             by the appropriate interpreter. Note that each of the PREFIX
   |             and/or PREFIX_xxx directories will be supplied as an options
   |             to this post-install script (such as --prefix_bin=<pathname>).
   |          9) Cleanup.
   |
   |    Windows-like host
   |
   |       On a Windows-like host (such as Windows 7 or 10) the generated
   |       installer is implemented as a binary executable which is actually
   |       generated under the covers by NSIS (the Nullsoft Scripted Install
   |       System). NSIS is open source and is freely available at
   |
   |           https://sourceforge.net/projects/nsis
   |
   |       Details of the installer construction process on Windows:
   |
   |          Aside from initialization and command line processing the Windows
   |          implementation of mkinstaller goes through the following steps:
   |
   |          1) Determination of a suitable temp directory. Much of the work
   |             done by the mkinstaller script is done in a temp directory.
   |          2) Generation of a .nsi script file.
   |          3) MakeNSIS is used to "compile" the .nsi script forming a
   |             .exe binary executable.
   |
   |          The .exe binary executable formed in step (3) is the product of the
   |          mkinstaller script and may be shipped to customers to perform the
   |          desired installation on their Windows system.
   |
   |          Note that the name of the installer is specified using the -c <name>
   |          or --create=<name> option to mkinstaller. However if the -c <name>
   |          or --create=<name> option is not used then mkinstaller will try
   |          to come-up with a reasonable name:
   |
   |             1) If the --project-name=<name> and --project-version=<version>
   |                was used then the name of the generated installer will be:
   |
   |                   <name>-<version>-installer.exe
   |
   |             2) If the --project-name=<name> was used but not the
   |                --project-version option the name of the generated
   |                installer will be:
   |
   |                   <name>-installer.exe
   |
   |             3) If neither the --project-name nor the --project-version
   |                option the name of the generated installer will be:
   |
   |                   installer.exe
   |
   |          If the name is specified using the -c <name> or --create=<name>
   |          option then the name should NOT included a .exe extension. The
   |          makensis tool which actually produces the binary executable
   |          will add the necessary extension.
   |
   |       Running the generated installer on a Windows target system:
   |
   |          The default use of the generated installer will produce a new
   |          directory on the user's desktop.
   |
   |             bigtop> installer.exe
   |
   |          A different prefix may be specified using the /D option:
   |
   |             bigtop> installer.exe /D=E:\\opt\\banana
   |
   |          Note that the prefix directory will be creates as necessary
   |          however the uninstaller will only (recursively delete) the
   |          final directory component. In the above example only
   |          E:\\opt\\banana will be (recursively deleted, but the
   |          directory E:\\opt will be left intact.
   |
   |       Note that the generated installer will pop-up a progress bar dialog
   |       box to indicate the installation progress. The above examples were
   |       run by bozo on bigtop.highwire.net
   |
   |AUTHOR
   |    Jim Reus (jim.reus\@gmail.com)
   |
   |CONTACT
   |    Please contact:
   |
   |        totebag.help (totebag.help\@gmail.com) with questions.
   |
   |        totebag.bugs (totebag.bugs\@gmail.com) to report problems.
   |
   |        totebag.more (totebag.more\@gmail.com) to request enhancements.
   |
   |
   |    Be sure to provide as much information as possible.
   |
   |    This man page was generated by mkinstaller $mkinstaller_ver_name using the --help option. Revised $mkinstaller_ver_time
EOF2
   exit 0;
}

# MyUniqueFileId: 86c5676c-f385-41d3-c876-6e18a9b0ea51
#-------------------------------------------------------------------------------
#
#  This is the subroutine which generates help output for the mkinstaller
#  tool itself. Somehow we've got to merge common functionality with html
#  the replicated work is just awful.
#
#-------------------------------------------------------------------------------

sub html {
   my $pathname = shift;
   if ( ! open(HTML,"> $pathname")) {
      print STDERR "mkinstaller: can't create/write \"$pathname\"\n";
      exit 1;
   }
   print HTML pKit_fixIndentStuff(<<"EOF1");
   |<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
   |<html>
   |   <!-- --------------------------------------------------------------------------------------------------------------------------->
   |   <a name="mkinstaller"></a>
   |   <head>
   |      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   |      <meta name="GENERATOR" content="arg 1.7.1">
   |      <link rel="shortcut icon" href="../../icons/myShortcutIcon.png">
   |      <title>mkinstaller - Generate self-extracting installer.</title>
   |   </head>
   |   <body>
   |      <h3>
   |         <center>
   |            <nobr>
   |               mkinstaller (rev. $mkinstaller_ver_name)
   |            </nobr>
   |         </center>
   |      </h3>
   |
   |      <h3>
   |         NAME
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i>&nbsp;-&nbsp;Generate self-extracting installer.
   |      </blockquote>
   |
   |      <h3>
   |         SYNOPSIS
   |      </h3>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--copyright</b>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--help</b>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--html</b>&nbsp;&nbsp;<span style="font-family:'Times New Roman'; font-size: 125%;"><i>pathname</i></span>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--vernum</b>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--version</b>
   |      </blockquote>
   |      <br>
   |      <blockquote>
   |         <b>mkinstaller</b>
   |         <big>[</big><span style="font-family:'Times New Roman'; font-size: 125%;"><i>options</i></span> ...<big>]</big>
   |         <span style="font-family:'Times New Roman'; font-size: 125%;"><i>pathname</i></span> ...
   |      </blockquote>
   |      <br>
   |
   |      <h3>
   |         DESCRIPTION
   |      </h3>
   |      <blockquote>
   |         This script is used to generate an "installer" script implemented as
   |         a Bourne-shell script on UNIX-like systems (such as Linux, MacOS, or
   |         Solaris) or as a binary executable on Windows-like systems. A wide
   |         assortment of options are provided by <i>mkinstaller</i> to specify what is
   |         to be included for installation by the generated installer script.
   |         This generated installer itself supports a number of options for
   |         specifying the where the various directories are to be installed
   |         (prefix directory pathnames).
   |      </blockquote>
   |
   |      <blockquote>
   |         There are 2 separate computer systems involved in this process:
   |         <blockquote>
   |            <ol>
   |               <li>The <b>source</b> system. This is where the software to be installed
   |                   is found and where the <i>mkinstaller</i> script (the generator) is
   |                   used. On Windows-like hosts the <i>NSIS</i> software package must
   |                   have been properly installed on the <b>source</b> system.
   |               </li>
   |               <li>The <b>target</b> system. This is where the generated installer
   |                   script is run, where the software is to be installed. Note
   |                   that the <i>NSIS</i> software package is NOT required on the "target"
   |                   system.
   |               </li>
   |            </ol>
   |         </blockquote>
   |         There are 3 pieces of software involved:
   |         <blockquote>
   |            <ol>
   |               <li>The software to be installed. This is the software (binaries
   |                   and/or text) located on the <b>source</b> system whose components
   |                   have been built and is deemed ready for distribution.
   |               </li>
   |               <li>The <i>mkinstaller</i> script. Note that on a Windows-like host
   |                   the <i>NSIS</i> software must be properly installed. The <i>mkinstaller</i>
   |                   script required <i>NSIS</i> to generate the desired installer. <i>NSIS</i>
   |                   will NOT be required on the <b>target</b> system.
   |               </li>
   |               <li>The generated installer script. On a UNIX-like host this is
   |                   a Bourne-shell script generated by the <i>mkinstaller</i> script.
   |                   On a Windows-like host this is a binary executable (a <b><big><code>.exe</code></big></b>
   |                   file) that is generated by the <i>mkinstaller</i> script using the
   |                   <i>NSIS</i> package under the covers.
   |               </li>
   |            </ol>
   |         </blockquote>
   |         There are 4 distinct phases or times involved in this process:
   |         <blockquote>
   |            <ol>
   |               <li><b>Build-time</b>. This is the time when the software (binaries
   |                   and/or text files) is built and installed on the <b>source</b> system.
   |                   How this software is built and installed is not discussed here.
   |               </li>
   |               <li><b>Generation-time</b>. This is the time when <i>mkinstaller</i> is used
   |                   to collect the software that was produced in phase 1 and generate
   |                   the installer script. Like phase 1, this is also done on the
   |                   <b>source</b> system.
   |               </li>
   |               <li><b>Transport</b>. This is the process of taking a copy of the
   |                   generated installer script that was produced in phase 2 from
   |                   the <b>source</b> system to the <b>target</b> system. The details of this
   |                   are not discussed here however such transport generally
   |                   involves <i>scp</i>, <i>ftp</i>, <i>curl</i>, CD, DVD, USB-drive, or a download from
   |                   a web site.
   |               </li>
   |               <li><b>Installation-time</b>. this is the time when the installer
   |                   script that was generated by <i>mkinstaller</i> in phase 2 is executed
   |                   on the <b>target</b> system.
   |               </li>
   |            </ol>
   |         </blockquote>
   |      </blockquote>
   |
   |      <blockquote>
   |         <b>UNIX-like Host</b>
   |         <blockquote>
   |            On a UNIX-like host such as Linux, MacOS, or Solaris the generated
   |            installer script is implemented as a self-extracting Bourne-shell
   |            script carrying a tarball as a payload. Note that <i>mkinstaller</i>
   |            requires <i>tar</i> on UNIX-like hosts. This is normally not a problem
   |            as almost every UNIX-like system provides <i>tar</i>. On some UNIX-like
   |            hosts (most notably Solaris) <i>tar</i> doesn't support compression. On
   |            such systems mkinstaller will require <i>gzcat</i> and <i>gzip</i> to support
   |            compression.
   |         </blockquote>
   |         <blockquote>
   |            The installation process on a UNIX-like target system is done by
   |            simply running the generated installer script using the <b><big><code>--prefix</code></big></b>
   |            option to supply the installation directory. For example:
   |            <blockquote>
   |                <b><big><code>./banana-installer -v --prefix=/opt/banana</code></big></b>
   |            </blockquote>
   |            Note that on UNIX-like hosts the <b><big><code>--prefix=</code></big></b><i>pathname</i> option isn't
   |            really optional, it is required. Also note that use of the <b><big><code>-v</code></big></b>
   |            option (verbose mode) is recommended as the generated installer
   |            normally produces no output other than remarks, warnings, and/or
   |            error messages.
   |         </blockquote>
   |         <b>Windows-like Host</b>
   |         <blockquote>
   |            On a Windows-like host (such as Windows 7 or Windows 10) the
   |            generated installer is implemented as a binary executable which
   |            is actually generated under the covers by <i>NSIS</i> (Nullsoft Scripted
   |            Install System). <i>NSIS</i> is required by <i>mkinstaller</i> on Windows-like
   |            hosts. Note that <i>NSIS</i> is open source and is freely available at:
   |            <blockquote>
   |               <a href="https://sourceforge.net/projects/nsis"><b><big><code>https://sourceforge.net/projects/nsis</code></big></b></a>
   |            </blockquote>
   |         </blockquote>
   |         <blockquote>
   |            The installation process on a Windows-like target system is done by
   |            simply running the generated installer binary executable. Unlike an
   |            installer produced for UNIX-like hosts, an installer for Windows-like
   |            hosts may perform the installation to a default location; the user's
   |            desktop:
   |            <blockquote>
   |              <b><big><code>banana-installer.exe</code></big></b>
   |            </blockquote>
   |            When run the installer executable puts-up a dialog box resembling:
   |            <blockquote>
   |               <center>
   |                  <img src="../../images/mkinstaller/installer-dialog.png">
   |                  <p>
   |                     Typical installation dialog box
   |               </center>
   |            </blockquote>
   |            The installation dialog box allows the user to specify the installation
   |            "prefix" directory by replacing the default pathname with the desired
   |            pathname or using the browser button to locate and select a pathname.
   |         </blockquote>
   |         <blockquote>
   |            To specify an installation prefix on the command line the <b><big><code>/D=</code></big></b><i>pathname</i>
   |            option may be used:
   |            <blockquote>
   |              <b><big><code>banana-installer.exe /D=E:\\opt\\banana</code></big></b>
   |            </blockquote>
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         OPTIONS
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i> supports the following options:
   |         <blockquote>
   |
   |            <b>--copyright</b>
   |            <blockquote>
   |               Output copyright and license to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>--help</b>
   |            <blockquote>
   |               Output this man page to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>--html</b>&nbsp;&nbsp;<i>pathname</i>
   |            <blockquote>
   |               Output this man page as HTML to the given file pathname and quit.
   |            </blockquote>
   |
   |            <b>--vernum</b>
   |            <blockquote>
   |               Output version number to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>--version</b>
   |            <blockquote>
   |               Output version number and revision date to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>-c</b> <i>name</i> <br>
   |            <b>--create=</b><i>name</i>
   |            <blockquote>
   |               The name of the script to generate. It is generally not advisable
   |               to include a suffix (aka. extension) as part of the script name.
   |               Also note that this is <i>not</i> a pathname, is is the simple name of
   |               the script file which is to be created in the current directory.
   |               By default the script will be named "installer".
   |            </blockquote>
   |
   |            <b>--cc=</b><i>name</i>
   |            <blockquote>
   |               This option has been obsoleted. Use <b><big><code>CC=</code></big></b><i>name</i> and <b><big><code>CC-options=</code></big></b><i>string</i>
   |               instead.
   |            </blockquote>
   |
   |            <b>--cxx=</b><i>name</i>
   |            <blockquote>
   |               This option has been obsoleted. Use <b><big><code>CXX=</code></big></b><i>name</i> and <b><big><code>CXX-options=</code></big></b><i>string</i>
   |               instead.
   |            </blockquote>
   |
   |            <b>CC=</b><i>name</i> <br>
   |            <b>CC=[</b><i>pathname</i><b>,</b><i>name</i><b>]</b> <br>
   |            <b>--CC=</b><i>name</i> <br>
   |            <b>--CC=[</b><i>pathname</i><b>,</b><i>name</i><b>]</b>
   |            <blockquote>
   |               Used to specify the name of the C compiler used. For historical
   |               reasons the leading double-dashes are optional.
   |            </blockquote>
   |            <blockquote>
   |               Note that there are 2 forms accepted for the option's argument:
   |               <ol>
   |                  <li> A simple C compiler name such as <i>gcc</i> or <i>icc</i>. This is the
   |                       name of the C compiler that was used to produce the binaries
   |                       to be installed. For example:
   |                       <blockquote>
   |                          <b><big><code>CC=gcc</code></big></b>
   |                       </blockquote>
   |                       In this case the <i>gcc</i> GNU C compiler was used to produce the
   |                       binaries (executables and libraries). Note that if <i>name</i> has
   |                       directory components only the basename will be used.
   |                  </li>
   |                  <li> A comma separated pair enclosed in square brackets. The first
   |                       component is the actual pathname of the C compiler that was
   |                       used to produce the binaries to be installed. The second
   |                       component is a name by which the compiler will be considered.
   |                       For example:
   |                       <blockquote>
   |                          <b><big><code>CC='[/usr/lib64/ccache/cc,gcc]'</code></big></b>
   |                       </blockquote>
   |                       In this case a C compiler with the pathname <b><big><code>/usr/lib64/ccache/cc</code></big></b>
   |                       was actually used but consider it to be <i>gcc</i>.
   |                  </li>
   |               </ol>
   |            </blockquote>
   |            <blockquote>
   |               The first form is really a special case where the basename of the
   |               <i>pathname</i> is the same as the simple <i>name</i> of the C compiler.
   |            </blockquote>
   |            <blockquote>
   |               This option almost always needs quoting as shown above since the
   |               square-brackets are considered to have special meaning by the shell.
   |            </blockquote>
   |
   |            <b>CC-options=</b><i>string</i> <br>
   |            <b>--CC-options=</b><i>string</i>
   |            <blockquote>
   |               Used to specify the options to be used with the C compiler used.
   |               Only special options such as the language standard assumed are
   |               to be specified. Define <b><big><code>-D</code></big></b><i>name</i>, include pathname <b><big><code>-I</code></big></b><i>pathname</i>,
   |               and library pathname <b><big><code>-L</code></big></b><i>pathname</i> (along with library names) are
   |               not normally used. The normal compile-only option <b><big><code>-c</code></big></b> is used by
   |               default. Note that the <i>string</i> of options should be quoted.
   |               For historical reasons the leading double-dash is optional.
   |            </blockquote>
   |
   |            <b>CXX=</b><i>name</i> <br>
   |            <b>CXX=[</b><i>pathname</i><b>,</b><i>name</i><b>]</b> <br>
   |            <b>--CXX=</b><i>name</i> <br>
   |            <b>--CXX=[</b><i>pathname</i><b>,</b><i>name</i><b>]</b>
   |            <blockquote>
   |               Used to specify the name of the C++ compiler used. For historical
   |               reasons the leading double-dashes are optional.
   |            </blockquote>
   |            <blockquote>
   |               Note that there are 2 forms accepted for the option's argument:
   |               <ol>
   |                  <li> A simple C++ compiler name such as <i>g++</i> or <i>icpc</i>. This is the
   |                       name of the C++ compiler that was used to produce the binaries
   |                       to be installed. For example:
   |                       <blockquote>
   |                          <b><big><code>CXX=g++</code></big></b>
   |                       </blockquote>
   |                       In this case the <i>g++</i> GNU C++ compiler was used to produce the
   |                       binaries (executables and libraries). Note that if <i>name</i> has
   |                       directory components only the basename will be used.
   |                  </li>
   |                  <li> A comma separated pair enclosed in square brackets. The first
   |                       component is the actual pathname of the C++ compiler that was
   |                       used to produce the binaries to be installed. The second
   |                       component is a name by which the compiler will be considered.
   |                       For example:
   |                       <blockquote>
   |                          <b><big><code>CC='[/usr/lib64/ccache/c++,g++]'</code></big></b>
   |                       </blockquote>
   |                       In this case a C++ compiler with the pathname <b><big><code>/usr/lib64/ccache/c++</code></big></b>
   |                       was actually used but consider it to be <i>g++</i>.
   |                  </li>
   |               </ol>
   |            </blockquote>
   |            <blockquote>
   |               The first form is really a special case where the basename of the
   |               <i>pathname</i> is the same as the simple <i>name</i> of the C++ compiler.
   |            </blockquote>
   |            <blockquote>
   |               This option almost always needs quoting as shown above since the
   |               square-brackets are considered to have special meaning by the shell.
   |            </blockquote>
   |
   |            <b>CXX-options=</b><i>string</i> <br>
   |            <b>--CXX-options=</b><i>string</i>
   |            <blockquote>
   |               Used to specify the options to be used with the C++ compiler used.
   |               Only special options such as the language standard assumed are
   |               to be specified. Define <b><big><code>-D</code></big></b><i>name</i>, include pathname <b><big><code>-I</code></big></b><i>pathname</i>,
   |               and library pathname <b><big><code>-L</code></big></b><i>pathname</i> (along with library names) are
   |               not normally used. The normal compile-only option <b><big><code>-c</code></big></b> is used by
   |               default. Note that the <i>string</i> of options should be quoted.
   |            </blockquote>
   |
   |            <b>--contact=</b><i>address</i>
   |            <blockquote>
   |               A contact email address. There is no default contact address.
   |            </blockquote>
   |
   |            <b>--debug</b> <br>
   |            <b>--debug</b>=<i>pathname</i>
   |            <blockquote>
   |               Produce extra output useful when debugging the <i>mkinstaller</i>
   |               script itself. Output will be sent to <i>stderr</i> if no pathname
   |               is provided.
   |            </blockquote>
   |
   |            <b>--default-prefix=</b><i>pathname</i>
   |            <blockquote>
   |               Used to set a default installation prefix in the generated
   |               script. Note that by default there is no default installation
   |               prefix in the generated script and so the user of that script
   |               must supply a pathname for the installation prefix.
   |            </blockquote>
   |
   |            <b>--exclude=</b><i>pattern</i>
   |            <blockquote>
   |               Exclude files whose basenames match the given globbing pattern.
   |               Note that the pattern almost always needs to be quoted as such
   |               patterns typically contain characters that are significant to
   |               the shell. For example: <b><big><code>--exclude='*.a'</code></big></b>
   |            </blockquote>
   |            <blockquote>
   |               This option is not well supported on Windows-like hosts at this
   |               time.
   |            </blockquote>
   |
   |            <b>--fill</b>
   |            <blockquote>
   |               On Windows-like platforms the underlying <i>NSIS</i> tool will fail
   |               if it encounters an empty directory to be installed. This
   |               option works around this limitation by adding a dummy file to
   |               such directories (named <b><big><code>dummy.txt</code></big></b>). Note that subdirectories
   |               and symbolic-links don't count when checking if a directory is
   |               empty.
   |            </blockquote>
   |            <blockquote>
   |               <b>Note:</b> Use of this option isn't necessary on UNIX-like systems.
   |            </blockquote>
   |
   |            <b>--follow</b>
   |            <blockquote>
   |               Follow symbolic links for directory pathnames to will be
   |               embedded as tarballs within the generated installer script.
   |               By default such symbolic links are not permitted.
   |            </blockquote>
   |            <blockquote>
   |               Note that Windows-like systems do not support symbolic-links.
   |            </blockquote>
   |
   |            <b>--intermediate-dir=</b><i>name</i> <br>
   |            <b>version-dir=</b><i>name</i>
   |            <blockquote>
   |               Use the given simple name as an intermediate directory name
   |               (aka. a version directory name) to be added under the PREFIX
   |               directory pathname as given to the installer at installation
   |               time in to which the directories will be installed. The
   |               default is no such intermediate directory, the installations
   |               will be done in the PREFIX directory as given at installation
   |               time.
   |            </blockquote>
   |
   |            <b>--is-gnu-tar</b>
   |            <blockquote>
   |               Assume the <i>tar</i> utility is GNU <i>tar</i> and so supports the <b><big><code>z</code></big></b> option
   |               (compress). By default the <i>tar</i> utility is located and tested.
   |            </blockquote>
   |
   |            <b>--keep</b>
   |            <blockquote>
   |               The <i>mkinstaller</i> script normally recursively deletes the various
   |               temporary directories that it creates and fills in the process
   |               of constructing an installer script. Use of this option prevents
   |               this deletion preserving it for a postmortem analysis.
   |            </blockquote>
   |
   |            <b>--nofill</b>
   |            <blockquote>
   |               Don't add a dummy file (named <b><big><code>dummy.txt</code></big></b>) to empty directories.
   |               See the <b><big><code>--fill</code></big></b> option.
   |            </blockquote>
   |
   |            <b>--nofollow</b>
   |            <blockquote>
   |               Don't follow symbolic links for directory pathnames to will be
   |               embedded as tarballs within the generated installer script.
   |               When such symbolic-links are detected and error message will
   |               be produced and the script will terminate (after cleaning-up).
   |               This is the default behavior.
   |            </blockquote>
   |            <blockquote>
   |               Note that Windows-like systems do not support symbolic-links.
   |            </blockquote>
   |
   |            <b>--nokeep</b>
   |            <blockquote>
   |               Recursively delete the various temporary directories that are
   |               created and filled in the process of constructing an installer
   |               script. This is the default behavior (see the <b><big><code>--keep</code></big></b> option).
   |            </blockquote>
   |
   |            <b>--nosha</b>
   |            <blockquote>
   |               Don't generate a SHA hash file for the generated script. This
   |               is the default behaviour.
   |            </blockquote>
   |
   |            <b>--nonstd</b>
   |            <blockquote>
   |               Don't bother with any search for standard directory names such
   |               as <b><big><code>bin</code></big></b>, <b><big><code>lib</code></big></b>, or <b><big><code>include</code></big></b>, (see the <b><big><code>--std</code></big></b> option). Instead just
   |               simply use the directory pathname as given. Note that such a
   |               search would only done when the given directory pathnames don't
   |               include those with standard base names as <b><big><code>bin</code></big></b>, <b><big><code>lib</code></big></b>, or <b><big><code>include</code></big></b>.
   |            </blockquote>
   |
   |            <b>--not-gnu-tar</b>
   |            <blockquote>
   |               Assume the <i>tar</i> utility is not GNU <i>tar</i> and doesn't support the
   |               <b><big><code>z</code></big></b> option (can't compress). By default the <i>tar</i> utility is located
   |               and tested.
   |            </blockquote>
   |
   |            <b>--os=</b><i>string</i>
   |            <blockquote>
   |               The OS on the system on which the installer is being generated.
   |               This string is encoded in the installer script as an aid in
   |               determining if the generated script is applicable to the
   |               system where it is run. The default is to use <b><big><code>uname -s</code></big></b> and
   |               <b><big><code>uname -r</code></big></b> to determine this string.
   |            </blockquote>
   |
   |            <b>--preinstall-bin=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a binary executable which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |
   |            <b>--preinstall-perl=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Perl script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such pre-install Perl scripts are not generally supported
   |               on Windows systems as Perl is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--preinstall-python=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Python script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such pre-install Python scripts are not generally supported
   |               on Windows systems as Python is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--preinstall-sh=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Bourne-shell script which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such pre-install Bourne-shell scripts are not generally
   |               supported on Windows systems as the Bourne-shell is not
   |               generally found on Windows systems.
   |            </blockquote>
   |
   |            <b>--postinstall-bin=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a binary executable which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |
   |            <b>--postinstall-perl=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Perl script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such post-install Perl scripts are not generally supported
   |               on Windows systems as Perl is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--postinstall-python=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Python script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such post-install Python scripts are not generally supported
   |               on Windows systems as Python is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--postinstall-sh=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Bourne-shell script which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such post-install Bourne-shell scripts are not generally
   |               supported on Windows systems as the Bourne-shell is not
   |               generally found on Windows systems.
   |            </blockquote>
   |
   |            <b>--prjnam=</b><i>name</i> <br>
   |            <b>--project-name=</b><i>name</i>
   |            <blockquote>
   |               The name of the project to be installed by the generated
   |               installer script. There is no default project name.
   |            </blockquote>
   |
   |            <b>--prjver=</b><i>A</i><b>.</b><i>B</i>[<b>.</b><i>C</i>[<b>.</b><i>D</i>]][<i>suffix</i>] <br>
   |            <b>--project-version=</b><i>A</i><b>.</b><i>B</i>[<b>.</b><i>C</i>[<b>.</b><i>D</i>]][<i>suffix</i>]
   |            <blockquote>
   |               The version number of the project to be installed by the
   |               generated installer script. Note that the given version number
   |               is expected to have 2, 3, or 4 dot-separated numeric components
   |               and an optional suffix. If the <b><big><code>--project-version</code></big></b> option is used
   |               then the <b><big><code>--project-name</code></big></b> option must also be used. There is
   |               no default project version number.
   |            </blockquote>
   |
   |            <b>--sha-1</b> <br>
   |            <b>--sha-160</b> <br>
   |            <b>--sha-256</b> <br>
   |            <b>--sha-384</b> <br>
   |            <b>--sha-512</b>
   |            <blockquote>
   |               Generate a SHA hash of the generated script. The hash file
   |               will have the same name as the generated script but with an
   |               added <b><big><code>.sha-</code></big></b><i>nnn</i>" suffix (where <i>nnn</i> is one of 1, 256,
   |               384, or 512). Note that <b><big><code>--sha-1</code></big></b> and <b><big><code>--sha-160</code></big></b> are synonymous.
   |               It is almost always a good idea to generate such a hash and
   |               the SHA 256 hash is generally preferred.
   |            </blockquote>
   |
   |            <b>--std</b>
   |            <blockquote>
   |               If <b>none</b> of the given directory pathnames have basenames such
   |               as <b><big><code>bin</code></big></b>, <b><big><code>lib</code></big></b>, or <b><big><code>include</code></big></b> then look for immediate subdirectories
   |               of the given directory pathnames with such basenames. If <b>any</b>
   |               have such standard base names then replace the given directory
   |               pathname with all of the immediate subdirectory pathnames. See
   |               the <b><big><code>--nonstd</code></big></b> option.
   |            </blockquote>
   |
   |            <b>-v</b>[<i>digit</i>] <br>
   |            <b>--verbose</b>[<i>digit</i>]
   |            <blockquote>
   |               Operate in a "verbose" mode.
   |            </blockquote>
   |            <blockquote>
   |               Repeating this option increases the amount of output produced.
   |               Note that the option may end with an optional digit which
   |               indicates a repetition count. Thus the option: <br>
   |               <p>
   |<p>
   |<pre>
   |   -v3
   |</pre>
   |<p>
   |               is equivalent to: <br>
   |               <p>
   |<p>
   |<pre>
   |   -v -v -v
   |</pre>
   |            </blockquote>
   |
   |            <b>-w</b> <i>pathname</i> <br>
   |            <b>--with-notice=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a textfile which contains the copyright
   |               notice that is to be output by the generated installer script
   |               when the installer's <b><big><code>--copyright</code></big></b> option is used. By default
   |               the generated installer doesn't support a <b><big><code>--copyright</code></big></b> option.
   |            </blockquote>
   |
   |            <b>--with-payload</b>
   |            <blockquote>
   |               Include the payload with the generated script. This results
   |               in a useful installer script that will actually install the
   |               supplied directories under the indicated prefix directory (see
   |               the <b><big><code>--prefix=</code></big></b><i>...</i> and the <b><big><code>--intermediate-dir=</code></big></b><i>...</i> options. This
   |               is the default behavior.
   |            </blockquote>
   |
   |            <b>--with-</b><i>name</i><b>-file=</b><i>pathname</i>
   |            <blockquote>
   |               A file with the specified <i>pathname</i> is to be included in the
   |               specified installation directory with the given basename (see
   |               the <i>pathname</i> description below (actually a parameter) for
   |               how directories to be installed are to be specified. Note that
   |               <i>name</i> in the option name is typically something like <b><big><code>bin</code></big></b>,
   |               <b><big><code>include</code></big></b>, <b><big><code>lib</code></big></b>, ... and like <i>pathname</i> below, may not contain
   |               any spaces, tabs, or dashes. If such an installation directory
   |               hasn't been specified then the appropriate work will be done
   |               so that the installer will have such a directory containing
   |               the specified file.
   |            </blockquote>
   |
   |            <b>--without-payload</b>
   |            <blockquote>
   |               Don't include the payload with the generated script. This
   |               results in an ineffective installer script that won't actually
   |               install anything. It does however go through much of the other
   |               parts of the process and so may be an aid when debugging the
   |               generated installer.
   |            </blockquote>
   |
   |            <i>pathname</i>
   |            <blockquote>
   |               The pathnames of one or more directories and/or files which will
   |               be installed in the installation prefix directory at installation
   |               time (when the generated installer is run). Note that such
   |               directories may share basenames with other directories (they'll
   |               be merged) but the basenames of files must be unique (otherwise
   |               they'd collide in the installation prefix directory). Typical
   |               directory basenames are: <b><big><code>bin</code></big></b>, <b><big><code>include</code></big></b>, <b><big><code>lib</code></big></b>, ... Typical file
   |               basenames are: <b><big><code>README</code></big></b>, <b><big><code>LICENSE</code></big></b>, ... Note that at least one such
   |               directory pathname is required.
   |            </blockquote>
   |            <blockquote>
   |               Note that if such a pathname given on the command line contains
   |               any symbolic-links they will be expanded (by following) in order
   |               to form a pathname without symbolic-links. This is only done to
   |               pathnames on the command line, not those found down in directory
   |               trees (where symbolic-links are not permitted by the <i>mkinstaller</i>
   |               script).
   |            </blockquote>
   |
   |            <blockquote>
   |               The basename of this pathname may not contain any spaces, tabs,
   |               or dashes however the directory component (if any) may.
   |            </blockquote>
   |            <blockquote>
   |               Note that a file pathname is much like a file pathname given
   |               with a <b><big><code>--with-</code></big></b><i>name</i><b><big><code>-file=</code></big></b><i>pathname</i> option but is to be placed
   |               in the the top-level installation prefix directory.
   |            </blockquote>
   |
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         EXAMPLE
   |      </h3>
   |      <blockquote>
   |         The following is an annotated example of the use of <i>mkinstaller</i> by the
   |         <i>ROSE</i> project to form a binary installer. Note that it is assumed that
   |         both the <i>boost</i> and <i>ROSE</i> libraries have been built and "installed" on
   |         this (host) system.
   |      </blockquote>
   |      <blockquote>
   |         Assuming:
   |         <blockquote>
   |           Unix-like environment
   |         </blockquote>
   |         <blockquote>
   |            <i>mkinstaller</i> installed under  <b><big><code>/opt/totebag/bin</code></big></b>
   |            and <b><big><code>/opt/totebag/lib</code></big></b>
   |         </blockquote>
   |         <blockquote>
   |            <i>Boost</i> installed in <b><big><code>/opt/boost/include</code></big></b>
   |            and <b><big><code>/opt/boost/lib</code></big></b>
   |         </blockquote>
   |         <blockquote>
   |            <i>ROSE</i> installed in <b><big><code>/opt/ROSE/bin</code></big></b>
   |            and <b><big><code>/opt/ROSE/include</code></big></b>
   |            and <b><big><code>/opt/ROSE/lib</code></big></b>
   |            and <b><big><code>/opt/ROSE/share</code></big></b>
   |         </blockquote>
   |         Example command:
   |         <blockquote>
   |<pre>
   |/opt/totebag/bin/mkinstaller -v2 \\
   |                             -c ROSE-rh6-4.8.5-installer \\
   |                             CC=gcc \\
   |                             CXX=g++ \\
   |                             /opt/boost/{include,lib} \\
   |                             /opt/ROSE/{bin,include,lib,share} \\
   |                             --postinstall-perl=/opt/totebag/lib/mkinstaller/rose-post-install
   |</pre>
   |         </blockquote>
   |         Annotated command:
   |         <blockquote>
   |            From the above example command:
   |            <blockquote>
   |<pre>
   |-v2 \\
   |</pre>
   |            </blockquote>
   |            The <b><big><code>-v2</code></big></b> option indicates (enhanced) verbose output is desired.
   |            Note that verbose output is generally beneficial. Also note that
   |            the trailing backslash was the continuation mark from the above
   |            very long command above (an honest cut/paste), it is not part
   |            of this option or any of the following options and parameters.
   |            <blockquote>
   |<pre>
   |-c ROSE-rh6-4.8.5-installer \\
   |</pre>
   |            </blockquote>
   |            The <b><big><code>-c</code></big></b> <i>name</i> option is used to give a meaningful name to the
   |            generated installer. Note that the generated installer (a
   |            Bourne-shell script) will end-up in the current directory. It is
   |            suggested (but not required) that the <i>mkinstaller</i> command be run
   |            from an empty directory.
   |            <blockquote>
   |<pre>
   |CC=gcc \\
   |</pre>
   |            </blockquote>
   |            Used to specify the name of the C compiler. Note that this is just
   |            the compiler name, not a pathname. This will encode information
   |            in the generated installer that indicates how the binaries to be
   |            installed were built. Not really an option, it is required.
   |            <blockquote>
   |<pre>
   |CXX=g++ \\
   |</pre>
   |            </blockquote>
   |            Used to specify the name of the C++ compiler. Note that this is
   |            just the compiler name, not a pathname. This will be encoded
   |            in the generated installer that indicates how the binaries to be
   |            installed were built.
   |            <blockquote>
   |<pre>
   |/opt/boost/{include,lib} \\
   |</pre>
   |            </blockquote>
   |            The pathnames where the <i>boost</i> headers and libraries were installed
   |            when they were built. Note that the example uses a curious form
   |            of wildcard notation. It actually expands to 2 separate directory
   |            pathnames: <b><big><code>/opt/boost/include</code></big></b> and <b><big><code>/opt/boost/lib</code></big></b>
   |            <blockquote>
   |<pre>
   |/opt/ROSE/{bin,include,lib,share} \\
   |</pre>
   |            </blockquote>
   |            The pathnames where the various <i>ROSE</i> executables, headers, and
   |            libraries were installed when they were built. This actually expands
   |            to 4 separate directory pathnames: <b><big><code>/opt/ROSE/bin</code></big></b> <b><big><code>/opt/ROSE/include</code></big></b>
   |            <b><big><code>/opt/ROSE/lib</code></big></b> and <b><big><code>/opt/ROSE/share</code></big></b>
   |            <blockquote>
   |<pre>
   |--postinstall-perl=/opt/totebag/lib/mkinstaller/rose-post-install
   |</pre>
   |            </blockquote>
   |            The <b><big><code>--postinstall-perl=</code></big></b><i>pathname</i> option indicates the pathname of
   |            a Perl script (a file) which is to be carried in the generated
   |            installer. Once all of the directories have been put in place during
   |            the installation this script will be executed. Note that a <i>ROSE</i>
   |            specific post-install Perl script is included with <i>mkinstaller</i>.
   |            </blockquote>
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         RETURNS
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i> returns the standard exit codes:
   |         <blockquote>
   |            <table border=0><smaller>
   |               <tr>
   |                  <td align=right>0</td>
   |                  <td align=left>--</td>
   |                  <td align=left>success</td>
   |               </tr>
   |               <tr>
   |                  <td align=right>1</td>
   |                  <td align=left>--</td>
   |                  <td align=left>failure</td>
   |               </tr>
   |            </table>
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         ENVIRONMENT
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i> refers to the following environment variables:
   |         <blockquote>
   |
   |            <b>DEBUG</b> <br>
   |            <b>DEBUG_mkinstaller</b>
   |            <blockquote>
   |               This environment variable controls the production of additional
   |               output intended as an aid in debugging the script itself. When
   |               set to a non-zero integer value additional output will be
   |               generated and sent to <i>stderr</i>. If set to a pathname additional
   |               output will sent to a file with the given pathname. If set to
   |               a value of 0 (zero) or left unset then no additional debugging
   |               output will be produced.
   |            </blockquote>
   |
   |            <b>INEFFECTIVE_mkinstaller</b>
   |            <blockquote>
   |               If this environment variable has been set then the generated
   |               script will lack a payload and may not even be runnable. Note
   |               that this feature is almost never used except when debugging
   |               the script generation process.
   |            </blockquote>
   |
   |            <b>MKINSTALLER_TMPDIR</b>
   |            <blockquote>
   |               Consider this pathname before considering TMPDIR (see
   |               step (0) in the <b>NOTES</b> section below).
   |            </blockquote>
   |
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         IMPLEMENTATION
   |      </h3>
   |      <blockquote>
EOF1
   if ($OSclass eq "Windows-like") {
      print HTML "         <i>mkinstaller</i> is implemented as a Perl script that is wrapped in\n";
      print HTML "         a binary executable to avoid any Windows registry entanglements.\n";
   }
   else {
      print HTML "         <i>mkinstaller</i> is implemented as a Perl script.\n";
   }
   print HTML pKit_fixIndentStuff(<<"EOF2");
   |      </blockquote>
   |
   |      <h3>
   |         SEE&nbsp;ALSO
   |      </h3>
   |      <blockquote>
   |         Note that the following tools may be used by <i>mkinstaller</i>:
   |         <blockquote>
   |            cp(1), <br>
   |            fgrep(1), <br>
   |            gzcat(1), <br>
   |            gzip(1), <br>
   |            ldd(1), <br>
   |            <a href="http://nsis.sourceforge.net/Docs/Chapter3.html#">makensis</a>(1), <br>
   |            <a href="http://nsis.sourceforge.net/Main_Page">NSIS</a>, <br>
   |            <a href="../html1/pshaw$TBG_HTML_EXT">pshaw</a>(<a href="../html1/index$TBG_HTML_EXT">1x</a>), <br>
   |            sh(1), <br>
   |            sha1sum(1), <br>
   |            sha256sum(1), <br>
   |            sha384sum(1), <br>
   |            sha512sum(1), <br>
   |            strings(1), <br>
   |            tar(1), <br>
   |            uname(1)
   |         </blockquote>
   |         Some of these may be required and if not found <i>mkinstaller</i> may
   |         fail with an error message.
   |      </blockquote>
   |
   |      <h3>
   |         NOTES
   |      </h3>
   |      <blockquote>
   |         The script has no significant differences between hosts. Host specific
   |         details are determined at <i>mkinstaller</i> script run time. Note that on
   |         Windows-like hosts the script will fail with an error message if it
   |         can't find/run <i>makensis</i> (make sure <i>makensis</i> is reachable through the
   |         <b><big><code>PATH</code></big></b> environment variable).
   |      </blockquote>
   |      <blockquote>
   |         The directory where temporary files are to be placed is determined
   |         as follows:
   |         <blockquote>
   |            <ol start="0">
   |               <li>If <b><big><code>MKINSTALLER_TMPDIR</code></big></b> is defined and is not empty then
   |                   consider its value as a directory pathname. If this pathname
   |                   exists and is a directory and is writable then temporary
   |                   files will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>TMPDIR</code></big></b> is defined and is not empty then consider its
   |                   value as a directory pathname. If this pathname exists
   |                   and is a directory and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>TMP</code></big></b> is defined and is not empty then consider its
   |                   value as a directory pathname. If this pathname exists
   |                   and is a directory and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>TEMP</code></big></b> is defined and is not empty then consider its
   |                   value as a directory pathname. If this pathname exists
   |                   and is a directory and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If the user's home directory can be determined and if
   |                   this home directory contains a subdirectory named <b><big><code>tmp</code></big></b>
   |                   that is itself writable then temporary files will be
   |                   placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>C:</code></big></b><i>userProfile</i><b><big><code>\\AppData\\Local\\temp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>/tmp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>/var/tmp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>C:\\Temp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>C:\\Windows\\Temp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If the current directory is writable then temporary
   |                   files will be placed in the current directory.
   |                   Otherwise...
   |               </li>
   |               <li>A fatal error message will be sent to <i>stderr</i> and
   |                   the script will exit with a non-zero exit code.
   |               </li>
   |            </ol>
   |         </blockquote>
   |         Note that 5, 8, and 9 are only applicable on Windows-like hosts.
   |      </blockquote>
   |      <blockquote>
   |         Support on <i>cygwin</i> and <i>mingw</i> system is rather experimental.
   |      </blockquote>
   |
   |      <h3>
   |         DETAILS
   |      </h3>
   |      <blockquote>
   |         The installer construction process is implemented in a different
   |         fashion on UNIX-like systems such as Linux, MacOS, and Solaris
   |         from that on a Windows-like system. The <i>mkinstaller</i> command line
   |         use is identical between UNIX- and Windows-like hosts.
   |      </blockquote>
   |
   |      <blockquote>
   |         <b>UNIX-like Host</b>
   |         <blockquote>
   |            On a UNIX-like host the generated installer script is implemented
   |            as a self-extracting Bourne-shell script carrying a tarball as
   |            a payload.
   |         </blockquote>
   |         <blockquote>
   |            <b>Details of the installer construction process on UNIX:</b>
   |            <blockquote>
   |               Aside from initialization and command line processing the UNIX
   |               implementation of <i>mkinstaller</i> goes through the following steps:
   |               <ol>
   |                  <li>Determination of a suitable temp directory. Much of the work
   |                      done by the <i>mkinstaller</i> script is done in a temp directory.
   |                  </li>
   |                  <li>Creation of a top level temporary directory under which all
   |                      other temporaries will be created. Creation of an "accumulator",
   |                      an "intermediate" and a "wrapper" directory in the top level
   |                      temp directory. A tarup/untar process will use both the
   |                      "intermediate" and "accumulator" directories to merge given
   |                      directories with the same basename. The "wrapper" directory
   |                      will be used to carry the individual directory tarballs.
   |                  </li>
   |                  <li>From each of the specified directories to be installed such
   |                      as .../bin, .../lib, specified on the <i>mkinstaller</i> command line
   |                      tarup the individual directory forming tarballs in the wrapper
   |                      directory in the temp directory.
   |                  </li>
   |                  <li>Tarup the temporary wrapper directory for eventual inclusion
   |                      in the generated installer.
   |                  </li>
   |                  <li>Generate the text of the "installer" script in the temporary
   |                      directory customizing it with with options for specifying an
   |                      overall prefix directory and individual prefixes for each of
   |                      the directories specified on the <i>mkinstaller</i> command line.
   |                  </li>
   |                  <li>Add the tarball built in (4) to the end of the script generated
   |                      in (5) forming the distribution self-extracting installation
   |                      script in the directory where <i>mkinstaller</i> was run.
   |                  </li>
   |                  <li>Cleanup.
   |                  </li>
   |               </ol>
   |               In the end the only product is the desired distribution self-
   |               extracting installation script in the directory where the
   |               <i>mkinstaller</i> command was run. Everything else produced along
   |               the way (directories and files) is considered temporary and
   |               is destroyed.
   |            </blockquote>
   |            <blockquote>
   |               Note that the name of the generated installer script is specified
   |               using the <b><big><code>-c</code></big></b> <i>name</i> or <b><big><code>--create=</code></big></b><i>name</i> option to mkinstaller.
   |               However if the <b><big><code>-c</code></big></b> <i>name</i> or <b><big><code>--create=</code></big></b><i>name</i> option is not used
   |               then <i>mkinstaller</i> will try to come-up with a reasonable name:
   |               <blockquote>
   |                  <ol>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> and <b><big><code>--project-version=</code></big></b><i>version</i>
   |                         was used then the name of the generated installer will resemble:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-</code></big></b><i>version</i><b><big><code>-installer</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> was used but not the
   |                         <b><big><code>--project-version</code></big></b> option the name of the generated
   |                         installer will resemble:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-installer</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If neither the <b><big><code>--project-name</code></big></b> nor the <b><big><code>--project-version</code></big></b>
   |                         option the name of the generated installer will be:
   |                         <blockquote>
   |                            <b><big><code>installer</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                  </ol>
   |               </blockquote>
   |               As is typical for a UNIX-like environment, the generated script
   |               has no extension.
   |            </blockquote>
   |            <b>How the generated installer script works on a UNIX-like target:</b>
   |            <blockquote>
   |               <ol>
   |                  <li>The installer script locates itself. This may seem to be an
   |                      obvious and or silly question but the actual location of the
   |                      script file is necessary for the actual extraction (the script
   |                      file must be read by the standard <i>tail</i> utility).
   |                  </li>
   |                  <li>Determination of a suitable temp directory. Much of the work
   |                      done by the generated installer script is done in a temp
   |                      directory. Creation of a top level temporary directory under
   |                      which all other temporaries will be created. This temp
   |                      directory is created under the standard temp directory
   |                      determined at the start of this step (see NOTES).
   |                  </li>
   |                  <li><b><big><code>PREFIX</code></big></b> and <b><big><code>PREFIX_</code></big></b><i>xxx</i> values are established from command
   |                      line options. If appropriate options aren't supplied to
   |                      install all directories then the installer script will prompt
   |                      for the necessary pathname(s). The installer script will
   |                      create the directories if necessary.
   |                  </li>
   |                  <li>The tarball embedded in the installer script is extracted from
   |                      the installer script into the temp directory created in (2).
   |                  </li>
   |                  <li>The tarball in (4) is unwrapped revealing one or more tarballs
   |                      (one for each installation directory such as <b><big><code>bin.tar.gz</code></big></b>
   |                      <b><big><code>include.tar.gz</code></big></b> <b><big><code>lib.tar.gz</code></big></b> ...). If a pre-install script was
   |                      supplied to <i>mkinstaller</i> when the generated installer script
   |                      was produced then it will be revealed at this time. Similarly
   |                      if a post-install script was supplied to <i>mkinstaller</i> when the
   |                      generated installer script was produced then it will also be
   |                      revealed at this time. Note that neither of these scripts if
   |                      supplied and revealed are actually executed in this step. See
   |                      steps (6) and (8).
   |                  </li>
   |                  <li>If (5) revealed a pre-install script then it will be executed
   |                      by the appropriate interpreter. Note that each of the <b><big><code>PREFIX</code></big></b>
   |                      and/or <b><big><code>PREFIX_</code></big></b><i>xxx</i> directories will be supplied as an option to
   |                      this pre-install script (such as  <b><big><code>--prefix_bin=</code></big></b><i>pathname</i>). Also
   |                      note at this time the individual tarballs representing the
   |                      directories to install have NOT be unwrapped.
   |                  </li>
   |                  <li>Each individual tarball revealed (5) is unwrapped into the
   |                      appropriate <b><big><code>PREFIX</code></big></b> directory overlying anything already
   |                      there.
   |                  </li>
   |                  <li>If (5) revealed a post-install script then it will be executed
   |                      by the appropriate interpreter. Note that each of the <b><big><code>PREFIX</code></big></b>
   |                      directories will be supplied as an option to this post-install
   |                      script (such as <b><big><code>--prefix_bin=</code></big></b><i>pathname</i>).
   |                  </li>
   |                  <li>Cleanup.
   |                  </li>
   |               </ol>
   |            </blockquote>
   |         </blockquote>
   |         <b>Windows-like host</b>
   |         <blockquote>
   |            On a Windows-like host (such as Windows 7 or 10) the generated
   |            installer is implemented as a binary executable which is actually
   |            generated under the covers by <i>NSIS</i> (the Nullsoft Scripted Install).
   |            System). <i>NSIS</i> is open source and is freely available at:
   |            <blockquote>
   |               <a href="https://sourceforge.net/projects/nsis"><b><big><code>https://sourceforge.net/projects/nsis</code></big></b></a>
   |            </blockquote>
   |            <b>Details of the installer construction process on Windows:</b>
   |            <blockquote>
   |               Aside from initialization and command line processing the Windows
   |               implementation of <i>mkinstaller</i> goes through the following steps:
   |               <ol>
   |                  <li>Determination of a suitable temp directory. Much of the work
   |                      done by the <i>mkinstaller</i> script is done in a temp directory.
   |                  </li>
   |                  <li>Generation of a <b><big><code>.nsi</code></big></b> script file.
   |                  </li>
   |                  <li><i>MakeNSIS</i> is used to "compile" the <b><big><code>.nsi</code></big></b> script forming a
   |                      <b><big><code>.exe</code></big></b> binary executable.
   |                  </li>
   |               </ol>
   |               The <b><big><code>.exe</code></big></b> binary executable formed in step (3) is the product of the
   |               <i>mkinstaller</i> script and may be shipped to customers to perform the
   |               desired installation on their Windows system.
   |            </blockquote>
   |            <blockquote>
   |               Note that the name of the installer is specified using the <b><big><code>-c</code></big></b> <i>name</i>
   |               or <b><big><code>--create=</code></big></b><i>name</i> option to <i>mkinstaller</i>. However if the <b><big><code>-c</code></big></b> <i>name</i>
   |               or <b><big><code>--create=</code></big></b><i>name</i> option is not used then <i>mkinstaller</i> will try
   |               to come-up with a reasonable name:
   |               <blockquote>
   |                  <ol>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> and <b><big><code>--project-version=</code></big></b><i>version</i>
   |                         was used then the name of the generated installer will resemble:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-</code></big></b><i>version</i><b><big><code>-installer.exe</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> was used but not the
   |                         <b><big><code>--project-version</code></big></b> option the name of the generated
   |                         installer will resemble:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-installer.exe</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If neither the <b><big><code>--project-name</code></big></b> nor the <b><big><code>--project-version</code></big></b>
   |                         option the name of the generated installer will be:
   |                         <blockquote>
   |                            <b><big><code>installer.exe</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                  </ol>
   |               </blockquote>
   |               If the name is specified using the <b><big><code>-c</code></big></b> <i>name</i> or <b><big><code>--create=</code></big></b><i>name</i>
   |               option then the name should NOT included a <b><big><code>.exe</code></big></b> extension. The
   |               <i>makensis</i> tool which actually produces the binary executable
   |               will add the necessary extension.
   |            </blockquote>
   |            <b>Running the generated installer on a Windows target system:</b>
   |            <blockquote>
   |               The default use of the generated installer will produce a new
   |               directory on the user's desktop.
   |               <blockquote>
   |                  bigtop> <b><big><code>installer.exe</code></big></b>
   |               </blockquote>
   |               A different prefix may be specified using the <b><big><code>/D</code></big></b> option:
   |               <blockquote>
   |                  bigtop> <b><big><code>installer.exe /D=E:\\opt\\banana</code></big></b>
   |               </blockquote>
   |               Note that the prefix directory will be creates as necessary
   |               however the uninstaller will only (recursively) delete the
   |               final directory component. In the above example only
   |               <b><big><code>E:\\opt\\banana</code></big></b> will be (recursively deleted, but the
   |               directory <b><big><code>E:\\opt</code></big></b> will be left intact.
   |            </blockquote>
   |            <blockquote>
   |               Note that the generated installer will pop-up a progress bar dialog
   |               box to indicate the installation progress. The above examples were
   |               run by bozo on bigtop.highwire.net
   |            </blockquote>
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         AUTHOR
   |      </h3>
   |      <blockquote>
   |         <a href="mailto:jim.reus\@gmail.com?subject=mkinstaller">Jim Reus</a> <br>
   |      </blockquote>
   |
   |      <h3>
   |         CONTACT
   |      </h3>
   |      <blockquote>
   |         Please contact: <br>
   |         <blockquote>
   |            <a href="mailto:totebag.help\@gmail.com?subject=Help: mkinstaller">totebag.help</a> with questions. <br>
   |            <br>
   |            <a href="mailto:totebag.bugs\@gmail.com?subject=Bug: mkinstaller">totebag.bugs</a> to report problems. <br>
   |            <br>
   |            <a href="mailto:totebag.more\@gmail.com?subject=Enhance: mkinstaller">totebag.more</a> to request enhancements. <br>
   |            <br>
   |         </blockquote>
   |         Be sure to provide as much information as possible.
   |      </blockquote>
   |
   |      <h3>
   |         <center>
   |            <nobr>
   |               mkinstaller (rev. $mkinstaller_ver_name)
   |            </nobr>
   |         </center>
   |      </h3>
   |
   |      <i>This man page was generated by mkinstaller $mkinstaller_ver_name using the <code>--html</code> option. Revised $mkinstaller_ver_time</i>
   |   </body>
   |</html>
EOF2
   close(HTML);
}

