#!/usr/bin/perl
$Interpreter ||= "/usr/bin/perl";
#-------------------------------------------------------------------------------
#
#   Copyright 1985-99,2000-18 James Frederick Reus
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#-------------------------------------------------------------------------------

# MyUniqueFileId: 05bfd522-45a2-4dfa-ca27-420e6c630546

$mkinstaller_ver_major = "2";
$mkinstaller_ver_minor = "0";
$mkinstaller_ver_build = "1";
$mkinstaller_ver_patch = "";
$mkinstaller_ver_name  = "2.0.1";
$mkinstaller_ver_time  = " 6Feb2018 18:15:21z";
$mkinstaller_ver_id    = "@(#)mkinstaller 2.0.1 -  6Feb2018 18:15:21z";

#{------------------------------------------------------------------------------
#
#       tbg_extensions.pfrag
#
#       This file was generated by the configure script using simple
#       stubstitution at configuration time. It is meant to ease the
#       importation of a filename extension discovered at configuration
#       time to be used at build-time.
#
#-------------------------------------------------------------------------------

#---------------------------------------
#
#       Filename extensions...
#
#---------------------------------------

$TBG_A_EXT      = ".a";
$TBG_AXX_EXT    = ".a";
$TBG_CSH_EXT    = "";
$TBG_HTML_EXT   = ".html";
$TBG_KSH_EXT    = "";
$TBG_O_EXT      = ".o";
$TBG_PERL_EXT   = "";
$TBG_PYTHON_EXT = "";
$TBG_SH_EXT     = "";
$TBG_X_EXT      = "";

#---------------------------------------
#
#       The prefix to a library filename
#       (a UNIX-ism, is an empty string
#       on Windows-like systems)...
#
#---------------------------------------

$TBG_LIB_PFX    = "lib";

#}------------------------------------------------------------------------------

@defaultCopyrightOwners
  = ( "Copyright 1985-99,2000-18 James Frederick Reus\n"
    );

@defaultCopyrightStatement
  = ( "Licensed under the Apache License, Version 2.0 (the \"License\");\n"
    , "you may not use this file except in compliance with the License.\n"
    , "You may obtain a copy of the License at\n"
    , "\n"
    , "    http://www.apache.org/licenses/LICENSE-2.0\n"
    , "\n"
    , "Unless required by applicable law or agreed to in writing, software\n"
    , "distributed under the License is distributed on an \"AS IS\" BASIS,\n"
    , "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
    , "See the License for the specific language governing permissions and\n"
    , "limitations under the License.\n"
    );

# MyUniqueFileId: 8428f7ce-97e8-4d57-c29f-84c52fae80f1
#-------------------------------------------------------------------------------
#
#  Initialization...
#
#-------------------------------------------------------------------------------

#---------------------------------------
#
#  Globals...
#
#---------------------------------------

$rawCommand    = $0;
$theCommand    = $rawCommand;
$theCommand    =~ tr/\\/\//;
$foundInDir    = "";
$TstartOverall = time();

$debugging     = 0;
if ( exists $ENV{"DEBUG_mkinstaller"}) {
   $debugging  = 1;
}

{
   #------------------------------------
   #
   #  Locals...
   #
   #------------------------------------

   print STDERR "mkinstaller: initialization...\n" if $debugging;
   my $Contact                         = "";
   my %check_prog_isSupported          = ( );
   my %check_prog_pathname             = ( );

#  my $CC_name                         = ""; # start off as undefined
#  my $CC_optionGiven                  = "";
#  my $CC_options                      = "";
   my $CC_version                      = "";
   my $CC_libcxxPathname               = "";
   my $CC_libcVersion                  = "";
   my @CC_libcVerList                  = ( );

#  my $CXX_name                        = ""; # start off as undefined
#  my $CXX_optionGiven                 = "";
#  my $CXX_options                     = "";
   my $CXX_version                     = "";
   my $CXX_libcxxPathname              = "";
   my @CXX_libcxxVerList               = ( );
   my $CXX_libcxxVersion               = "";
   my @CXX_abiVerList                  = ( );
   my $CXX_abiVersion                  = "";

   my $devNull                         = nullPathname();
   my %dirBasenames                    = ( );
   my @dirBasenames                    = ( );
   my %dirPathnames                    = ( );
   my @dirPathnames                    = ( );
   my $dirPathnamesCount               = 0;
   my $followSymlinks                  = 0;
   my $ForProject                      = "";
   my $FORTRANname                     = "";
   my $genSHA                          = 0;
   my $givenNonStdNames                = 0;
   my $givenStdNames                   = 0;
   my $here                            = getWorkingDirectory();
   my $intermediateName                = "";
   my $keep                            = 0;
   my $libDirBasename                  = "";
   my $myPath                          = "";
   my @myPath                          = ( );
   my $oldOSname                       = ""; # Only for backwards compatability
   my $OSclass                         = getOSclass();
   my $OSname                          = $^O;
   my $OSversion                       = "";
   my $postInstallBasename             = "";
   my $postInstallPathname             = "";
   my $postInstallStyle                = "";
   my $preInstallBasename              = "";
   my $preInstallPathname              = "";
   my $preInstallStyle                 = "";
   my $ProjectName                     = "";
   my $ProjectVer                      = "";  # Set by --project-version option
   my $ProjectVerMajor                 = "";
   my $ProjectVerMinor                 = "";
   my $ProjectVerBuild                 = "";
   my $ProjectVerPatch                 = "";
   my $ProjectVerSuffix                = "";
   my $scriptName                      = "";
   my $scriptNameU                     = "";
   my $SCRIPTNAME                      = "";
   my $SCRIPTNAME_TMPDIR               = "";
   my $stdMode                         = 0;
   my $theCommandLine                  = $rawCommand;
   my @theNotice                       = ( );
   my $titleLine                       = "";
   my $TmpDir                          = "";
   my $TmpDirA                         = "";
   my $TmpDirI                         = "";
   my $TmpDirT                         = "";
   my $TmpDirW                         = "";
   my $TmpFile                         = "";
   my $use_hasher                      = "";
   my $use_hasherOpt                   = "";
   my $use_hasher                      = "";
   my $use_makensis                    = "";
   my $use_pshaw                       = "";
   my $use_shaNNNsum                   = "";
   my $use_tar                         = "";
   my $use_uname                       = "";
   my $verbosityLevel                  = 0;
   my $withNotice                      = "";
   my $withPayload                     = 1;
   print STDERR "mkinstaller: ...done\n" if $debugging;

   if ( exists $ENV{"INEFFECTIVE_mkinstaller"}) {
      $withPayload                     = 0;
   }

   #---------------------------------------
   #
   #  If the command has a directory
   #  component, add it to PATH. Under
   #  special conditions we'll skip this
   #  work (paying for it later).
   #
   #---------------------------------------

   if (suffix($theCommand) ne ".perl") {
      print STDERR "mkinstaller: locate [$theCommand]...\n" if $debugging;
      if (basename($theCommand) ne $theCommand) {
         $foundInDir = dirname($theCommand);
         if ($foundInDir eq "") {
            print STDERR "mkinstaller: error -- can't determine where \"$theCommand\" is located, can't isolate directory\n";
            exit 1;
         }
         if ( exists $ENV{'PATH'} ) {
            my $isWindows;
            $myPath = $ENV{'PATH'};
            $myPath =~ tr/\\/\//;
            if ($OSclass eq "Windows-like") {
               $isWindows  = 1;
               @myPath     = split /;/, $myPath;
               $use_exeExt = ".exe";
               unshift @myPath, $foundInDir;
               $myPath     = join(';',@myPath);
               $myPath     =~ tr/\//\\/;
            }
            elsif ($OSclass eq "UNIX-like") {
               $isWindows  = 0;
               @myPath     = split /:/, $myPath;
               $use_exeExt = "";
               unshift @myPath, $foundInDir;
               $myPath     = join(':',@myPath);
            }
            else {
               print STDERR "mkinstaller: error -- host isn't UNIX- or Windows-like\n";
               exit 1;
            }
            $ENV{'PATH'} = $myPath;
         }
         else {
            $myPath = $foundInDir;
            $myPath =~ tr/\\/\//;
            @myPath = ( $myPath );
            if ($OSclass eq "Windows-like") {
               $myPath     =~ tr/\//\\/;
               $use_exeExt = ".exe";
            }
            elsif ($OSclass eq "UNIX-like") {
               $use_exeExt = "";
            }
            $ENV{'PATH'} = $myPath;
         }
      }
      else {
         if ( exists $ENV{'PATH'} ) {
            $myPath = $ENV{'PATH'};
            if ($OSclass eq "Windows-like") {
               $use_exeExt = ".exe";
               $myPath     =~ tr/\\/\//;
               @myPath     = split /;/, $myPath;
               my $i;
               for ($i=0; $i<=$#myPath; $i+=1) {
                  my $pathname = joinpath($myPath[$i],"mkinstaller.exe");
                  if (-f $pathname) {
                     $foundInDir = $myPath[$i];
                     last;
                  }
               }
               $myPath     =~ tr/\//\\/;
            }
            elsif ($OSclass eq "UNIX-like") {
               $use_exeExt = "";
               @myPath     = split /:/, $myPath;
               my $i;
               for ($i=0; $i<=$#myPath; $i+=1) {
                  my $pathname = joinpath($myPath[$i],"mkinstaller");
                  if (-f $pathname) {
                     if (-x $pathname) {
                        $foundInDir = $myPath[$i];
                        last;
                     }
                  }
               }
            }
            else {
               print STDERR "mkinstaller: error -- host isn't UNIX- or Windows-like\n";
               exit 1;
            }
            if ($foundInDir eq "") {
               print STDERR "mkinstaller: error -- can't determine where \"$theCommand\" is located\n";
               exit 1;
            }
         }
         else {
            print STDERR "mkinstaller: error -- can't determine where \"$theCommand\" is located, PATH not set\n";
            exit 1;
         }
      }
      print STDERR "mkinstaller: ...found in [$foundInDir]...\n" if $debugging;
   }

   #----------------------------------------------------------------------------
   #
   #  Process command line...
   #
   #  First take stuff from OPTS_mkinstaller
   #  environment variable and put it at the
   #  start of the command line...
   #
   #----------------------------------------------------------------------------

   if ( exists $ENV{'OPTS_mkinstaller'} ) {
      print STDERR "mkinstaller: deal with OPTS_mkinstaller...\n" if $debugging;
      my $tmp = $ENV{'OPTS_mkinstaller'};
      if ($tmp ne "") {
         my @tmp = split /\s/, $tmp;
         my $i;
         for ($i=$#tmp; 0<=$i; $i-=1) {
            unshift @ARGV, $tmp[$i];
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
   }

   #---------------------------------------
   #
   #  Then step through the command line...
   #
   #---------------------------------------

   print STDERR "mkinstaller: process command line...\n" if $debugging;
   {
      my $i;
      for ($i=0; $i<=$#ARGV; $i+=1) {
         my $opt = $ARGV[$i];
         print STDERR "mkinstaller: ...found \"$opt\"\n" if $debugging;
         $_      = $opt;
         parseArgs: {
                       #---------------------------------------
                       #
                       #  Standard options...
                       #
                       #---------------------------------------

                       /^--help$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             help();
                             exit 0;
                          };

                       /^--html$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: missing error -- argument to $opt option\n";
                                exit 1;
                             }
                             my $given       = $ARGV[$i];
                             print STDERR "mkinstaller:    ...with \"$given\"\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt." ".quoteIfReqd($given);
                             $given    =~ tr/\\/\//;
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- empty argument to $opt option\n";
                                exit 1;
                             }
                             html($given);
                             exit 0;
                          };

                       /^--vernum$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print "$mkinstaller_ver_name\n";
                             exit 0;
                          };

                       /^--version$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print "mkinstaller: version $mkinstaller_ver_name rev. $mkinstaller_ver_time\n";
                             exit 0;
                          };

                       /^--copyright$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             copyright();
                             exit 0;
                          };

                       #---------------------------------------
                       #
                       #  Non-standard options...
                       #
                       #---------------------------------------

                       /^-c$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: error -- missing argument to $opt option\n";
                                exit 1;
                             }
                             my $given       = $ARGV[$i];
                             print STDERR "mkinstaller:    ...with \"$given\"\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt." ".quoteIfReqd($given);
                             my $bn          = basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\" to ".$opt." option\n";
                                print STDERR "mkinstaller: ..script name must be simple; without directory components\n";
                                exit 1;
                             }
                             if ($scriptName ne "") {
                                print STDERR "mkinstaller: error -- unexpected $opt \"".$given."\"\n";
                                print STDERR "mkinstaller: ...already specified name of generated script as \"".$scriptName."\"\n";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\" to ".$opt." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   exit 1;
                                }
                             }
                             $scriptName = $given;
                             print STDERR "mkinstaller:       script name is \"$scriptName\"\n" if $debugging;
                             last parseArgs;
                          };

                       #
                       #  The --cc[=<name>] option has been deprecated.
                       #

                       /^--cc$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: note -- missing or zero-length argument to $opt option\n";
                             last parseArgs;
                          };

                       /^(--cc)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $optName\n" if $debugging;
                             print STDERR "mkinstaller:    ...with [$given]\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ( defined $CC_name) {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             else {
                                print STDERR "mkinstaller:    ...split [$given]\n" if $debugging;
                                $_         = $given;
                                             s/^\s+//;
                                             s/\s+$//;
                                my @parts  = split /\s+/, $given;
                                my $Nparts = $#parts + 1;
                                if ($debugging) {
                                   print STDERR "mkinstaller:       into $Nparts\n" if $debugging;
                                   my $j;
                                   for ($j=0; $j<$Nparts; ++$j) {
                                      my $part = $parts[$j];
                                      print STDERR "mkinstaller:       $j: [$part]\n" if $debugging;
                                   }
                                }
                                $CC_name = $parts[0];
                                print STDERR "mkinstaller:    ...name is \"$CC_name\"\n" if $debugging;
                                if (2 <= $Nparts) {
                                   my $vn = $parts[1];
                                   if ($vn =~ /^(\d+(\.\d+)*)(.*)$/) {
                                      my $vn = $1;
                                      my $suffix = $3;
                                      print STDERR "mkinstaller:       version \"$vn\"\n" if $debugging;
                                      print STDERR "mkinstaller: note -- ignoring version number $vn supplied by $opt option\n";
                                      if ($suffix ne "") {
                                         print STDERR "mkinstaller: error -- version number supplied with $optName option has a suffix\n";
                                      }
                                   }
                                   else {
                                      print STDERR "mkinstaller: note -- second part of argument to $optName option doesn't resemble a version number\n";
                                   }
                                   if (3 <= $Nparts) {
                                      print STDERR "mkinstaller: note -- unexpected extra parts of argument to $optName option\n";
                                      print STDERR "mkinstaller: ...";
                                      my $j;
                                      for ($j=2; $j<$Nparts; ++$j) {
                                         my $part = $parts[$j];
                                         print STDERR " " if (2 < $j);
                                         print STDERR "\"".$part."\"";
                                      }
                                      print STDERR "\n";
                                   }
                                }
                             }
                             print STDERR "mkinstaller:    ...C compiler name [$CC_name]\n" if $debugging;
                             if ($CC_name eq "gnu") {
                                print STDERR "mkinstaller: note -- C compiler \"$CC_name\" replaced by \"gcc\"\n";
                                $CC_name = "gcc";
                                print STDERR "mkinstaller:       C compiler name [$CC_name]\n" if $debugging;
                             }
                             elsif (($CC_name eq "intel") || ($CC_name eq "Intel")) {
                                print STDERR "mkinstaller: note -- C compiler \"$CC_name\" replaced by \"icc\"\n";
                                $CC_name = "icc";
                                print STDERR "mkinstaller:       C compiler name [$CC_name]\n" if $debugging;
                             }
                             elsif (($CC_name eq "llvm") || ($CC_name eq "LLVM")) {
                                print STDERR "mkinstaller: note -- C compiler \"$CC_name\" replaced by \"clang\"\n";
                                $CC_name = "clang";
                                print STDERR "mkinstaller:       C compiler name [$CC_name]\n" if $debugging;
                             }
                             last parseArgs;
                          };

                       /^--contact$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--contact)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($Contact ne "") {
                                print STDERR "mkinstaller: unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $Contact = $given;
                             print STDERR "mkinstaller:    ...contact [$Contact]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--create$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--create)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller:    ...with \"$given\"\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             my $bn      = basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: invalid argument(=\"".$given."\" to ".$opt." option\n";
                                print STDERR "mkinstaller: ..script name must be simple\n";
                                exit 1;
                             }
                             if ($scriptName ne "") {
                                print STDERR "mkinstaller: unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: invalid argument(=\"".$given."\" to ".$opt." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   exit 1;
                                }
                             }
                             $scriptName = $given;
                             print STDERR "mkinstaller:       script name is \"$scriptName\"\n" if $debugging;
                             last parseArgs;
                          };

                       #
                       #  The --cxx[=<name>] option has been deprecated.
                       #

                       /^--cxx$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: note -- missing or zero-length argument to $opt option\n";
                             last parseArgs;
                          };

                       /^(--cxx)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $optName\n" if $debugging;
                             print STDERR "mkinstaller:    ...with [$given]\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ( defined $CXX_name) {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             else {
                                print STDERR "mkinstaller:    ...split [$given]\n" if $debugging;
                                $_         = $given;
                                             s/^\s+//;
                                             s/\s+$//;
                                my @parts  = split /\s+/, $given;
                                my $Nparts = $#parts + 1;
                                if ($debugging) {
                                   print STDERR "mkinstaller:       into $Nparts\n" if $debugging;
                                   my $j;
                                   for ($j=0; $j<$Nparts; ++$j) {
                                      my $part = $parts[$j];
                                      print STDERR "mkinstaller:       $j: [$part]\n" if $debugging;
                                   }
                                }
                                $CXX_name = $parts[0];
                                print STDERR "mkinstaller:    ...name is \"$CXX_name\"\n" if $debugging;
                                if (2 <= $Nparts) {
                                   my $vn = $parts[1];
                                   if ($vn =~ /^(\d+(\.\d+)*)(.*)$/) {
                                      my $vn = $1;
                                      my $suffix = $3;
                                      print STDERR "mkinstaller:       version \"$vn\"\n" if $debugging;
                                      print STDERR "mkinstaller: note -- ignoring version number $vn supplied by $opt option\n";
                                      if ($suffix ne "") {
                                         print STDERR "mkinstaller: note -- version number supplied with $optName option has a suffix\n";
                                      }
                                   }
                                   else {
                                      print STDERR "mkinstaller: note -- second part of argument to $optName option doesn't resemble a version number\n";
                                   }
                                   if (3 <= $Nparts) {
                                      print STDERR "mkinstaller: note -- unexpected extra parts of argument to $optName option\n";
                                      print STDERR "mkinstaller: ...";
                                      my $j;
                                      for ($j=2; $j<$Nparts; ++$j) {
                                         my $part = $parts[$j];
                                         print STDERR " " if (2 < $j);
                                         print STDERR "\"".$part."\"";
                                      }
                                      print STDERR "\n";
                                   }
                                }
                             }
                             print STDERR "mkinstaller:    ...C++ compiler name [$CXX_name]\n" if $debugging;
                             if ($CXX_name eq "gnu") {
                                print STDERR "mkinstaller: note -- C++ compiler \"$CXX_name\" replaced by \"g++\"\n";
                                $CXX_name = "g++";
                                print STDERR "mkinstaller:       C++ compiler name [$CXX_name]\n" if $debugging;
                             }
                             elsif (($CXX_name eq "intel") || ($CXX_name eq "Intel")) {
                                print STDERR "mkinstaller: note -- C++ compiler \"$CXX_name\" replaced by \"icc\"\n";
                                $CXX_name = "icpc";
                                print STDERR "mkinstaller:       C++ compiler name [$CXX_name]\n" if $debugging;
                             }
                             elsif (($CXX_name eq "clang") || ($CXX_name eq "llvm") || ($CXX_name eq "LLVM")) {
                                print STDERR "mkinstaller: note -- C++ compiler \"$CXX_name\" replaced by \"clang++\"\n";
                                $CXX_name = "clang++";
                                print STDERR "mkinstaller:       C++ compiler name [$CXX_name]\n" if $debugging;
                             }
                             last parseArgs;
                          };

                       /^((-d)|(--debug))$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $debugging      = 1;
                             last parseArgs;
                          };

                       /^--follow$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $followSymlinks = 1;
                             last parseArgs;
                          };

                       /^--fortran$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--fortran)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($FORTRANname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $FORTRANname = $given;
                             print STDERR "mkinstaller:    ...FORTRAN name [$FORTRANname]\n" if $debugging;
                             last parseArgs;
                          };

                       /^((-k)|(--keep))$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $keep           = 1;
                             last parseArgs;
                          };

                       #- - - - - - - - - - - - - - - - - - - -
                       #
                       #  Note: The --intermediate-dir option is almost
                       #        identical to the --version-dir option
                       #        option, the only actual difference is
                       #        in the error and debugging messages.
                       #

                       /^(--intermediate-dir)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             my $bn          = basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\") to ".$optName." option\n";
                                print STDERR "mkinstaller: ...intermediate directory name must be simple; without directory components\n";
                                exit 1;
                             }
                             if ($intermediateName ne "") {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                print STDERR "mkinstaller: ...already specified name of intermediate directory name as \"".$intermediateName."\"\n";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\" to ".$optName." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   exit 1;
                                }
                             }
                             $intermediateName = $given;
                             print STDERR "mkinstaller:       version directory name is \"$intermediateName\"\n" if $debugging;
                             last parseArgs;
                          };

                       /^--nofollow$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $followSymlinks = 0;
                             last parseArgs;
                          };

                       /^--nosha$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $genSHA         = 0;
                             last parseArgs;
                          };

                       /^--nonstd$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $stdMode        = 0;
                             last parseArgs;
                          };

                       /^--os$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: note -- the --os option is obsolete and is ignored\n";
                             if ($oldOSname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             $oldOSname = "unknown";
                             if ($OSname ne "") {
                                print STDERR "mkinstaller: ...the OS has been automatically detected as: \"$OSname\"\n";
                             }
                             last parseArgs;
                          };

                       /^(--os)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($oldOSname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             $oldOSname = $given;
                             print STDERR "mkinstaller:    ...OS name [$oldOSname]\n" if $debugging;
                             print STDERR "mkinstaller: note -- the --os=... option is obsolete and is ignored\n";
                             if ($OSname ne "") {
                                print STDERR "mkinstaller: ...the OS has been automatically detected as: \"$OSname\"\n";
                             }
                             last parseArgs;
                          };

                       /^--postinstall-bin$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--postinstall-bin)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = basename($postInstallPathname);
                             $postInstallStyle    = "binary";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$postInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...binary post-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--postinstall-perl$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--postinstall-perl)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = basename($postInstallPathname);
                             $postInstallStyle    = "perl";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$postInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...perl post-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--postinstall-python$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--postinstall-python)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = basename($postInstallPathname);
                             $postInstallStyle    = "python";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$postInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...python post-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--postinstall-sh$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--postinstall-sh)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($postInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $postInstallPathname = $given;
                             $postInstallBasename = basename($postInstallPathname);
                             $postInstallStyle    = "sh";
                             if ($postInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$postInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...shell post-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$postInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$postInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$postInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-bin$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--preinstall-bin)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = basename($preInstallPathname);
                             $preInstallStyle    = "binary";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$preInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...binary pre-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-perl$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--preinstall-perl)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = basename($preInstallPathname);
                             $preInstallStyle    = "perl";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$preInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...perl pre-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-python$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--preinstall-python)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = basename($preInstallPathname);
                             $preInstallStyle    = "python";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$preInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...python pre-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--preinstall-sh$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--preinstall-sh)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($preInstallPathname ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $preInstallPathname = $given;
                             $preInstallBasename = basename($preInstallPathname);
                             $preInstallStyle    = "sh";
                             if ($preInstallBasename eq "") {
                                print STDERR "mkinstaller: error -- can't extract basename of \"$preInstallPathname\"\n";
                                exit 1;
                             }
                             print STDERR "mkinstaller:    ...shell pre-install script\n" if $debugging;
                             print STDERR "mkinstaller:       pathname [$preInstallPathname]\n" if $debugging;
                             print STDERR "mkinstaller:       basename [$preInstallBasename]\n" if $debugging;
                             print STDERR "mkinstaller:          style [$preInstallStyle]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--(prjnam|project-name)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--(prjnam|project-name))=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($3);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($ProjectName ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             $ProjectName = $given;
                             print STDERR "mkinstaller:    ...project name [$ProjectName]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--(prjver|project-version)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt option\n";
                             exit 1;
                          };

                       /^(--(prjver|project-version))=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($3);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($ProjectVer ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"$given\"\n";
                                exit 1;
                             }
                             if ( ! ($given =~ /^\d+(\.\d+(\.\d+(\.(\d+))?)?)?(\D\S*)?$/)) {
                                print STDERR "mkinstaller: error -- invalid argument(=$given) to $optName option\n";
                                print STDERR "mkinstaller: ...expected something of the form:\n";
                                print STDERR "mkinstaller:\n";
                                print STDERR "mkinstaller:    $optName=A[.B[.C[.D]]][S]\n";
                                print STDERR "mkinstaller:\n";
                                print STDERR "mkinstaller:    where A, B, C, and D are sequences of 1 or more digits each (B,\n";
                                print STDERR "mkinstaller:    C, D are optional and S is an optional string which may not\n";
                                print STDERR "mkinstaller:    start with a digit and may not contain spaces and/or tabs.\n";
                                print STDERR "mkinstaller:\n";
                                exit 1;
                             }
                             $ProjectVerMajor  = $given; $ProjectVerMajor  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$1/;
                             $ProjectVerMinor  = $given; $ProjectVerMinor  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$2/;
                             $ProjectVerBuild  = $given; $ProjectVerBuild  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$3/;
                             $ProjectVerPatch  = $given; $ProjectVerPatch  =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$5/;
                             $ProjectVerSuffix = $given; $ProjectVerSuffix =~ s/^(\d+)\.(\d+)\.(\d+)(\.(\d+))?(\D\S*)?$/$6/;
                             $ProjectVer       = $given;
                             print STDERR "mkinstaller:    ...project version [$ProjectVer]\n" if $debugging;
                             print STDERR "mkinstaller:              major is [$ProjectVerMajor]\n" if $debugging;
                             print STDERR "mkinstaller:              minor is [$ProjectVerMinor]\n" if $debugging;
                             print STDERR "mkinstaller:              build is [$ProjectVerBuild]\n" if $debugging;
                             print STDERR "mkinstaller:              patch is [$ProjectVerPatch]\n" if $debugging;
                             print STDERR "mkinstaller:             suffix is [$ProjectVerSuffix]\n" if $debugging;
                             last parseArgs;
                          };

                       /^--sha-?([1-9][0-9]*)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             my $given       = $1;
                             my $oldGenSHA   = genSHA ;
                             if (($given eq "1") || ($given eq "160")) {
                                $genSHA = 1;
                             }
                             elsif ($given eq "256") {
                                $genSHA = 256;
                             }
                             elsif ($given eq "384") {
                                $genSHA = 384;
                             }
                             elsif ($given eq "512") {
                                $genSHA = 512;
                             }
                             else {
                                print STDERR "mkinstaller: error -- unknown option \"".$opt."\"\n";
                                print STDERR "mkinstaller: ...did you mean: --sha-1, --sha-160, --sha-256, --sha-384, or --sha-512?\n";
                                exit 1;
                             }
                             if ($oldGenSHA != 0) {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             last parseArgs;
                          };

                       /^--std$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $stdMode        = 1;
                             last parseArgs;
                          };

                       #- - - - - - - - - - - - - - - - - - - -
                       #
                       #  Note: The --version-dir option is almost
                       #        identical to the --intermediate-dir
                       #        option, the only actual difference is
                       #        in the error and debugging messages.
                       #

                       /^(--version-dir)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- missing or zero-length argument to $optName option\n";
                                exit 1;
                             }
                             my $bn          = basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\") to ".$optName." option\n";
                                print STDERR "mkinstaller: ...version directory name must be simple; without directory components\n";
                                exit 1;
                             }
                             if ($intermediateName ne "") {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                print STDERR "mkinstaller: ...already specified name of version directory name as \"".$intermediateName."\"\n";
                                exit 1;
                             }
                             if ($OSclass eq "Windows-like") {
                                my $sfx = suffix($given);
                                if ($sfx ne "") {
                                   print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\" to ".$optName." option\n";
                                   print STDERR "mkinstaller: ...suffix not allowed on \"Windows-like\" host\n";
                                   exit 1;
                                }
                             }
                             $intermediateName = $given;
                             print STDERR "mkinstaller:       version directory name is \"$intermediateName\"\n" if $debugging;
                             last parseArgs;
                          };

                       /^-w$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $i += 1;
                             if ($#ARGV < $i) {
                                print STDERR "mkinstaller: error -- missing argument to $opt option\n";
                                exit 1;
                             }
                             my $given       = $ARGV[$i];
                             $theCommandLine = $theCommandLine." ".$opt." ".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- zero-length argument to $opt option\n";
                                exit 1;
                             }
                             if ($withNotice ne "") {
                                print STDERR "mkinstaller: error -- unexpected $opt \"".$given."\"\n";
                                print STDERR "mkinstaller: ...already file containing payload copyright notice as \"".$withNotice."\"\n";
                                exit 1;
                             }
                             if ( ! -f $given) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\") to $opt option\n";
                                if ( -e $given) {
                                   print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a file\n";
                                }
                                else {
                                   print STDERR "mkinstaller: ...can't find/read \"".$given."\"\n";
                                }
                                exit 0;
                             }
                             if ( ! -T $given) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\") to $opt option\n";
                                print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a textfile\n";
                                exit 1;
                             }
                             $withNotice = $given;
                             @theNotice  = slurpPathnameIntoArray($withNotice,"mkinstaller");
                             last parseArgs;
                          };

                       /^(--with-notice)=(.*)$/

                          && do {
                             my $optName     = $1;
                             my $given       = unquote($2);
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$optName."=".quoteIfReqd($given);
                             if ($given eq "") {
                                print STDERR "mkinstaller: error -- zero-length argument to $optName option\n";
                                exit 1;
                             }
                             if ($withNotice ne "") {
                                print STDERR "mkinstaller: error -- unexpected $optName=\"".$given."\"\n";
                                print STDERR "mkinstaller: ...already file containing payload copyright notice as \"".$withNotice."\"\n";
                                exit 1;
                             }
                             if ( ! -f $given) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\") to $optName option\n";
                                if ( -e $given) {
                                   print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a file\n";
                                }
                                else {
                                   print STDERR "mkinstaller: ...can't find/read \"".$given."\"\n";
                                }
                                exit 0;
                             }
                             if ( ! -T $given) {
                                print STDERR "mkinstaller: error -- invalid argument(=\"".$given."\") to $optName option\n";
                                print STDERR "mkinstaller: ...\"".$given."\" doesn't appear to be a textfile\n";
                                exit 1;
                             }
                             $withNotice = $given;
                             @theNotice  = slurpPathnameIntoArray($withNotice,"mkinstaller");
                             last parseArgs;
                          };

                       /^--with-payload$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $withPayload    = 1;
                             last parseArgs;
                          };

                       /^--without-payload$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             $withPayload    = 0;
                             last parseArgs;
                          };

                       #---------------------------------------
                       #
                       #  "Semi-standard" options...
                       #
                       #---------------------------------------

                       /^-v$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine  = $theCommandLine." ".$opt;
                             $verbosityLevel += 1;
                             print STDERR "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^-v0$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine  = $theCommandLine." ".$opt;
                             $verbosityLevel  = 0;
                             print STDERR "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^-v([1-9][0-9]*)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine  = $theCommandLine." ".$opt;
                             $verbosityLevel += $1;
                             print STDERR "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^--verbose$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine  = $theCommandLine." ".$opt;
                             $verbosityLevel += 1;
                             print STDERR "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^--verbose0$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine  = $theCommandLine." ".$opt;
                             $verbosityLevel  = 0;
                             print STDERR "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       /^--verbose([1-9][0-9]*)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine  = $theCommandLine." ".$opt;
                             $verbosityLevel += $1;
                             print STDERR "mkinstaller:    ...level is now $verbosityLevel\n" if $debugging;
                             last parseArgs;
                          };

                       #---------------------------------------
                       #
                       #  Hybrid options/parameters...
                       #
                       #  NOTE: C/C++ compiler names and
                       #        options are specified as
                       #        parameters of a sort. The
                       #        leading dashes are optional.
                       #        Also that the compiler names
                       #        are required. The C/C++
                       #        compiler options are indeed
                       #        optional
                       #
                       #---------------------------------------

                       /^(--)?CC=?$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt\n";
                             print STDERR "mkinstaller: ...expected C compiler basename\n";
                             exit 1;
                          };

                       /^((--)?CC=)(.+)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $given       = unquote($3);
                             $theCommandLine = $theCommandLine." ".$opt;
                             if ( defined $CC_name) {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             my $bn          = basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: warning -- improper argument(=\"$given\") to $optName\n";
                                print STDERR "mkinstaller: ...C compiler name should be simple; without directory components\n";
                                print STDERR "mkinstaller:    only the basename(=$bn) will be used\n";
                             }
                             $CC_name         = $bn;
                             last parseArgs;
                          };

                       /^((--)?CC-option(s)?=)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             if ( defined $CC_options) {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             $CC_options      = "";
                             last parseArgs;
                          };

                       /^((--)?CC-option(s)?=)(.+)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $given       = unquote($4);
                             $theCommandLine = $theCommandLine." ".$opt;
                             if ( defined $CC_options) {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             $CC_options     = $given;
                             $CC_optionGiven = $opt;
                             last parseArgs;
                          };

                       /^(--)?CXX=?$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             print STDERR "mkinstaller: error -- missing or zero-length argument to $opt\n";
                             print STDERR "mkinstaller: ...expected C++ compiler basename\n";
                             exit 1;
                          };

                       /^((--)?CXX=)(.+)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $given       = unquote($3);
                             $theCommandLine = $theCommandLine." ".$opt;
                             if ( defined $CXX_name) {
                                print STDERR "mkinstaller: unexpected $opt\n";
                                exit 1;
                             }
                             my $bn          = basename($given);
                             if ($given ne $bn) {
                                print STDERR "mkinstaller: warning -- improper argument(=\"$given\") to $optName\n";
                                print STDERR "mkinstaller: ...C++ compiler name should be simple; without directory components\n";
                                print STDERR "mkinstaller:    only the basename(=$bn) will be used\n";
                             }
                             $CXX_name       = $bn;
                             last parseArgs;
                          };

                       /^((--)?CXX-option(s)?=)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             $theCommandLine = $theCommandLine." ".$opt;
                             if ( defined $CXX_options) {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             $CXX_options     = "";
                             last parseArgs;
                          };

                       /^((--)?CXX-option(s)?=)(.+)$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             my $optName     = $1;
                             my $given       = unquote($4);
                             $theCommandLine = $theCommandLine." ".$opt;
                             if ( defined $CXX_options) {
                                print STDERR "mkinstaller: error -- unexpected $opt\n";
                                exit 1;
                             }
                             $CXX_options     = $given;
                             $CXX_optionGiven = $opt;
                             last parseArgs;
                          };

                       #---------------------------------------
                       #
                       #  Unknown options...
                       #
                       #---------------------------------------

                       /^--(.*)$/

                          && do {
                             print STDERR "mkinstaller: error -- unknown option \"".$opt."\"\n";
                             my $optName = $1;
                             if (length($optName) == 1) {
                                print STDERR "mkinstaller: ...did you mean -".$optName." or \"./".$opt."\"\n";
                             }
                             elsif (1 <= length($opt)) {
                                print STDERR "mkinstaller: ...did you mean \"./".$opt."\"\n";
                             }
                             exit 1;
                          };

                       /^-(.*)$/

                          && do {
                             print STDERR "mkinstaller: error -- unknown option \"".$opt."\"\n";
                             my $optName = $1;
                             if (2 <= length($optName)) {
                                print STDERR "mkinstaller: ...did you mean --".$optName." or \"./".$opt."\"\n";
                             }
                             elsif (1 <= length($opt)) {
                                print STDERR "mkinstaller: ...did you mean \"./".$opt."\"\n";
                             }
                             exit 1;
                          };

                       #---------------------------------------
                       #
                       #  Parameters...
                       #
                       #---------------------------------------

                       /^.+$/

                          && do {
                             print STDERR "mkinstaller:    is $opt\n" if $debugging;
                             my $given       = unquote($opt);
                             $theCommandLine = $theCommandLine." ".quoteIfReqd($given);
                             if ( ! $followSymlinks) {
                                if ( -l $given) {
                                   if ( -e $given) {
                                      print STDERR "mkinstaller: error -- \"$given\" is a symbolic-link not a directory\n";
                                   }
                                   else {
                                      print STDERR "mkinstaller: error -- \"$given\" is a broken symbolic-link not a directory\n";
                                   }
                                   exit 1;
                                }
                             }
                             if ( -d $given) {
                                if ( exists $dirPathnames{$given}) {
                                   print STDERR "mkinstaller: error -- unexpected \"$given\"\n";
                                   exit 1;
                                }
                                print STDERR "mkinstaller:    ...a directory\n" if $debugging;
                                my $bn                = basename($given);
                                if ($bn =~ /\s/) {
                                   if ($bn eq $given) {
                                      print STDERR "mkinstaller: error -- \"$given\" contains spaces and/or tabs\n";
                                   }
                                   else {
                                      print STDERR "mkinstaller: error -- basename of \"$given\" contains spaces and/or tabs\n";
                                   }
                                   exit 1;
                                }
                                if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
                                   print STDERR "mkinstaller:       has a standard basename(=$bn)\n" if $debugging;
                                   $givenStdNames     = 1;
                                   if ($bn =~ /^lib$/i) {
                                      $libDirBasename = "lib";
                                   }
                                   elsif ($bn =~ /^lib64$/i) {
                                      $libDirBasename = "lib64";
                                   }
                                }
                                else {
                                   print STDERR "mkinstaller:       has a non-standard basename(=$bn)\n" if $debugging;
                                   $givenNonStdNames = 1;
                                }
                                $dirPathnames{$given} = $bn;
                                if ( ! exists $dirBasenames{$bn}) {
                                   print STDERR "mkinstaller:       new basename \"$bn\"\n" if $debugging;
                                   my $jdx                         = $#dirBasenames + 1;
                                   $dirBasenames[$jdx]             = $bn;
                                   $dirBasenames{$bn}{"pathnames"} = [ ];
                                   $dirBasenames{$bn}{"indices"}   = [ ];
                                   $dirBasenames{$bn}{"which"}     = $jdx;
                                   $dirBasenames{$bn}{"count"}     = 0;
                                }
                                else {
                                   print STDERR "mkinstaller:       known basename \"$bn\"\n" if $debugging;
                                }
                                my $idx             = $#dirPathnames + 1;
                                $dirPathnames[$idx] = $given;
                                $dirPathnamesCount += 1;
                                push @{ $dirBasenames{$bn}{"pathnames"} }, $given;
                                push @{ $dirBasenames{$bn}{"indices"} },   $idx;
                                $dirBasenames{$bn}{"count"} += 1;
                             }
                             else {
                                if ( -e $given) {
                                   print STDERR "mkinstaller: error -- \"$given\" is not a directory\n";
                                }
                                else {
                                   print STDERR "mkinstaller: error -- can't find/read \"$given\"\n";
                                }
                                exit 1;
                             }
                             last parseArgs;
                          };

                       /^$/

                          && do {
                             print STDERR "mkinstaller: error -- zero-length parameter\n";
                             exit 1;
                          };
                    }
      }
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Deal with defaults...
   #
   #----------------------------------------------------------------------------

   print STDERR "mkinstaller: deal with defaults...\n" if $debugging;
   {
      if ($dirPathnamesCount <= 0) {
         print STDERR "mkinstaller: error -- expected at least 1 directory pathname\n";
         exit 1;
      }
      if ($OSclass eq "UNIX-like") {
#== cut here ========================================================================================================== cut here ===
         #---------------------------------------
         #
         #  On a UNIX-like host the --CC=... and
         #  the --CXX=... options are required
         #  when bin or lib (or lib64) directories
         #  are installed.
         #
         #---------------------------------------
         print STDERR "mkinstaller: ...on a UNIX-like host\n" if $debugging;
         if ( defined $CC_options) {
            print STDERR "mkinstaller:    C compiler options were specified (=$CC_options)\n" if $debugging;
            if ( ! defined $CC_name) {
               print STDERR "mkinstaller:    but no C compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: warning -- $CC_optionGiven was used but no C compiler was specified\n";
            }
         }
         if ( defined $CXX_options) {
            print STDERR "mkinstaller:    C++ compiler options were specified (=$CXX_options)\n" if $debugging;
            if ( ! defined $CXX_name) {
               print STDERR "mkinstaller:    but no C++ compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: warning -- $CXX_optionGiven was used but no C++ compiler was specified\n";
            }
         }
         if (( exists $dirBasenames{"bin"}) || ( exists $dirBasenames{"lib"}) || ( exists $dirBasenames{"lib64"})) {
            print STDERR "mkinstaller: ...a \"bin\", \"lib\", or \"lib64\" directory was specified\n" if $debugging;
            my $told = 0;
            if ( ! defined $CC_name) {
               print STDERR "mkinstaller:    but no C compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: error - a \"bin\", \"lib\", or \"lib64\" directory was specified\n" if ( ! $told);
               $told = 1;
               print STDERR "mkinstaller: ...but no C compiler was specified\n";
               exit 1;
            }
            if ( ! defined $CXX_name) {
               print STDERR "mkinstaller:    but no C++ compiler was specified\n" if $debugging;
               print STDERR "mkinstaller: error - a \"bin\", \"lib\", or \"lib64\" directory was specified\n" if ( ! $told);
               $told = 1;
               print STDERR "mkinstaller: ...but no C++ compiler was specified\n";
               exit 1;
            }
         }
         else {
            print STDERR "mkinstaller:    no \"bin\", \"lib\", or \"lib64\" directory was specified\n" if $debugging;
            if ( defined $CC_name) {
               print STDERR "mkinstaller:    but a C compiler was specified (as $CC_name)\n" if $debugging;
            }
            if ( defined $CXX_name) {
               print STDERR "mkinstaller:    but a C++ compiler was specified (as $CXX_name)\n" if $debugging;
            }
         }
         if ( defined $CC_name) {
            print STDERR "mkinstaller:    a C compiler was specified\n" if $debugging;
            if ( ! defined $CC_options) {
               print STDERR "mkinstaller:    but no C compiler options were specified\n" if $debugging;
               $CC_options = "";
            }
         }
         if ( defined $CXX_name) {
            print STDERR "mkinstaller:    a C++ compiler was specified\n" if $debugging;
            if ( ! defined $CXX_options) {
               print STDERR "mkinstaller:    but no C++ compiler options were specified\n" if $debugging;
               $CXX_options = "";
            }
         }
#== cut here ========================================================================================================== cut here ===
      }
      if ($ProjectVer ne "") {
         if ($ProjectName eq "") {
            print STDERR "mkinstaller: error -- use of --project-version requires use of --project-name\n";
            exit 1;
         }
      }
      if ($OSname eq "") {
         print STDERR "mkinstaller: ...identify host OS\n" if $debugging;
         if ($OSclass eq "UNIX-like") {
            print STDERR "mkinstaller:    is \"UNIX-like\"\n" if $debugging;
#== cut here ========================================================================================================== cut here ===
            my $Sreturn = "";
            my $Rreturn = "";
            my $cmd     = "uname -s";
            print STDERR "mkinstaller:    run [$cmd]\n" if $debugging;
            my $gives   = `$cmd`;
            my $status  = $? >> 8; chomp $gives;
            chomp $gives;
            if ($status != 0) {
               print STDERR "mkinstaller:    ...failed, exit code $status\n" if $debugging;
               $Sreturn = "";
            }
            else {
               print STDERR "mkinstaller:    ...suceeded, giving \"$Sreturn\"\n" if $debugging;
               $Sreturn = $gives;
            }
            $cmd        = "uname -r";
            print STDERR "mkinstaller:    run [$cmd]\n" if $debugging;
            $gives      = `$cmd`;
            my $status  = $? >> 8; chomp $gives;
            chomp $gives;
            if ($status != 0) {
               print STDERR "mkinstaller:    ...failed, exit code $status\n" if $debugging;
               $Rreturn = "";
            }
            else {
               print STDERR "mkinstaller:    ...suceeded, giving \"$Sreturn\"\n" if $debugging;
               $Rreturn = $gives;
            }
            if ($Sreturn ne "") {
               if ($Rreturn ne "") {
                  $OSname = "$Sreturn $Rreturn";
                  print STDERR "mkinstaller:    host OS = \"$OSname\"\n" if $debugging;
               }
            }
#== cut here ========================================================================================================== cut here ===
         }
         elsif ($OSclass eq "Windows-like") {
            print STDERR "mkinstaller:    is \"Windows-like\"\n" if $debugging;
            $OSname = "Windows";
         }
         else {
            print STDERR "mkinstaller:    is neither \"UNIX\" nor \"Windows\" like\n" if $debugging;
            print STDERR "mkinstaller: error -- can't identify the class of host\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
      }
      if ($scriptName eq "") {
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
               $scriptName = $ProjectName."-".$ProjectVer."-installer";
            }
            else {
               $scriptName = $ProjectName."-installer";
            }
         }
         else {
            $scriptName = "installer";
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
      print STDERR "mkinstaller:    scriptName        = \"$scriptName\"\n" if $debugging;

      $scriptNameU       = $scriptName;
      $scriptNameU       =~ tr/\x20-\x7f//cd;
      $scriptNameU       =~ tr/a-zA-Z0-9_/_/c;
      print STDERR "mkinstaller:    scriptNameU       = \"$scriptNameU\"\n" if $debugging;

      $SCRIPTNAME        = $scriptNameU;
      $SCRIPTNAME        =~ tr/a-z/A-Z/;
      print STDERR "mkinstaller:    SCRIPTNAME        = \"$SCRIPTNAME\"\n" if $debugging;
      $SCRIPTNAME_TMPDIR = $SCRIPTNAME."_TMPDIR";
      print STDERR "mkinstaller:    SCRIPTNAME_TMPDIR = \"$SCRIPTNAME_TMPDIR\"\n" if $debugging;
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   if ($genSHA) {
      #---------------------------------------
      #
      #  Locate appropriate hash tool (optional)...
      #
      #---------------------------------------

      print STDERR "mkinstaller: locate optional \"pshaw\" utility...\n" if $debugging;
      $use_pshaw = lookForExecutable("pshaw",\@myPath,$OSclass);
      if ($use_pshaw eq "") {
         print STDERR "mkinstaller: warning -- can't locate optional \"pshaw\" utility\n";
      }
      else {
         print STDERR "mkinstaller: ...\"$use_pshaw\"\n" if $debugging;
      }
      print STDERR "mkinstaller: locate optional \"shaNNNsum\" utility...\n" if $debugging;
      if ($genSHA == 1) {
         $use_shaNNNsum = lookForExecutable("sha1sum",\@myPath,$OSclass);
      }
      elsif ($genSHA == 256) {
         $use_shaNNNsum = lookForExecutable("sha256sum",\@myPath,$OSclass);
      }
      elsif ($genSHA == 384) {
         $use_shaNNNsum = lookForExecutable("sha384sum",\@myPath,$OSclass);
      }
      elsif ($genSHA == 512) {
         $use_shaNNNsum = lookForExecutable("sha512sum",\@myPath,$OSclass);
      }
      else {
         $use_shaNNNsum = ""
      }
      if ($use_shaNNNsum eq "") {
         print STDERR "mkinstaller: warning -- can't locate optional \"sha".$genSHA."sum\" utility\n";
      }
      else {
         print STDERR "mkinstaller: ...\"$use_shaNNNsum\"\n" if $debugging;
      }
      if ($use_shaNNNsum ne "") {
         $use_hasher    = $use_shaNNNsum;
         $use_hasherOpt = "";
      }
      elsif ($use_pshaw ne "") {
         $use_hasher    = $use_pshaw;
         $use_hasherOpt = " -".$genSHA;
         $use_hasherOpt = "";
      }
      else {
         $use_hasher    = "";
         $use_hasherOpt = "";
         $genSHA        = 0;
         print STDERR "mkinstaller: warning -- can't generate a hash file\n";
      }
      print STDERR "mkinstaller: ...using \"$use_hasher\"\n" if (1 <= $verbosityLevel);
   }

   #----------------------------------------------------------------------------
   #
   #  Initial announcments...
   #
   #----------------------------------------------------------------------------

   if (1 <= $verbosityLevel) {
      print STDERR "mkinstaller: version ".$mkinstaller_ver_name." rev. ".$mkinstaller_ver_time."\n";
      if ($OSname ne "") {
         print STDERR "mkinstaller: ...running on \"".$OSname."\"\n";
      }
      print STDERR "mkinstaller: ...running in \"".$here."\"\n";
      if ($ProjectName ne "") {
         print STDERR "mkinstaller: ...project = \"".$ProjectName."\"\n";
        if ($ProjectVer ne "") {
            print STDERR "mkinstaller:    version = \"".$ProjectVer."\"\n";
        }
      }
   }

   #----------------------------------------------------------------------------
   #
   #  If operating in standard mode with no given pathnames with standard
   #  basenames then rebuild the directory hash and list.
   #
   #----------------------------------------------------------------------------

   print STDERR "mkinstaller: deal with (non)standard pathnames...\n" if $debugging;
   {
      if ($stdMode) {
         my $rebuilt = 0;
         print STDERR "mkinstaller: ...operating in standard mode\n" if $debugging;
         if ( ! $givenStdNames) {
            print STDERR "mkinstaller:    but given no pathnames with standard basenames\n" if $debugging;
            if (1 <= $verbosityLevel) {
               print STDERR "mkinstaller: operating in \"standard\" mode but no \"standard basenames\"\n";
               if (2 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...\"bin\", \"lib\", \"lib64\", or \"include\"\n";
               }
            }
            my @allPathnames = ( );
            my $first        = 1;
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
               my $i;
               for ($i=0; $i<=$#dirs; $i+=1) {
                  my $pathname = $dirs[$i];
                  if ($first) {
                     print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
                     $first = 0;
                  }
                  else {
                     print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
                  }
                  my $idx             = $#allPathnames + 1;
                  $allPathnames[$idx] = $pathname;
               }
            }
            print STDERR "mkinstaller:    check each given directory pathname for subdirectories with standard basenames\n" if $debugging;
            my $changed       = 0;
            my $haveStdSubdir = 0;
            my @usePathnames  = ( );
            my $i;
            for ($i=0; $i<=$#allPathnames; $i+=1) {
               my $foundOne = 0;
               my $pathname = $allPathnames[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
               }
               else {
                  print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
               }
               if (opendir(DIR,"$pathname")) {
                  while (defined($tmpName1 = readdir(DIR))) {
                     if (($tmpName1 ne "" ) && ($tmpName1 ne ".") && ($tmpName1 ne "..")) {
                        if (($tmpName1 =~ /^bin$/i) || ($tmpName1 =~ /^lib$/i) || ($tmpName1 =~ /^lib64$/i) || ($tmpName1 =~ /^include$/i)) {
                           $foundOne          = 1;
                           if ($bn =~ /^lib$/i) {
                              $libDirBasename = "lib";
                           }
                           elsif ($bn =~ /^lib64$/i) {
                              $libDirBasename = "lib64";
                           }
                           last;
                        }
                     }
                  }
                  closedir(DIR);
               }
               if ($foundOne) {
                  print STDERR "mkinstaller:          has a subdir with a standard basename\n" if $debugging;
                  if (opendir(DIR,"$pathname")) {
                     while (defined($tmpName2 = readdir(DIR))) {
                        if (($tmpName2 ne "" ) && ($tmpName2 ne ".") && ($tmpName2 ne "..")) {
                           my $joinName = fixpath(joinpath($pathname,$tmpName2));
                           if ( ! $followSymlinks) {
                              if ( -l $joinName) {
                                 if ( -e $joinName) {
                                    print STDERR "mkinstaller: error -- \"$joinName\" is a symbolic-link not a directory\n";
                                 }
                                 else {
                                    print STDERR "mkinstaller: error -- \"$joinName\" is a broken symbolic-link not a directory\n";
                                 }
                                 exit 1;
                              }
                           }
                           if (-d $joinName) {
                              my $idx             = $#usePathnames + 1;
                              $usePathnames[$idx] = $joinName;
                              $changed            = 1;
                           }
                        }
                     }
                     closedir(DIR);
                  }
               }
               else {
                  print STDERR "mkinstaller:          has no subdirs with a standard basename\n" if $debugging;
                  my $idx             = $#usePathnames + 1;
                  $usePathnames[$idx] = $pathname;
               }
            }
            if ($changed) {
               if (1 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...rebuilding pathname list\n";
               }
               print STDERR "mkinstaller:    changed directory pathname list\n" if $debugging;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
                  }
                  else {
                     print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
                  }
               }
               print STDERR "mkinstaller:    rebuild directory pathname hash and list\n" if $debugging;
               $rebuilt           = 1;
               %dirBasenames      = ( );
               @dirBasenames      = ( );
               %dirPathnames      = ( );
               @dirPathnames      = ( );
               $dirPathnamesCount = 0;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
                  }
                  else {
                     print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
                  }
                  my $bn       = basename($pathname);
                  if ($bn =~ /\s/) {
                     if ($bn eq $pathname) {
                        print STDERR "mkinstaller: error -- \"$pathname\" contains spaces and/or tabs\n";
                     }
                     else {
                        print STDERR "mkinstaller: error -- basename of \"$pathname\" contains spaces and/or tabs\n";
                     }
                     exit 1;
                  }
                  if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
                     print STDERR "mkinstaller:       has a standard basename(=$bn)\n" if $debugging;
                     $givenStdNames     = 1;
                     if ($bn =~ /^lib$/i) {
                        $libDirBasename = "lib";
                     }
                     elsif ($bn =~ /^lib64$/i) {
                        $libDirBasename = "lib64";
                     }
                  }
                  else {
                     print STDERR "mkinstaller:       has a non-standard basename(=$bn)\n" if $debugging;
                     $givenNonStdNames = 1;
                  }
                  $dirPathnames{$pathname} = $bn;
                  if ( ! exists $dirBasenames{$bn}) {
                     print STDERR "mkinstaller:       new basename \"$bn\"\n" if $debugging;
                     my $jdx                         = $#dirBasenames + 1;
                     $dirBasenames[$jdx]             = $bn;
                     $dirBasenames{$bn}{"pathnames"} = [ ];
                     $dirBasenames{$bn}{"indices"}   = [ ];
                     $dirBasenames{$bn}{"which"}     = $jdx;
                     $dirBasenames{$bn}{"count"}     = 0;
                  }
                  else {
                     print STDERR "mkinstaller:       known basename \"$bn\"\n" if $debugging;
                  }
                  my $idx             = $#dirPathnames + 1;
                  $dirPathnames[$idx] = $pathname;
                  $dirPathnamesCount += 1;
                  push @{ $dirBasenames{$bn}{"pathnames"} }, $pathname;
                  push @{ $dirBasenames{$bn}{"indices"} },   $idx;
                  $dirBasenames{$bn}{"count"} += 1;
               }
               if ($debugging) {
                  print "mkinstaller:    ...done, now have:\n";
                  my $bn;
                  foreach $bn (sort keys %dirBasenames) {
                     print "mkinstaller:       \"$bn\"\n";
                     my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                     my $i;
                     for ($i=0; $i<=$#dirs; $i+=1) {
                        my $pathname = $dirs[$i];
                        print "mkinstaller:       ...\"$pathname\"\n";
                     }
                  }
               }
               if (1 <= $verbosityLevel) {
                  if (2 <= $verbosityLevel) {
                     print STDERR "mkinstaller:    done, giving:\n";
                     my $bn;
                     foreach $bn (sort keys %dirBasenames) {
                        my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                        my $i;
                        for ($i=0; $i<=$#dirs; $i+=1) {
                           my $pathname = $dirs[$i];
                           if ($i == 0) {
                              print "mkinstaller:       ...\"$pathname\"\n";
                           }
                           else {
                              print "mkinstaller:          \"$pathname\"\n";
                           }
                        }
                     }
                  }
                  else {
                     print STDERR "mkinstaller:    done\n";
                  }
               }
            }
         }
         else {
            print STDERR "mkinstaller:    given pathnames with standard basenames\n" if $debugging;
            if ($givenNonStdNames) {
               print STDERR "mkinstaller:    ...and given pathnames with non-standard basenames\n" if $debugging;
            }
         }
      }
      else {
         print STDERR "mkinstaller: ...operating in nonstandard mode\n" if $debugging;
      }
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Ready to go to work...
   #
   #----------------------------------------------------------------------------

   #------------------------------------
   #
   #  Deal with pre-install script...
   #
   #------------------------------------

   if ($preInstallPathname ne "") {
      print STDERR "mkinstaller: check the pre-install script\n" if $debugging;
      if ( ! -f $preInstallPathname) {
         print STDERR "mkinstaller: error -- can't find pre-install script \"$preInstallPathname\"\n";
         exit 1;
      }
      my $ok = 0;
      if ($preInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error -- invalid pre-install style(=\"$preInstallStyle\")\n";
         exit 1;
      }
      my $sbn = basename($preInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error -- name of pre-install script \"$preInstallPathname\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"$pathname\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"$pathname\"\n";
               }
            }
            exit 1;
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print STDERR "mkinstaller: no pre-install script\n" if $debugging;
      $preInstallStyle = "";
   }

   #------------------------------------
   #
   #  Deal with post-install script...
   #
   #------------------------------------

   if ($postInstallPathname ne "") {
      print STDERR "mkinstaller: check the post-install script\n" if $debugging;
      if ( ! -f $postInstallPathname) {
         print STDERR "mkinstaller: error -- can't find post-install script \"$postInstallPathname\"\n";
         exit 1;
      }
      my $ok = 0;
      if ($postInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error -- invalid post-install style(=\"$postInstallStyle\")\n";
         exit 1;
      }
      my $sbn = basename($postInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error -- name of post-install script \"$postInstallPathname\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"$pathname\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"$pathname\"\n";
               }
            }
            exit 1;
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print STDERR "mkinstaller: no post-install script\n" if $debugging;
      $postInstallStyle = "";
   }

   #---------------------------------------
   #
   #  Construct the title line used at the
   #  top of the --help output...
   #
   #---------------------------------------

   print STDERR "mkinstaller: prepare help title...\n" if $debugging;
   {
      my $gapString  = "   ";
      $titleLine     = $scriptName."(1x)".$gapString.$scriptName."(1x)";
      my $LtitleLine = length $titleLine;
      while ($LtitleLine < 80) {
         $gapString  = $gapString." ";
         $titleLine  = $scriptName."(1x)".$gapString.$scriptName."(1x)";
         $LtitleLine = length $titleLine;
      }
      print STDERR "mkinstaller:    [--------------------------------------------------------------------------------]\n" if $debugging;
      print STDERR "mkinstaller:    [".$titleLine."]\n" if $debugging;
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #---------------------------------------
   #
   #  Prepare a string with the project
   #  name an version used in the --help
   #  output...
   #
   #---------------------------------------

   print STDERR "mkinstaller: prepare project name version string for help...\n" if $debugging;
   {
      if ($ProjectName ne "") {
         print STDERR "mkinstaller: ...project name    = [$ProjectName]\n" if $debugging;
         if ($ProjectVer ne "") {
            print STDERR "mkinstaller: ...project version = [$ProjectVer]\n" if $debugging;
            $ForProject = " for ".$ProjectName." ver. ".$ProjectVer;
         }
         else {
            $ForProject = " for ".$ProjectName;
            print STDERR "mkinstaller: ...no project version\n" if $debugging;
         }
      }
      else {
         print STDERR "mkinstaller: ...no project name\n" if $debugging;
         $ForProject = "";
      }
      print STDERR "mkinstaller:    [".$ForProject."]\n" if $debugging;
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Locate a directory for temporaries...
   #
   #  Intents: TmpDir  -- The top-level temp directory as supplied by the
   #                      environment. This directory will not be deleted.
   #
   #           TmpDirT -- The top-level directory specific to this run of
   #                      the mkinstaller script. It will be deleted when
   #                      this run is completed (unless the --keep option is
   #                      specified).
   #
   #           TmpDirI -- Individual directories (such as bin/) are tar'd-up
   #                      from their given site into TmpDirI. Are sub-
   #                      directories of $TmpDirT
   #           TmpDirA -- The tarball (bin.tar.gz) is then expanded from the
   #                      into the accumulator directory TmpDirA (overlaying
   #                      what may be there). The tarball in TmpDirI may then
   #                      be deleted. Is a sub-directory of $TmpDirT
   #
   #           TmpDirW -- The directories (such as bin/) in the accumulator
   #                      directory TmpDirA are then tar'd up in to the wrapper
   #                      directory TmpDirW which is eventually tar'd up as the
   #                      collective payload (wrapper.tar). Is a sub-directory
   #                      of $TmpDirT
   #
   #           TmpFile -- The partially built installer script. To be joined
   #                      with the collective payload to form the installer
   #                      script.
   #
   #----------------------------------------------------------------------------

   print STDERR "mkinstaller: identify temp directory...\n" if $debugging;
   if ($TmpDir eq "") {
      if ( exists $ENV{'MKINSTALLER_TMPDIR'} ) {
         my $TryTmp = $ENV{'MKINSTALLER_TMPDIR'};
         print STDERR "mkinstaller: ...MKINSTALLER_TMPDIR gave \"$TmpDir\"\n" if $debugging;
         if ( -d $TryTmp) {
            $TmpDir = $TryTmp;
         }
         else {
            print STDERR "mkinstaller:    which is not a valid directory\n" if $debugging;
         }
      }
   }
   if ($TmpDir eq "") {
      $TmpDir = findTempDir("MKINSTALLER_TMPDIR");
      if ($TmpDir eq "") {
         print STDERR "mkinstaller: error -- can't decide on a location for a temp directory\n";
         exit 1;
      }
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;
   $TmpDir  = absname($TmpDir);
   print STDERR "mkinstaller:    use: \"$TmpDir\"\n" if $debugging;
   $TmpDirT = "$TmpDir/mki.$$";
   print STDERR "mkinstaller:         \"$TmpDirT\"\n" if $debugging;
   $TmpDirA = "$TmpDirT/accumulator";
   print STDERR "mkinstaller:         \"$TmpDirA\"\n" if $debugging;
   $TmpDirI = "$TmpDirT/initial";
   print STDERR "mkinstaller:         \"$TmpDirI\"\n" if $debugging;
   $TmpDirW = "$TmpDirT/wrapper";
   print STDERR "mkinstaller:         \"$TmpDirW\"\n" if $debugging;
   $TmpFile = "$TmpDirT/script.tmp";
   print STDERR "mkinstaller:         \"$TmpFile\"\n" if $debugging;

   #---------------------------------------
   #
   #  Prepare temporary directories...
   #
   #---------------------------------------

   print STDERR "mkinstaller: prepare temporary directories...\n" if $debugging;
   {
      print STDERR "mkinstaller: ...check for \"$TmpDirT\"\n" if $debugging;
      if ( -l $TmpDirT) {
         print STDERR "mkinstaller: error -- \"$TmpDirT\" already exists\n";
         if ( -e $TmpDirT) {
            print STDERR "mkinstaller: ...as a symbolic-link\n";
         }
         else {
            print STDERR "mkinstaller: ...as a broken symbolic-link\n";
         }
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      if ( -e $TmpDirT) {
         print STDERR "mkinstaller: error -- \"$TmpDirT\" already exists\n";
         if ( -d $TmpDirT) {
            print STDERR "mkinstaller: ...as a directory\n";
         }
         elsif ( -f $TmpDirT) {
            print STDERR "mkinstaller: ...as a file\n";
         }
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      print STDERR "mkinstaller: ...create \"$TmpDirT\"\n" if $debugging;
      if ( ! mkDirectory($TmpDirT,1)) {
         print STDERR "mkinstaller: error -- can't create new \"$TmpDirT\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      print STDERR "mkinstaller: ...create \"$TmpDirA\"\n" if $debugging;
      if ( ! mkDirectory($TmpDirA,1)) {
         print STDERR "mkinstaller: error -- can't create new \"$TmpDirA\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      print STDERR "mkinstaller: ...create \"$TmpDirI\"\n" if $debugging;
      if ( ! mkDirectory($TmpDirI,1)) {
         print STDERR "mkinstaller: error -- can't create new \"$TmpDirI\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      print STDERR "mkinstaller: ...create \"$TmpDirW\"\n" if $debugging;
      if ( ! mkDirectory($TmpDirW,1)) {
         print STDERR "mkinstaller: error -- can't create new \"$TmpDirW\" directory\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      if (1 <= $verbosityLevel) {
         print STDERR "mkinstaller: ...location for temporaries is \"".$TmpDir."\"\n";
         print STDERR "mkinstaller:       my top temp directory is \"".$TmpDirT."\"\n";
      }
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #============================================================================

   if ($OSclass eq "UNIX-like") {
#== cut here ========================================================================================================== cut here ===

      #-------------------------------------------------------------------------
      #
      #  On a UNIX-like host we will want to get version number for the C
      #  and C++ compilers.
      #
      #-------------------------------------------------------------------------

      {
         print STDERR "mkinstaller: Check C compiler version\n" if $debugging;
         my $tmp        = mki_checkForCompilerVersion($CC_name);
         if ($tmp =~ /^\s*(\S+)\s+(\d+(\.\d+)*)([^.0-9].*)?$/) {
            my $part1   = $1;
            my $part2   = $2;
            my $part3   = $3;
            my $part4   = $4;
            print STDERR "mkinstaller:    part1 = [$part1]\n" if $debugging;
            print STDERR "mkinstaller:    part2 = [$part2]\n" if $debugging;
            print STDERR "mkinstaller:    part3 = [$part3]\n" if $debugging;
            print STDERR "mkinstaller:    part4 = [$part4]\n" if $debugging;
            $CC_version  = $part2;
            print STDERR "mkinstaller: ...gives $CC_version\n" if $debugging;
         }
         else {
            print STDERR "mkinstaller:    failed\n" if $debugging;
         }
         print STDERR "mkinstaller: Check C++ compiler version\n" if $debugging;
         my $tmp        = mki_checkForCompilerVersion($CXX_name);
         if ($tmp =~ /^\s*(\S+)\s+(\d+(\.\d+)*)([^.0-9].*)?$/) {
            my $part1   = $1;
            my $part2   = $2;
            my $part3   = $3;
            my $part4   = $4;
            print STDERR "mkinstaller:    part1 = [$part1]\n" if $debugging;
            print STDERR "mkinstaller:    part2 = [$part2]\n" if $debugging;
            print STDERR "mkinstaller:    part3 = [$part3]\n" if $debugging;
            print STDERR "mkinstaller:    part4 = [$part4]\n" if $debugging;
            $CXX_version = $part2;
            print STDERR "mkinstaller: ...gives $CXX_version\n" if $debugging;
         }
         else {
            print STDERR "mkinstaller:    failed\n" if $debugging;
         }
      }

      #-------------------------------------------------------------------------
      #
      #  On a UNIX-like host (Linux in particular) we will want to get version
      #  numbers for the C library, Standard C++ library, and C++ ABI.
      #
      #-------------------------------------------------------------------------

      print STDERR "mkinstaller: Check library versions\n" if $debugging;
      @CC_libcVerList    = ( );
      $CC_libcVersion    = "";
      @CXX_libcxxVerList = ( );
      $CXX_libcxxVersion = "";
      @CXX_abiVerList    = ( );
      $CXX_abiVersion    = "";
      if (mki_stdlibcxx_version()) {
         print STDERR "mkinstaller: ...done\n" if $debugging;
         my $Nlibc      = $#CC_libcVerList + 1;
         my $Nstdlibcxx = $#CXX_libcxxVerList + 1;
         my $Nabi       = $#CXX_abiVerList + 1;
         if (1 <= $Nlibc) {
            $CC_libcVersion    = $CC_libcVerList[0];
         }
         else {
            $CC_libcVersion    = "";
         }
         if (1 <= $Nstdlibcxx) {
            $CXX_libcxxVersion = $CXX_libcxxVerList[0];
         }
         else {
            $CXX_libcxxVersion = "";
         }
         if (1 <= $Nabi) {
            $CXX_abiVersion    = $CXX_abiVerList[0];
         }
         else {
            $CXX_abiVersion    = "";
         }
         if (1 <= $verbosityLevel) {
            if ($CC_libcVersion ne "") {
               print STDERR "mkinstaller: ...C library version number is $CC_libcVersion\n";
            }
            else {
               print STDERR "mkinstaller: didn't find C library version number\n";
            }
            if ($CXX_libcxxPathname ne "") {
               print STDERR "mkinstaller: found Standard C++ library at \"$CXX_libcxxPathname\"\n";
            }
            else {
               print STDERR "mkinstaller: didn't find Standard C++ library\n";
            }
            if ($CXX_libcxxVersion ne "") {
               print STDERR "mkinstaller: ...C++ Standard library version number is $CXX_libcxxVersion\n";
            }
            else {
               print STDERR "mkinstaller: didn't find C++ Standard library library version number\n";
            }
            if ($CC_libcVersion ne "") {
               print STDERR "mkinstaller: ...C++ ABI version number is $CXX_abiVersion version number\n";
            }
            else {
               print STDERR "mkinstaller: didn't find C++ ABI library version number\n";
            }
         }
      }
      else {
         print STDERR "mkinstaller:    ...failed\n" if $debugging;
      }

      #-------------------------------------------------------------------------
      #
      #  On a UNIX-like host we will want to get version number for the
      #  operating system (aka. kernel on Linux).
      #
      #-------------------------------------------------------------------------

      print STDERR "mkinstaller: Check library versions\n" if $debugging;
      {
         my $versionNumber = mki_os_version();
         if ($versionNumber != "") {
            $OSversion = $versionNumber;
            print STDERR "mkinstaller: ...done, is $OSversion\n" if $debugging;
         }
         else {
            print STDERR "mkinstaller: ...failed\n" if $debugging;
         }
         if ($OSversion ne "") {
            print STDERR "mkinstaller: ...Operating System version number is $OSversion\n" if (1 <= verbosityLevel);
         }
         else {
            print STDERR "mkinstaller: warning didn't find operating system version number\n";
         }
      }
#== cut here ========================================================================================================== cut here ===
   }
   elsif ($OSclass eq "Windows-like") {
#== cut here ========================================================================================================== cut here ===
      #-------------------------------------------------------------------------
      #
      #  On a Window-like host there isn't really a need for version numbers
      #  for the C++ ABI, Standard C++ library, and C library.
      #
      #-------------------------------------------------------------------------

      print STDERR "mkinstaller: Don't bother checking library versions\n" if $debugging;
#== cut here ========================================================================================================== cut here ===
   }
   else {
      print STDERR "mkinstaller: error -- can't identify the class of host\n";
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
      exit 1;
   }

   #----------------------------------------------------------------------------
   #
   #  Initial announcments...
   #
   #----------------------------------------------------------------------------

   if (1 <= $verbosityLevel) {
      print STDERR "mkinstaller: version ".$mkinstaller_ver_name." rev. ".$mkinstaller_ver_time."\n";
      if ($OSname ne "") {
         print STDERR "mkinstaller: ...running on \"".$OSname."\"\n";
      }
      print STDERR "mkinstaller: ...running in \"".$here."\"\n";
      if ($ProjectName ne "") {
         print STDERR "mkinstaller: ...project = \"".$ProjectName."\"\n";
        if ($ProjectVer ne "") {
            print STDERR "mkinstaller:    version = \"".$ProjectVer."\"\n";
        }
      }
   }

   #----------------------------------------------------------------------------
   #
   #  If operating in standard mode with no given pathnames with standard
   #  basenames then rebuild the directory hash and list.
   #
   #----------------------------------------------------------------------------

   print STDERR "mkinstaller: deal with (non)standard pathnames...\n" if $debugging;
   {
      if ($stdMode) {
         my $rebuilt = 0;
         print STDERR "mkinstaller: ...operating in standard mode\n" if $debugging;
         if ( ! $givenStdNames) {
            print STDERR "mkinstaller:    but given no pathnames with standard basenames\n" if $debugging;
            if (1 <= $verbosityLevel) {
               print STDERR "mkinstaller: operating in \"standard\" mode but no \"standard basenames\"\n";
               if (2 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...\"bin\", \"lib\", \"lib64\", or \"include\"\n";
               }
            }
            my @allPathnames = ( );
            my $first        = 1;
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
               my $i;
               for ($i=0; $i<=$#dirs; $i+=1) {
                  my $pathname = $dirs[$i];
                  if ($first) {
                     print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
                     $first = 0;
                  }
                  else {
                     print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
                  }
                  my $idx             = $#allPathnames + 1;
                  $allPathnames[$idx] = $pathname;
               }
            }
            print STDERR "mkinstaller:    check each given directory pathname for subdirectories with standard basenames\n" if $debugging;
            my $changed       = 0;
            my $haveStdSubdir = 0;
            my @usePathnames  = ( );
            my $i;
            for ($i=0; $i<=$#allPathnames; $i+=1) {
               my $foundOne = 0;
               my $pathname = $allPathnames[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
               }
               else {
                  print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
               }
               if (opendir(DIR,"$pathname")) {
                  while (defined($tmpName1 = readdir(DIR))) {
                     if (($tmpName1 ne "" ) && ($tmpName1 ne ".") && ($tmpName1 ne "..")) {
                        if (($tmpName1 =~ /^bin$/i) || ($tmpName1 =~ /^lib$/i) || ($tmpName1 =~ /^lib64$/i) || ($tmpName1 =~ /^include$/i)) {
                           $foundOne          = 1;
                           if ($bn =~ /^lib$/i) {
                              $libDirBasename = "lib";
                           }
                           elsif ($bn =~ /^lib64$/i) {
                              $libDirBasename = "lib64";
                           }
                           last;
                        }
                     }
                  }
                  closedir(DIR);
               }
               if ($foundOne) {
                  print STDERR "mkinstaller:          has a subdir with a standard basename\n" if $debugging;
                  if (opendir(DIR,"$pathname")) {
                     while (defined($tmpName2 = readdir(DIR))) {
                        if (($tmpName2 ne "" ) && ($tmpName2 ne ".") && ($tmpName2 ne "..")) {
                           my $joinName = fixpath(joinpath($pathname,$tmpName2));
                           if ( ! $followSymlinks) {
                              if ( -l $joinName) {
                                 if ( -e $joinName) {
                                    print STDERR "mkinstaller: error -- \"$joinName\" is a symbolic-link not a directory\n";
                                 }
                                 else {
                                    print STDERR "mkinstaller: error -- \"$joinName\" is a broken symbolic-link not a directory\n";
                                 }
                                 exit 1;
                              }
                           }
                           if (-d $joinName) {
                              my $idx             = $#usePathnames + 1;
                              $usePathnames[$idx] = $joinName;
                              $changed            = 1;
                           }
                        }
                     }
                     closedir(DIR);
                  }
               }
               else {
                  print STDERR "mkinstaller:          has no subdirs with a standard basename\n" if $debugging;
                  my $idx             = $#usePathnames + 1;
                  $usePathnames[$idx] = $pathname;
               }
            }
            if ($changed) {
               if (1 <= $verbosityLevel) {
                  print STDERR "mkinstaller: ...rebuilding pathname list\n";
               }
               print STDERR "mkinstaller:    changed directory pathname list\n" if $debugging;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
                  }
                  else {
                     print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
                  }
               }
               print STDERR "mkinstaller:    rebuild directory pathname hash and list\n" if $debugging;
               $rebuilt           = 1;
               %dirBasenames      = ( );
               @dirBasenames      = ( );
               %dirPathnames      = ( );
               @dirPathnames      = ( );
               $dirPathnamesCount = 0;
               my $i;
               for ($i=0; $i<=$#usePathnames; $i+=1) {
                  my $pathname = $usePathnames[$i];
                  if ($i == 0) {
                     print STDERR "mkinstaller:    ...\"$pathname\"\n" if $debugging;
                  }
                  else {
                     print STDERR "mkinstaller:       \"$pathname\"\n" if $debugging;
                  }
                  my $bn       = basename($pathname);
                  if ($bn =~ /\s/) {
                     if ($bn eq $pathname) {
                        print STDERR "mkinstaller: error -- \"$pathname\" contains spaces and/or tabs\n";
                     }
                     else {
                        print STDERR "mkinstaller: error -- basename of \"$pathname\" contains spaces and/or tabs\n";
                     }
                     exit 1;
                  }
                  if (($bn =~ /^bin$/i) || ($bn =~ /^lib$/i) || ($bn =~ /^lib64$/i) || ($bn =~ /^include$/i)) {
                     print STDERR "mkinstaller:       has a standard basename(=$bn)\n" if $debugging;
                     $givenStdNames     = 1;
                     if ($bn =~ /^lib$/i) {
                        $libDirBasename = "lib";
                     }
                     elsif ($bn =~ /^lib64$/i) {
                        $libDirBasename = "lib64";
                     }
                  }
                  else {
                     print STDERR "mkinstaller:       has a non-standard basename(=$bn)\n" if $debugging;
                     $givenNonStdNames = 1;
                  }
                  $dirPathnames{$pathname} = $bn;
                  if ( ! exists $dirBasenames{$bn}) {
                     print STDERR "mkinstaller:       new basename \"$bn\"\n" if $debugging;
                     my $jdx                         = $#dirBasenames + 1;
                     $dirBasenames[$jdx]             = $bn;
                     $dirBasenames{$bn}{"pathnames"} = [ ];
                     $dirBasenames{$bn}{"indices"}   = [ ];
                     $dirBasenames{$bn}{"which"}     = $jdx;
                     $dirBasenames{$bn}{"count"}     = 0;
                  }
                  else {
                     print STDERR "mkinstaller:       known basename \"$bn\"\n" if $debugging;
                  }
                  my $idx             = $#dirPathnames + 1;
                  $dirPathnames[$idx] = $pathname;
                  $dirPathnamesCount += 1;
                  push @{ $dirBasenames{$bn}{"pathnames"} }, $pathname;
                  push @{ $dirBasenames{$bn}{"indices"} },   $idx;
                  $dirBasenames{$bn}{"count"} += 1;
               }
               if ($debugging) {
                  print "mkinstaller:    ...done, now have:\n";
                  my $bn;
                  foreach $bn (sort keys %dirBasenames) {
                     print "mkinstaller:       \"$bn\"\n";
                     my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                     my $i;
                     for ($i=0; $i<=$#dirs; $i+=1) {
                        my $pathname = $dirs[$i];
                        print "mkinstaller:       ...\"$pathname\"\n";
                     }
                  }
               }
               if (1 <= $verbosityLevel) {
                  if (2 <= $verbosityLevel) {
                     print STDERR "mkinstaller:    done, giving:\n";
                     my $bn;
                     foreach $bn (sort keys %dirBasenames) {
                        my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
                        my $i;
                        for ($i=0; $i<=$#dirs; $i+=1) {
                           my $pathname = $dirs[$i];
                           if ($i == 0) {
                              print "mkinstaller:       ...\"$pathname\"\n";
                           }
                           else {
                              print "mkinstaller:          \"$pathname\"\n";
                           }
                        }
                     }
                  }
                  else {
                     print STDERR "mkinstaller:    done\n";
                  }
               }
            }
         }
         else {
            print STDERR "mkinstaller:    given pathnames with standard basenames\n" if $debugging;
            if ($givenNonStdNames) {
               print STDERR "mkinstaller:    ...and given pathnames with non-standard basenames\n" if $debugging;
            }
         }
      }
      else {
         print STDERR "mkinstaller: ...operating in nonstandard mode\n" if $debugging;
      }
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  Ready to go to work...
   #
   #----------------------------------------------------------------------------

   #------------------------------------
   #
   #  Deal with pre-install script...
   #
   #------------------------------------

   if ($preInstallPathname ne "") {
      print STDERR "mkinstaller: check the pre-install script\n" if $debugging;
      if ( ! -f $preInstallPathname) {
         print STDERR "mkinstaller: error -- can't find pre-install script \"$preInstallPathname\"\n";
         exit 1;
      }
      my $ok = 0;
      if ($preInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($preInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error -- invalid pre-install style(=\"$preInstallStyle\")\n";
         exit 1;
      }
      my $sbn = basename($preInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error -- name of pre-install script \"$preInstallPathname\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"$pathname\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"$pathname\"\n";
               }
            }
            exit 1;
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print STDERR "mkinstaller: no pre-install script\n" if $debugging;
      $preInstallStyle = "";
   }

   #------------------------------------
   #
   #  Deal with post-install script...
   #
   #------------------------------------

   if ($postInstallPathname ne "") {
      print STDERR "mkinstaller: check the post-install script\n" if $debugging;
      if ( ! -f $postInstallPathname) {
         print STDERR "mkinstaller: error -- can't find post-install script \"$postInstallPathname\"\n";
         exit 1;
      }
      my $ok = 0;
      if ($postInstallStyle eq "binary") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "perl") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "python") {
         $ok = 1;
      }
      elsif ($postInstallStyle eq "sh") {
         $ok = 1;
      }
      if ( ! $ok) {
         print STDERR "mkinstaller: error -- invalid post-install style(=\"$postInstallStyle\")\n";
         exit 1;
      }
      my $sbn = basename($postInstallPathname);
      foreach $bn (sort keys %dirBasenames) {
         if ($bn eq $sbn) {
            print STDERR "mkinstaller: error -- name of post-install script \"$postInstallPathname\" collides with basename of:\n";
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               if ($i == 0) {
                  print STDERR "mkinstaller: ...\"$pathname\"\n";
               }
               else {
                  print STDERR "mkinstaller:    \"$pathname\"\n";
               }
            }
            exit 1;
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
   }
   else {
      print STDERR "mkinstaller: no post-install script\n" if $debugging;
      $postInstallStyle = "";
   }

   #---------------------------------------
   #
   #  Construct the title line used at the
   #  top of the --help output...
   #
   #---------------------------------------

   print STDERR "mkinstaller: prepare help title...\n" if $debugging;
   {
      my $gapString  = "   ";
      $titleLine     = $scriptName."(1x)".$gapString.$scriptName."(1x)";
      my $LtitleLine = length $titleLine;
      while ($LtitleLine < 80) {
         $gapString  = $gapString." ";
         $titleLine  = $scriptName."(1x)".$gapString.$scriptName."(1x)";
         $LtitleLine = length $titleLine;
      }
      print STDERR "mkinstaller:    [--------------------------------------------------------------------------------]\n" if $debugging;
      print STDERR "mkinstaller:    [".$titleLine."]\n" if $debugging;
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #---------------------------------------
   #
   #  Prepare a string with the project
   #  name an version used in the --help
   #  output...
   #
   #---------------------------------------

   print STDERR "mkinstaller: prepare project name version string for help...\n" if $debugging;
   {
      if ($ProjectName ne "") {
         print STDERR "mkinstaller: ...project name    = [$ProjectName]\n" if $debugging;
         if ($ProjectVer ne "") {
            print STDERR "mkinstaller: ...project version = [$ProjectVer]\n" if $debugging;
            $ForProject = " for ".$ProjectName." ver. ".$ProjectVer;
         }
         else {
            $ForProject = " for ".$ProjectName;
            print STDERR "mkinstaller: ...no project version\n" if $debugging;
         }
      }
      else {
         print STDERR "mkinstaller: ...no project name\n" if $debugging;
         $ForProject = "";
      }
      print STDERR "mkinstaller:    [".$ForProject."]\n" if $debugging;
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   if ($OSclass eq "UNIX-like") {
#== cut here ========================================================================================================== cut here ===

      #=========================================================================
      #
      #  This is a UNIX-like host
      #
      #  The installer script to be generated will be a self-extracting Bourne-
      #  shell script. The payload is a tar file containing one or more tarballs
      #  (compressed tar files) and an optional pre- and/or post-install scripts.
      #
      #  This section of the mkinstaller script is devoted to forming the
      #  tarballs and building the script (plus adding the tarball).
      #
      #=========================================================================

      print STDERR "mkinstaller: working on a \"$OSclass\" host\n" if $debugging;

      if ($withPayload) {
         #---------------------------------------
         #
         #  Locate tar (is required)...
         #
         #---------------------------------------

         print STDERR "mkinstaller: locate required \"tar\" utility...\n" if $debugging;
         $use_tar = lookForExecutable("tar",\@myPath,$OSclass);
         if ($use_tar eq "") {
            print STDERR "mkinstaller: error -- can't locate required \"tar\" utility\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         print STDERR "mkinstaller: ...found \"$use_tar\"\n" if $debugging;
         print STDERR "mkinstaller: ...using \"$use_tar\"\n" if (1 <= $verbosityLevel);
      }
      else {
         print STDERR "mkinstaller: without a payload, don't require \"tar\" utility\n" if $debugging;
      }

      #---------------------------------------
      #
      #  Destroy existing script (if any)...
      #
      #---------------------------------------

      print STDERR "mkinstaller: cleanup existing script...\n" if $debugging;
      {
         my $Tstart = time();
         print STDERR "mkinstaller: initial cleanup\n" if (1 <= $verbosityLevel);
         if ( -l "$here/$scriptName") {
            if ( -e "$here/$scriptName") {
               print STDERR "mkinstaller: error -- \"$here/$scriptName\" is a symbolic-link not a file\n";
            }
            else {
               print STDERR "mkinstaller: error -- \"$here/$scriptName\" is a broken symbolic-link not a file\n";
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         elsif ( -f "$here/$scriptName") {
            print STDERR "mkinstaller: ...destroy existing \"$here/$scriptName\" script\n" if (2 <= $verbosityLevel);
            my $Ndeleted = unlink "$here/$scriptName";
            if ($Ndeleted < 1) {
               print STDERR "mkinstaller: error -- can't destroy existing \"$here/$scriptName\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            if ( -f "$here/$scriptName") {
               print STDERR "mkinstaller: error -- didn't destroy existing \"$here/$scriptName\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            print STDERR "mkinstaller:    done\n" if (3 <= $verbosityLevel);
         }
         elsif ( -e "$here/$scriptName") {
            print STDERR "mkinstaller: error -- existing \"$here/$scriptName\" is not a file\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         my $Tend = time();
         my $dT   = $Tend - $Tstart;
         if (0 <= $dT) {
            if ($dT == 0) {
               print STDERR "mkinstaller: ...done (in <1 second)\n" if (2 <= $verbosityLevel);
            }
            elsif ($dT == 0) {
               print STDERR "mkinstaller: ...done (in $dT second)\n" if (2 <= $verbosityLevel);
            }
            else {
               print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (2 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller: ...done\n" if (2 <= $verbosityLevel);
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;

      #---------------------------------------
      #
      #  Tarup each of the individual directories
      #  from their given sites placing the
      #  individual tarballs into the wrapper
      #  directory TmpDirW.
      #
      #  Note that these individual tarballs
      #  are compressed (.tar.gz files).
      #
      #---------------------------------------

      if ($withPayload) {
         print STDERR "mkinstaller: process given directories...\n" if $debugging;
         print STDERR "mkinstaller: ...first tarup to $TmpDirI directory...\n" if $debugging;
         print STDERR "mkinstaller:    then untar to $TmpDirA directory (to merge)\n" if $debugging;
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $Tstart = time();
               print STDERR "mkinstaller: working \"$bn\"\n" if (1 <= $verbosityLevel);
               my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
               my $i;
               for ($i=0; $i<=$#dirs; $i+=1) {
                  my $pathname = $dirs[$i];
                  print STDERR "mkinstaller: ...\"$pathname\"\n" if $debugging;
                  if ($i == 0) {
                     print STDERR "mkinstaller: ...\"$pathname\"\n" if (2 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller:    \"$pathname\"\n" if (2 <= $verbosityLevel);
                  }
                  my $dn       = dirname($pathname);
                  my $bn       = basename($pathname);
                  if ( ! chdir($dn)) {
                     print STDERR "mkinstaller: error -- can't cd into \"$dn\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
                  {
                     #
                     #  First tar it up in to the individual tarball directory TmpDirI
                     #
                     print STDERR "mkinstaller:    tarup \"$dn/$bn\" to form \"$TmpDirI/$bn.tar.gz\"\n" if $debugging;
                     my $cmd    = "\"$use_tar\" -czf \"$TmpDirI/$bn.tar.gz\" \"$bn\"";
                     print STDERR "mkinstaller:    ...run [$cmd]\n" if $debugging;
                     my $status = system "$cmd >$devNull 2>&1";
                     if ($status != 0) {
                        print STDERR "mkinstaller:       failed, exit code $status\n" if $debugging;
                        print STDERR "mkinstaller: error -- can't tarup \"$bn\"\n";
                        print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                        print STDERR "mkinstaller:    was done from in \"$dn\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        exit 1;
                     }
                     print STDERR "mkinstaller:       succeeded\n" if $debugging;
                     if ( ! -f "$TmpDirI/$bn.tar.gz") {
                        print STDERR "mkinstaller: error -- didn't tarup \"$bn\"\n";
                        print STDERR "mkinstaller: ...[$cmd] failed\n";
                        print STDERR "mkinstaller:    was done from in \"$dn\"\n";
                        print STDERR "mkinstaller: ...can't find \"$TmpDirI/$bn.tar.gz\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        exit 1;
                     }
                  }
                  if ( ! chdir($here)) {
                     print STDERR "mkinstaller: error -- can't cd back to \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
                  if ( ! chdir($TmpDirA)) {
                     print STDERR "mkinstaller: error -- can't cd into \"$TmpDirA\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
                  {
                     #
                     #  Then untar the individual tarball over any existing
                     #  directory in to the accumulator directory TmpDirA
                     #
                     my $cmd    = "\"$use_tar\" -xzf \"$TmpDirI/$bn.tar.gz\"";
                     print STDERR "mkinstaller:    run [$cmd]\n" if $debugging;
                     my $status = system "$cmd >$devNull 2>&1";
                     if ($status != 0) {
                        print STDERR "mkinstaller:    ...failed, exit code $status\n" if $debugging;
                        print STDERR "mkinstaller: error -- can't tarup \"$bn\"\n";
                        print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                        print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        exit 1;
                     }
                     print STDERR "mkinstaller:    ...succeeded\n" if $debugging;
                     if ( ! -d "$TmpDirA/$bn") {
                        print STDERR "mkinstaller: error -- didn't untar \"$bn\"\n";
                        print STDERR "mkinstaller: ...[$cmd] failed\n";
                        print STDERR "mkinstaller: ...can't find \"$TmpDirA/$bn\"\n";
                        print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                        cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                        exit 1;
                     }
                     if ( -f "$TmpDirI/$bn.tar.gz") {
                        if ( ! unlink("$TmpDirI/$bn.tar.gz")) {
                           print STDERR "mkinstaller: error -- can't delete \"$TmpDirI/$bn.tar.gz\"\n";
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           exit 1;
                        }
                        if ( -f "$TmpDirI/$bn.tar.gz") {
                           print STDERR "mkinstaller: error -- didn't delete \"$TmpDirI/$bn.tar.gz\"\n";
                           cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                           exit 1;
                        }
                     }
                  }
                  if ( ! chdir($here)) {
                     print STDERR "mkinstaller: error -- can't cd back to \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
               }
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }
            #
            #  The merging process is done, now tarup the merged individual
            #  directories from the accumulator directory in to the wrapper
            #  directory TmpDirW
            #
            print STDERR "mkinstaller: ...tarup the individual directories into the wrapper directory\n" if $debugging;
            if ( ! chdir($TmpDirA)) {
               print STDERR "mkinstaller: error -- can't cd into \"$TmpDirA\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            {
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  print STDERR "mkinstaller:    \"$bn\"\n" if $debugging;
                  if ( ! -d $bn) {
                     print STDERR "mkinstaller: error -- can't find \"$TmpDirA/$bn\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
                  my $cmd    = "\"$use_tar\" -czf \"$TmpDirW/$bn.tar.gz\" \"$bn\"";
                  print STDERR "mkinstaller:    ...run [$cmd]\n" if $debugging;
                  my $status = system "$cmd >$devNull 2>&1";
                  if ($status != 0) {
                     print STDERR "mkinstaller:       failed, exit code $status\n" if $debugging;
                     print STDERR "mkinstaller: error -- can't tarup \"$bn\"\n";
                     print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                     print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
                  print STDERR "mkinstaller:       succeeded\n" if $debugging;
                  if ( ! -f "$TmpDirW/$bn.tar.gz") {
                     print STDERR "mkinstaller: error -- didn't tarup \"$bn\"\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"$TmpDirW/$bn.tar.gz\"\n";
                     print STDERR "mkinstaller:    was done from in \"$TmpDirA\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
               }
            }
            if ( ! chdir($here)) {
               print STDERR "mkinstaller: error -- can't cd back to \"$here\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
         }
         print STDERR "mkinstaller: ...done\n" if $debugging;

         #---------------------------------------
         #
         #  Add the given pre-install script (if
         #  any) to the wrapper directory.
         #
         #---------------------------------------

         if ($preInstallPathname ne "") {
            if ( -f $preInstallPathname) {
               my $Tstart = time();
               print STDERR "mkinstaller: working \"$preInstallPathname\" (a $preInstallStyle pre-install script)\n" if (1 <= $verbosityLevel);
               print STDERR "mkinstaller: add \"$preInstallPathname \" wrapper directory...\n" if $debugging;
               my $bn     = basename($preInstallPathname);
               my $cmd    = "cp -p \"$preInstallPathname\" \"$TmpDirW/$bn\"";
               print STDERR "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "$cmd >$devNull 2>&1";
               if ($status != 0) {
                  print STDERR "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error -- can't add pre-install script to wrapper directory\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"$here\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  exit 1;
               }
               else {
                  print STDERR "mkinstaller:    succeeded\n" if $debugging;
                  if ( ! -f "$TmpDirW/$bn") {
                     print STDERR "mkinstaller: error -- didn't add pre-install script to wrapper directory\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"$TmpDirW/$bn\"\n";
                     print STDERR "mkinstaller:    was done from in \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
               }
               print STDERR "mkinstaller: ...done\n" if $debugging;
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }
            else {
               print STDERR "mkinstaller: can't find \"$preInstallPathname\"\n" if (1 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller: no pre-install script\n" if (1 <= $verbosityLevel);
         }

         #---------------------------------------
         #
         #  Add the given post-install script (if
         #  any) to the wrapper directory.
         #
         #---------------------------------------

         if ($postInstallPathname ne "") {
            if ( -f $postInstallPathname) {
               my $Tstart = time();
               print STDERR "mkinstaller: working \"$postInstallPathname\" (a $postInstallStyle post-install script)\n" if (1 <= $verbosityLevel);
               print STDERR "mkinstaller: add \"$postInstallPathname \" wrapper directory...\n" if $debugging;
               my $bn     = basename($postInstallPathname);
               my $cmd    = "cp -p \"$postInstallPathname\" \"$TmpDirW/$bn\"";
               print STDERR "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "$cmd >$devNull 2>&1";
               if ($status != 0) {
                  print STDERR "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error -- can't add post-install script to wrapper directory\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"$here\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  exit 1;
               }
               else {
                  print STDERR "mkinstaller:    succeeded\n" if $debugging;
                  if ( ! -f "$TmpDirW/$bn") {
                     print STDERR "mkinstaller: error -- didn't add post-install script to wrapper directory\n";
                     print STDERR "mkinstaller: ...[$cmd] failed\n";
                     print STDERR "mkinstaller: ...can't find \"$TmpDirW/$bn\"\n";
                     print STDERR "mkinstaller:    was done from in \"$here\"\n";
                     cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                     exit 1;
                  }
               }
               print STDERR "mkinstaller: ...done\n" if $debugging;
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (3 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (3 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (3 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (3 <= $verbosityLevel);
               }
            }
            else {
               print STDERR "mkinstaller: can't find \"$postInstallPathname\"\n" if (1 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller: no post-install script\n" if (1 <= $verbosityLevel);
         }

         #---------------------------------------
         #
         #  Finally arup the temporary wrapper
         #  directory TmpDirW carrying the individual
         #  tarballs).
         #
         #  Note that this wrapper tarball is NOT
         #  compressed (so giving a .tar file).
         #
         #---------------------------------------

         print STDERR "mkinstaller: tarup wrapper directory \"$TmpDirW\"...\n" if $debugging;
         {
            my $wasIn   = getWorkingDirectory(); # Should be same as $here
            my $under   = dirname($TmpDirW);
            my $wrapper = basename($TmpDirW);
            print STDERR "mkinstaller: ...under = \"$under\"\n" if $debugging;
            print STDERR "mkinstaller:     name = \"$wrapper\"\n" if $debugging;
            if ( ! chdir($under)) {
               print STDERR "mkinstaller: error -- can't cd into \"$under\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            {
               print STDERR "mkinstaller: tarup wrapper directory \"$under/$wrapper\"\n" if (1 <= $verbosityLevel);
               my $Tstart = time();
               my $cmd    = "\"$use_tar\" -cf \"$wrapper.tar\" \"$wrapper\"";
               print STDERR "mkinstaller: ...run [$cmd]\n" if $debugging;
               my $status = system "$cmd >$devNull 2>&1";
               if ($status != 0) {
                  print STDERR "mkinstaller:    failed, exit code $status\n" if $debugging;
                  print STDERR "mkinstaller: error -- can't tarup \"$under/$wrapper\"\n";
                  print STDERR "mkinstaller: ...[$cmd], failed returning exit code $status\n";
                  print STDERR "mkinstaller:    was done from in \"$under\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  exit 1;
               }
               print STDERR "mkinstaller:    suceeded\n" if $debugging;
               if ( ! -f "$wrapper.tar") {
                  print STDERR "mkinstaller: error -- didn't tarup \"$under/$wrapper\"\n";
                  print STDERR "mkinstaller: ...[$cmd], failed\n";
                  print STDERR "mkinstaller:    was done from in \"$under\"\n";
                  print STDERR "mkinstaller: ...can't find \"$under/$wrapper.tar\"\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  exit 1;
               }
               my $Tend   = time();
               my $dT     = $Tend - $Tstart;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller: ...done (in <1 second)\n" if (2 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller: ...done (in $dT second)\n" if (2 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller: ...done (in $dT seconds)\n" if (2 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller: ...done\n" if (2 <= $verbosityLevel);
               }
            }
            if ( ! chdir($wasIn)) {
               print STDERR "mkinstaller: error -- can't cd back to \"$wasIn\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
         }
         print STDERR "mkinstaller: ...done\n" if $debugging;
      }

      #----------------------------------------------------------------------------
      #
      #  At this point the tarball (aka. the payload) is ready. It is now time to
      #  generate the installer script. Note that the generated installer script
      #  is a Bourne-Shell script. This is done using a "here document" technique
      #  the output being sent to a temporary textfile. While generation using a
      #  "here" document is typically simple, in this case the process is made
      #  complex due to the conditional generation involved. After the script
      #  generation is completed this temporary textfile and the tarball will be
      #  joined (using cat) to form the actual self-extracting installer script.
      #
      #----------------------------------------------------------------------------

      print STDERR "mkinstaller: form the Bourne-shell script...\n" if $debugging;
      {
         print STDERR "mkinstaller: forming \"$scriptName\" Bourne-shell script\n" if (1 <= $verbosityLevel);
         if ( -f $TmpFile) {
            print STDERR "mkinstaller: ...delete old \"$scriptName\"\n" if (1 <= $verbosityLevel);
            if ( ! unlink $TmpFile) {
               print STDERR "mkinstaller: error -- can't delete existing \"$scriptName\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            if ( -f $TmpFile) {
               print STDERR "mkinstaller: error -- didn't delete existing \"$scriptName\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
         }
         my $Tstart = time();
         print STDERR "mkinstaller: ...create new \"$scriptName\" script\n" if (1 <= $verbosityLevel);
         if ( ! open(SCRIPT,"> $TmpFile")) {
            print STDERR "mkinstaller: error -- can't create/write \"$scriptName\"\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         print SCRIPT "#!/bin/bash\n";
         if ($withNotice ne "") {
            print SCRIPT "#-------------------------------------------------------------------------------\n";
            print SCRIPT "#\n";
            my $i;
            for ($i=0; $i<=$#theNotice; $i+=1) {
               my $lineOfText = $theNotice[$i];
               if ($lineOfText ne "") {
                  print SCRIPT "#   $lineOfText\n";
               }
               else {
                  print SCRIPT "#\n";
               }
            }
            print SCRIPT "#\n";
            print SCRIPT "#-------------------------------------------------------------------------------\n";
         }
         print SCRIPT fixIndentStuff(<<"EOF00");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#   $scriptName
         |#
         |#   Generated by mkinstaller version $mkinstaller_ver_name rev. $mkinstaller_ver_time
         |#
         |#-------------------------------------------------------------------------------
         |
         |commandPathname="\$0"
         |debugging=false
         |here="\`pwd\`"
EOF00
         if ($libDirBasename ne "") {
            print SCRIPT "LibDirBasename=\"$libDirBasename\"\n";
         }
         print SCRIPT fixIndentStuff(<<"EOF01");
         |
         |if [ "X\${DEBUG_$scriptNameU}" != "X" ]
         |then
         |   debugging=true
         |fi
         |
         |GeneratedBy="mkinstaller version $mkinstaller_ver_name rev. $mkinstaller_ver_time"
         |GeneratorVer="$mkinstaller_ver_name"
         |
         |#---------------------------------------
         |#
         |#   This information is supplied at
         |#   run time by the user of the script.
         |#
         |#---------------------------------------
         |
         |keep=false
         |IntermediateName="$intermediateName"
         |MyTmpDir=""
         |JustQuery="false"
         |PREFIX=""
EOF01

         my $bn;
         foreach $bn (sort keys %dirBasenames) {
            my $vn = $bn;
            $vn    =~ tr/a-zA-Z0-9_/_/c;
            print SCRIPT "PREFIX_$vn=\"\"\n";
         }

         if ($debugging) {
            if ($preInstallBasename ne "") {
               print STDERR "mkinstaller: ...has a $preInstallStyle pre-install script (\"$preInstallBasename\")\n" if $debugging;
            }
            else {
               print STDERR "mkinstaller: ...has NO pre-install script\n" if $debugging;
            }
            if ($postInstallBasename ne "") {
               print STDERR "mkinstaller: ...has a $postInstallStyle post-install script (\"$postInstallBasename\")\n" if $debugging;
            }
            else {
               print STDERR "mkinstaller: ...has NO post-install script\n" if $debugging;
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF02");
         |PreInstallScriptName="$preInstallBasename"
         |PreInstallScriptStyle="$preInstallStyle"
         |PostInstallScriptName="$postInstallBasename"
         |PostInstallScriptStyle="$postInstallStyle"
         |TmpDir=""
         |verbosityLevel=0
EOF02

         my $NabiList = $#CXX_abiVerList + 1;
         my $SabiList = "";
         if (1 <= $NabiList) {
            my $i;
            for ($i=0; $i<$NabiList; ++$i) {
               my $versionNum = $CXX_abiVerList[$i];
               if ($i == 0) {
                  $SabiList = $versionNum;
               }
               else {
                  $SabiList = $SabiList." ".$versionNum;
               }
            }
         }
         my $NstdlibcxxList = $#CXX_libcxxVerList + 1;
         my $SstdlibcxxList = "";
         if (1 <= $NstdlibcxxList) {
            my $i;
            for ($i=0; $i<$NstdlibcxxList; ++$i) {
               my $versionNum = $CXX_libcxxVerList[$i];
               if ($i == 0) {
                  $SstdlibcxxList = $versionNum;
               }
               else {
                  $SstdlibcxxList = $SstdlibcxxList." ".$versionNum;
               }
            }
         }
         my $NlibcList = $#CC_libcVerList + 1;
         my $SlibcList = "";
         if (1 <= $NlibcList) {
            my $i;
            for ($i=0; $i<$NlibcList; ++$i) {
               my $versionNum = $CC_libcVerList[$i];
               if ($i == 0) {
                  $SlibcList = $versionNum;
               }
               else {
                  $SlibcList = $SlibcList." ".$versionNum;
               }
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF03");
         |
         |#---------------------------------------
         |#
         |#   This information was derived at
         |#   generation time on the source
         |#   system (where mkinstaller was
         |#   run).
         |#
         |#---------------------------------------
         |
         |Source_os="$OSname"
         |Source_os_version="$OSversion"
         |
         |Source_CC="$CC_name"
         |Source_CC_version="$CC_version"
         |Source_libc_verList="$SlibcList"
         |Source_libc_version="$CC_libcVersion"
         |
         |Source_CXX="$CXX_name"
         |Source_CXX_version="$CXX_version"
         |Source_stdlibcxx_verList="$SstdlibcxxList"
         |Source_stdlibcxx_version="$CXX_libcxxVersion"
         |Source_cxxABI_verList="$SabiList"
         |Source_cxxABI_version="$CXX_abiVersion"
         |
         |#---------------------------------------
         |#
         |#   This information is derived at
         |#   installation time on the target
         |#   system (where the installer was
         |#   run).
         |#
         |#---------------------------------------
         |
         |Target_os=""
         |Target_os_version=""
         |
         |Target_CC=""
         |Target_CC_version=""
         |Target_libc_verList=""
         |Target_libc_version=""
         |
         |Target_CXX=""
         |Target_CXX_version=""
         |Target_stdlibcxx_verList=""
         |Target_stdlibcxx_version=""
         |Target_cxxABI_verList=""
         |Target_cxxABI_version=""
         |
         |#---------------------------------------
         |#
         |#   We will eventually need to know
         |#   where this script is actually
         |#   located.
         |#
         |#---------------------------------------
         |
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: locate this script..." >&2
         |fi
         |bn=\`basename \${commandPathname}\`
         |if [ "X\${commandPathname}" = "X\${bn}" ]
         |then
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      echo "$scriptName: ...\\"\${commandPathname}\\" is simple" >&2
         |   fi
         |   if [ "X\${PATH}" != "X" ]
         |   then
         |      myPath=\`echo \${PATH} | tr ":" " "\`
         |   else
         |      echo "\${scriptName}: PATH is not set" >&2
         |      exit 1
         |   fi
         |   foundIn=
         |   for d in \${myPath}
         |   do
         |      if [ -d "\${d}" ]
         |      then
         |         case "X\${d}" in
         |            X/*)
         |                 ;;
         |            X*)  d="\${here}/\${d}"
         |                 ;;
         |         esac
         |         if [ -f "\${d}/$scriptName" ]
         |         then
         |            if [ -x "\${d}/$scriptName" ]
         |            then
         |               foundIn="\${d}"
         |               commandPathname="\${d}/$scriptName"
         |               break
         |            fi
         |         fi
         |      fi
         |   done
         |   if [ "X\${foundIn}" = "X" ]
         |   then
         |      echo "$scriptName: can't locate this script" >&2
         |      exit 1
         |   fi
         |else
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      echo "$scriptName: ...\\"\${commandPathname}\\" is NOT simple" >&2
         |   fi
         |   dn=\`dirname \${commandPathname}\`
         |   bn=\`basename \${commandPathname}\`
         |   case "X\${dn}" in
         |      X/*)
         |           if [ "X\${debugging}" != "Xfalse" ]
         |           then
         |              echo "$scriptName:    \\"\${commandPathname}\\" is absolute" >&2
         |           fi
         |           ;;
         |      X*)  if [ "X\${debugging}" != "Xfalse" ]
         |           then
         |              echo "$scriptName:    \\"\${commandPathname}\\" is releative" >&2
         |           fi
         |           commandPathname="\`pwd\`/\${commandPathname}"
         |           if [ "X\${debugging}" != "Xfalse" ]
         |           then
         |              echo "$scriptName:    ...consider \\"\${commandPathname}\\" " >&2
         |           fi
         |           dn=\`dirname "\${commandPathname}"\`
         |           bn=\`basename "\${commandPathname}"\`
         |           if [ "X\${debugging}" != "Xfalse" ]
         |           then
         |              echo "$scriptName:       is in \\"\${dn}\\" " >&2
         |              echo "$scriptName:       is called \\"\${bn}\\" " >&2
         |           fi
         |           ;;
         |   esac
         |   foundIn="\${dn}"
         |   commandPathname="\${dn}/\${bn}"
         |fi
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: ...in \\"\${foundIn}\\" " >&2
         |   echo "$scriptName:    as \\"\${commandPathname}\\" " >&2
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Deal with TMPDIR...
         |#
         |#  Note: It would be desirable to replace the next 183 lines with a call
         |#        to the findTempDir Perl script. However that does introduce an
         |#        outside dependency which we'd like to avoid in this script.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: identify temp directory..." >&2
         |fi
         |
         |if [ "X\${$SCRIPTNAME_TMPDIR}" != "X" ]
         |then
         |   if [ -d "\${$SCRIPTNAME_TMPDIR}" ]
         |   then
         |      if [ -w "\${$SCRIPTNAME_TMPDIR}" ]
         |      then
         |         TMPDIR="\${$SCRIPTNAME_TMPDIR}" ; export TMPDIR
         |         if [ "X\${debugging}" != "Xfalse" ]
         |         then
         |            echo "$scriptName: ...from $SCRIPTNAME_TMPDIR" >&2
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was specified then
         |#  make sure its valid...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" != "X" ]
         |then
         |   if [ -d "\${TMPDIR}" ]
         |   then
         |      if [ -w "\${TMPDIR}" ]
         |      then
         |         true
         |         if [ "X\${debugging}" != "Xfalse" ]
         |         then
         |            echo "$scriptName: ...from TMPDIR" >&2
         |         fi
         |      else
         |         TMPDIR="" ; export TMPDIR
         |      fi
         |   else
         |      TMPDIR="" ; export TMPDIR
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using TMP if it is defined and
         |#  is valid...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   if [ "X\${TMP}" != "X" ]
         |   then
         |      tryDir="\${TMP}"
         |      if [ -d "\${tryDir}" ]
         |      then
         |         if [ -w "\${tryDir}" ]
         |         then
         |            TMPDIR="\${tryDir}" ; export TMPDIR
         |            if [ "X\${debugging}" != "Xfalse" ]
         |            then
         |               echo "$scriptName: ...from TMP" >&2
         |            fi
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using TEMP if it is defined and
         |#  is valid...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   if [ "X\${TEMP}" != "X" ]
         |   then
         |      tryDir="\${TEMP}"
         |      if [ -d "\${tryDir}" ]
         |      then
         |         if [ -w "\${tryDir}" ]
         |         then
         |            TMPDIR="\${tryDir}" ; export TMPDIR
         |            if [ "X\${debugging}" != "Xfalse" ]
         |            then
         |               echo "$scriptName: ...from TEMP" >&2
         |            fi
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using tmp in the user's home
         |#  directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   if [ "X\${HOME}" != "X" ]
         |   then
         |      tryDir="\${HOME}/tmp"
         |      if [ -d "\${tryDir}" ]
         |      then
         |         if [ -w "\${tryDir}" ]
         |         then
         |            TMPDIR="\${tryDir}" ; export TMPDIR
         |            if [ "X\${debugging}" != "Xfalse" ]
         |            then
         |               echo "$scriptName: ...using HOME" >&2
         |            fi
         |         fi
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using /tmp directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   tryDir="/tmp"
         |   if [ -d "\${tryDir}" ]
         |   then
         |      if [ -w "\${tryDir}" ]
         |      then
         |         TMPDIR="\${tryDir}" ; export TMPDIR
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using /var/tmp directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   tryDir="/var/tmp"
         |   if [ -d "\${tryDir}" ]
         |   then
         |      if [ -w "\${tryDir}" ]
         |      then
         |         TMPDIR="\${tryDir}" ; export TMPDIR
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  If TMPDIR was NOT specified then
         |#  try using the current directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   tryDir="."
         |   if [ -d "\${tryDir}" ]
         |   then
         |      if [ -w "\${tryDir}" ]
         |      then
         |         TMPDIR="\${tryDir}" ; export TMPDIR
         |      fi
         |   fi
         |fi
         |
         |#---------------------------------------
         |#
         |#  Adjust the result so that it is an
         |#  absolute pathname...
         |#
         |#---------------------------------------
         |
         |if [ "X\${TMPDIR}" = "X" ]
         |then
         |   echo "$scriptName: can't decide on a location for a temp directory" >&2
         |   echo "$scriptName: ...set TMPDIR or $SCRIPTNAME_TMPDIR" >&2
         |   exit 1
         |else
         |   case "\${TMPDIR}" in
         |      /*)
         |          ;;
         |      *)
         |          TMPDIR="\`pwd\`/\${TMPDIR}" ; export TMPDIR
         |          ;;
         |   esac
         |fi
         |
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: ...as \\"\${TMPDIR}\\" " >&2
         |fi
         |
         |MyTmpDir="\${TMPDIR}/$scriptName.\$\$.tmp"
         |
         |#---------------------------------------
         |#
         |#  We'll do everything from here on in
         |#  a temporary directory...
         |#
         |#---------------------------------------
         |
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: create \\"\${MyTmpDir}\\" ">&2
         |fi
         |if [ -d "\${MyTmpDir}" ]
         |then
         |   echo "$scriptName: \\"\${MyTmpDir}\\" already exists" >&2
         |   exit 1
         |fi
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: ...run [mkdir \\"\${MyTmpDir}\\" ]" >&2
         |fi
         |mkdir "\${MyTmpDir}" >/dev/null 2>&1
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: can't create directory \\"\${MyTmpDir}\\" " >&2
         |   exit 1
         |fi
         |
         |cd "\${MyTmpDir}"
         |status=\$?
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: can't cd to directory \\"\${MyTmpDir}\\" " >&2
         |   exit 1
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Command line processing...
         |#
         |#-------------------------------------------------------------------------------
         |
         |while [ \$# != 0 ]
         |do
         |   opt="\$1"
         |   if [ "X\$1" != "X" ]
         |   then
         |      case "\$1" in
         |         #---------------------------------------
         |         #
         |         #  Standard options...
         |         #
         |         #---------------------------------------
         |
EOF03
         if ($withNotice ne "") {
            print SCRIPT fixIndentStuff(<<"EOF04");
         |         -copyright|--copyright)
         |                            echo
EOF04
            my $i;
            for ($i=0; $i<=$#theNotice; $i+=1) {
               my $lineOfText = $theNotice[$i];
               $lineOfText    =~ s/\\/\\\\/g;
               $lineOfText    =~ s/"/\\"/g;
               $lineOfText    =~ s/\$/\\\$/g;
#              $lineOfText    =~ s/@/\\@/g;
               print SCRIPT "                            echo \"$lineOfText\"\n";
            }
            print SCRIPT fixIndentStuff(<<"EOF05");
         |                            echo
         |                            exit 0
         |                            ;;
EOF05
         }
         print SCRIPT fixIndentStuff(<<"EOF06");
         |         -help|--help)
         |                            echo
         |                            echo "$titleLine"
         |                            echo
         |                            echo "NAME"
         |                            echo "    $scriptName -- Self-extracting installer script$ForProject."
         |                            echo
         |                            echo "USAGE"
EOF06
         if ($withNotice ne "") {
            print SCRIPT "                            echo \"    $scriptName --copyright\"\n";
         }
         print SCRIPT fixIndentStuff(<<"EOF07");
         |                            echo "    $scriptName --help"
EOF07
         if ($ProjectVer ne "") {
         print SCRIPT fixIndentStuff(<<"EOF08");
         |                            echo "    $scriptName --vernum"
EOF08
         }
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
         print SCRIPT fixIndentStuff(<<"EOF09");
         |                            echo "    $scriptName --version"
EOF09
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF10");
         |                            echo
EOF10
         my $exampleLine = $scriptName." [--keep] [--prefix=<pathname>]";
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               $exampleLine = $exampleLine." [--prefix-$bn=<pathname>]";
            }
         }
         $exampleLine    = $exampleLine." [-v[erbose][<digit>]]";
         print SCRIPT fixIndentStuff(<<"EOF11");
         |                            echo "    $exampleLine"
         |                            echo
         |                            echo "DESCRIPTION"
         |                            echo "    This script is a \\"self-extracting installer\\" script implemented as"
         |                            echo "    a bash script and carries a tarball as a payload. This generated"
         |                            echo "    installer script supports a number of options for specifying where"
         |                            echo "    the various directories are to be installed (prefix directory pathnames)."
         |                            echo
         |                            echo "    The installation process:"
         |                            echo
         |                            echo "       1) Determination of a suitable temp directory. Much of the work"
         |                            echo "          done by the $scriptName script is done in a temp directory."
         |                            echo "          Once an appropriate temporary directory has been arranged"
         |                            echo "          the $scriptName script will cd to this directory and work from"
         |                            echo "          there for much of the remaining work."
         |                            echo "       2) Using the command line options the this installer script will"
         |                            echo "          determine proper installation PREFIX directories for each of"
         |                            echo "          the directories to be installed. Note that each of the PREFIX"
         |                            echo "          directories will be created if necessary."
         |                            echo "       3) The \\"wrapper\\" tarball is extracted from this installer script"
         |                            echo "          landing in the temp directory."
         |                            echo "       4) The wrapper tarball is unwrapped using tar to form the \\"wrapper\\" "
         |                            echo "          directory in the temp directory. Note that this wrapper directory"
         |                            echo "          contains the individual tarballs of the directories to be installed."
         |                            echo "       5) For each of individual tarballs the script will cd to the appropriate"
         |                            echo "          prefix firectory and unwraps the individual tarball (found in the"
         |                            echo "          wrapper directory under the temp directory). This is the actual"
         |                            echo "          \\"install\\" step."
         |                            echo "       6) Cleanup if the --keep wasn't used."
         |                            echo
         |                            echo "OPTIONS"
         |                            echo "    \\"$scriptName\\" supports the following options:"
         |                            echo
         |                            echo "        --help"
         |                            echo
         |                            echo "            Output this man page to <stdout> and quit."
EOF11
         if ($ProjectVer ne "") {
            print SCRIPT fixIndentStuff(<<"EOF12");
         |                            echo
         |                            echo "        --vernum"
         |                            echo
         |                            echo "            Output version number of the payload to <stdout> and quit."
EOF12
         }
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
               print SCRIPT fixIndentStuff(<<"EOF13");
         |                            echo
         |                            echo "        --version"
         |                            echo
         |                            echo "            Output project name and version number of the payload to <stdout>"
         |                            echo "            and quit."
EOF13
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF14");
         |                            echo
         |                            echo "        -k"
         |                            echo "        --keep"
         |                            echo
         |                            echo "            Don't cleanup intermediate temporary files and directories that"
         |                            echo "            are produced during the extraction and installation process."
         |                            echo
         |                            echo "        --prefix=<pathname>"
         |                            echo
         |                            echo "            The pathname of the single directory where all of the payload"
         |                            echo "            directories are to be placed."
EOF14
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               print SCRIPT fixIndentStuff(<<"EOF15");
         |                            echo
         |                            echo "        --prefix-$bn=<pathname>"
         |                            echo
         |                            echo "            The pathname of the directory where the \\"$bn\\" payload directory"
         |                            echo "            is to be placed. Note that if this option is not specified then the"
         |                            echo "            overall --prefix=<pathname> should be used."
EOF15
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF16");
         |                            echo
         |                            echo "        -q"
         |                            echo "        --query"
         |                            echo
         |                            echo "            Don't actually perform the installation. Instead only harvest the"
         |                            echo "            target system information such as OS name and version number, C"
         |                            echo "            and C++ compiler version numbers, C library version number, The"
         |                            echo "            Standard C++ library and C++ ABI version numbers."
         |                            echo
         |                            echo "        -v[erbose][<digit>]"
         |                            echo
         |                            echo "            Operate in a verbose mode."
         |                            echo
         |                            echo "            Repeating this option increases the amount of output produced."
         |                            echo "            Note that the option may end with an optional digit which"
         |                            echo "            indicates a repetition count. Thus the option:"
         |                            echo
         |                            echo "               -v3"
         |                            echo
         |                            echo "            is equavalent to:"
         |                            echo
         |                            echo "               -v -v -v"
         |                            echo
         |                            echo "    Note that if no prefix is specified then this script will prompt for one."
         |                            echo
         |                            echo "RETURNS"
         |                            echo "    \\"$scriptName\\" returns the standard exit codes:"
         |                            echo
         |                            echo "       0 -- success"
         |                            echo "       1 -- failure"
         |                            echo
         |                            echo "ENVIRONMENT"
         |                            echo "    \\"$scriptName\\" refers to the following environment variables:"
         |                            echo
         |                            echo "        DEBUG_$scriptNameU"
         |                            echo
         |                            echo "            Generate extra output which is only usefull when debugging the"
         |                            echo "            \\"$scriptName\\" script itself. Note that at this time this"
         |                            echo "            environment variable is ignored."
         |                            echo
         |                            echo "        $SCRIPTNAME_TMPDIR"
         |                            echo
         |                            echo "            Consider this pathname before considering TMPDIR (see"
         |                            echo "            step (0) in the NOTES section below)."
         |                            echo
         |                            echo "INPLEMENTATION"
         |                            echo "    \\"$scriptName\\" is implemented as a bash script."
         |                            echo
         |                            echo "SEE ALSO"
         |                            echo "    mkinstaller(1x), sed(1), sh(1), tar(1)"
         |                            echo
         |                            echo "NOTES"
         |                            echo "    Both the sed and tar utilities are required."
EOF16
         if ($OSname ne "") {
            print SCRIPT "                            echo\n";
            print SCRIPT "                            echo \"    This installer script was built on \\\"$OSname\\\" \"\n";
         }
         if ($CC_name ne "") {
            print SCRIPT "                            echo\n";
            print SCRIPT "                            echo \"    The C compiler \\\"$CC_name\\\" was used to build the payload.\"\n";
         }
         if ($CXX_name ne "") {
            print SCRIPT "                            echo\n";
            print SCRIPT "                            echo \"    The C++ compiler \\\"$CXX_name\\\" was used to build the payload.\"\n";
         }
         if ($FORTRANname ne "") {
            print SCRIPT "                            echo\n";
            print SCRIPT "                            echo \"    The FORTRAN compiler \\\"$FORTRANname\\\" was used to build the payload.\"\n";
         }
         print SCRIPT fixIndentStuff(<<"EOF17");
         |                            echo
         |                            echo "    The directory where temporary files are to be placed is determined"
         |                            echo "    as follows:"
         |                            echo
         |                            echo "        0) If $SCRIPTNAME_TMPDIR is defined and is not empty then"
         |                            echo "           consider its value as a directory pathname. If this pathname"
         |                            echo "           exists and is a directory and is writable then temporary"
         |                            echo "           files will be placed in this directory. Otherwise..."
         |                            echo "        1) If TMPDIR is defined and is not empty then consider its"
         |                            echo "           value as a directory pathname. If this pathname exists"
         |                            echo "           and is a directory and is writable then temporary files"
         |                            echo "           will be placed in this directory. Otherwise..."
         |                            echo "        2) If TMP is defined and is not empty then consider its"
         |                            echo "           value as a directory pathname. If this pathname exists"
         |                            echo "           and is a directory and is writable then temporary files"
         |                            echo "           will be placed in this directory. Otherwise..."
         |                            echo "        3) If TEMP is defined and is not empty then consider its"
         |                            echo "           value as a directory pathname. If this pathname exists"
         |                            echo "           and is a directory and is writable then temporary files"
         |                            echo "           will be placed in this directory. Otherwise..."
         |                            echo "        4) If the user's home directory can be determined and if"
         |                            echo "           this home directory contains a subdirectory named tmp"
         |                            echo "           that is itself writable then temporary files will be"
         |                            echo "           placed in this directory. Otherwise..."
         |                            echo "        5) If \\"C:<userProfile>\\\\AppData\\\\Local\\\\temp\\" exists and"
         |                            echo "           is a writable directory then temporary files will be"
         |                            echo "           placed in this directory. Otherwise..."
         |                            echo "        6) If \\"/tmp\\" exists and is writable then temporary files"
         |                            echo "           will be placed in this directory. Otherwise..."
         |                            echo "        7) If \\"/var/tmp\\" exists and is writable then temporary files"
         |                            echo "           will be placed in this directory. Otherwise..."
         |                            echo "        8) If \\"C:\\\\Temp\\" exists and is writable then temporary files"
         |                            echo "           will be placed in this directory. Otherwise..."
         |                            echo "        9) If \\"C:\\\\Windows\\\\Temp\\" exists and is writable then temporary"
         |                            echo "           files will be placed in this directory. Otherwise..."
         |                            echo "       10) If the current directory is writable then temporary files"
         |                            echo "           will be placed in the current directory. Otherwise..."
         |                            echo "       11) A fatal error message will be sent to <stderr> and"
         |                            echo "           the program will exit with a non-zero exit code."
         |                            echo
         |                            echo "    Note that 5, 8, and 9 are only applicable on Windows-like hosts."
         |                            echo
         |                            echo "AUTHOR"
         |                            echo "    mkinstaller version $mkinstaller_ver_name rev. $mkinstaller_ver_time"
EOF17
         if ($Contact ne "") {
            print SCRIPT "                            echo\n";
            print SCRIPT "                            echo \"CONTACT\"\n";
            if ($ProjectName ne "") {
               print SCRIPT "                            echo \"    Please contact the $ProjectName team at:\"\n";
            }
            else {
               print SCRIPT "                            echo \"    Please contact:\"\n";
            }
            print SCRIPT "                            echo\n";
            print SCRIPT "                            echo \"        $Contact\"\n";
         }
         print SCRIPT fixIndentStuff(<<"EOF18");
         |                            echo
         |                            exit 0
         |                            ;;
EOF18
         if ($ProjectVer ne "") {
            print SCRIPT "\n";
            print SCRIPT "         --vernum)          echo $ProjectVer\n";
            print SCRIPT "                            exit 0\n";
            print SCRIPT "                            ;;\n";
            if ($ProjectName ne "") {
               print SCRIPT "\n";
               print SCRIPT "         --version)         echo $ProjectName: version $ProjectVer\n";
               print SCRIPT "                            exit 0\n";
               print SCRIPT "                            ;;\n";
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF19");
         |
         |         #---------------------------------------
         |         #
         |         #  Non-standard options...
         |         #
         |         #---------------------------------------
         |
         |         -k|--keep)         keep=true
         |                            ;;
         |
         |         --prefix=*)        given="\$1"
         |                            stmp=\`echo \${given} | sed -e 's/^--prefix=\\(.*\\)\$/\\1/'\`
         |                            given="\${stmp}"
         |                            case "X\${given}" in
         |                               X\\"*\\") given=`echo \${given} | sed 's/^"\\(.*\\)"\$/\\1/'`
         |                                       echo "$scriptName: stripped enclosing double-quotes from argument to --prefix option" >&2
         |                                       ;;
         |                               X\\'*\\') given=`echo \${given} | sed 's/^.\\(.*\\).\$/\\1/'`
         |                                       echo "$scriptName: stripped enclosing single-quotes from argument to --prefix option" >&2
         |                                       ;;
         |                               X*)
         |                                       ;;
         |                            esac
         |                            if [ "X\${given}" = "X" ]
         |                            then
         |                               echo "$scriptName: missing or zero-length argument to --prefix option" >&2
         |                               exit 1
         |                            fi
         |                            PREFIX="\${given}"
         |                            ;;
EOF19
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT fixIndentStuff(<<"EOF20");
         |
         |         --prefix-$bn=*)
         |                            given="\$1"
         |                            stmp=\`echo \${given} | sed -e 's/^--prefix-$bn=\\(.*\\)\$/\\1/'\`
         |                            given="\${stmp}"
         |                            case "X\${given}" in
         |                               X\\"*\\") given=`echo \${given} | sed 's/^"\\(.*\\)"\$/\\1/'`
         |                                       echo "$scriptName: stripped enclosing double-quotes from argument to --prefix-$bn option" >&2
         |                                       ;;
         |                               X\\'*\\') given=`echo \${given} | sed 's/^.\\(.*\\).\$/\\1/'`
         |                                       echo "$scriptName: stripped enclosing single-quotes from argument to --prefix-$bn option" >&2
         |                                       ;;
         |                               X*)
         |                                       ;;
         |                            esac
         |                            if [ "X\${given}" = "X" ]
         |                            then
         |                               echo "$scriptName: missing or zero-length argument to --prefix-$bn option" >&2
         |                               exit 1
         |                            fi
         |                            PREFIX_$vn="\${given}"
         |                            if [ "X\${IntermediateName}" != "X" ]
         |                            then
         |                               echo "$scriptName: version directory name(=\\"\${IntermediateName}\\") suppressed by --prefix-$bn option" >&2
         |                               IntermediateName=
         |                            fi
         |                            ;;
EOF20
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF21");
         |
         |         -q|--query)        JustQuery=true
         |                            ;;
         |
         |         #---------------------------------------
         |         #
         |         #  "Semi-standard" options...
         |         #
         |         #---------------------------------------
         |
         |         -v)                verbosityLevel=\`expr \${verbosityLevel} + 1\`
         |                            ;;
         |
         |         -v0)               verbosityLevel=0
         |                            ;;
         |
         |         -v[0-9])           given=\$1
         |                            itmp=\`echo \${given} | sed -e 's/^-v\\([0-9]\\)\$/\\1/'\`
         |                            verbosityLevel=\`expr \${verbosityLevel} + \${itmp}\`
         |                            ;;
         |
         |         --verbose)         verbosityLevel=\`expr \${verbosityLevel} + 1\`
         |                            ;;
         |
         |         --verbose0)        verbosityLevel=0
         |                            ;;
         |
         |         --verbose[0-9])    given="\$1"
         |                            itmp=\`echo \${given} | sed -e 's/^--verbose\\([0-9]\\)\$/\\1/'\`
         |                            verbosityLevel=\`expr \${verbosityLevel} + \${itmp}\`
         |                            ;;
         |
         |         #---------------------------------------
         |         #
         |         #  Unknown options...
         |         #
         |         #---------------------------------------
         |
         |         -*)                echo "$scriptName: unknown option \\"\$opt\\" " >&2
         |                            echo "$scriptName: ...if \\"\$opt\\" is meant to be a pathname try using \\'./\$opt\\' " >&2
         |                            exit 1
         |                            ;;
         |
         |         #---------------------------------------
         |         #
         |         #  Parameters...
         |         #
         |         #---------------------------------------
         |
         |         *)                 echo "$scriptName: unexpected \\"\$1\\" " >&2
         |                            exit 1
         |                            ;;
         |
         |      esac
         |   else
         |      echo "$scriptName: zero-length parameter" >&2
         |      exit 1
         |   fi
         |   shift
         |done
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  We'll be passing the verbosity level to pre- and post-install scripts...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   if [ 1 -lt \${verbosityLevel} ]
         |   then
         |      Vflag=" -v\${verbosityLevel}"
         |   else
         |      Vflag=" -v"
         |   fi
         |else
         |   Vflag=
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  A reminder that we're doing this all from a temporary directory.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: running \\"\${commandPathname}\\" " >&2
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: working in \\"\${amNowIn}\\" " >&2
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      /bin/ls -alF >&2
         |   fi
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Dealing with PREFIX...
         |#
         |#  The overall PREFIX is only needed if one or more of the individual PREFIX...
         |#  pathnames wasn't specified using the appropriate options. In this case we'll
         |#  have to ask for the overall PREFIX if it wasn't supplied then use it to set
         |#  each of the PREFIX... pathnames that wern't supplied.
         |#
         |#  If an intermediate or version directory name has been specified, it will
         |#  be appended under the given PREFIX directory.
         |#
         |#-------------------------------------------------------------------------------
         |
         |haveAll=true
EOF21
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT fixIndentStuff(<<"EOF22");
         |if [ "X\${PREFIX_$vn}" = "X" ]
         |then
         |   haveAll=false
         |fi
EOF22
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF23");
         |
         |if [ "X\${haveAll}" != Xtrue ]
         |then
         |   #---------------------------------------
         |   #
         |   #  Ask for PREFIX if one wasn't given...
         |   #
         |   #---------------------------------------
         |
         |   while [ "X\${PREFIX}" = "X" ]
         |   do
         |      [ "\${PREFIX}" != "" ] || read -e -p "$scriptName: Enter the PREFIX path: " PREFIX
         |      if [ "X\${PREFIX}" = "X" ]
         |      then
         |         echo "$scriptName: can't have empty PREFIX, try again"
         |      else
         |         case "X\${PREFIX}" in
         |            X\\"*\\") PREFIX=`echo \${PREFIX} | sed 's/^"\\(.*\\)"\$/\\1/'`
         |                    echo "$scriptName: stripped surrounding double-quotes" >&2
         |                    if [ "X\${PREFIX}" = "X" ]
         |                    then
         |                       echo "$scriptName: ...leaving an empty PREFIX, try again" >&2
         |                    fi
         |                    ;;
         |            X\\'*\\') PREFIX=`echo \${PREFIX} | sed 's/^.\\(.*\\).\$/\\1/'`
         |                    echo "$scriptName: ...stripped surrounding single-quotes" >&2
         |                    if [ "X\${PREFIX}" = "X" ]
         |                    then
         |                       echo "$scriptName: leaving an empty PREFIX, try again" >&2
         |                    fi
         |                    ;;
         |            X*)
         |                    ;;
         |         esac
         |      fi
         |   done
         |
         |   #---------------------------------------
         |   #
         |   #  Force PREFIX to be absolute.
         |   #
         |   #---------------------------------------
         |
         |   case "\${PREFIX}" in
         |      /*)
         |          ;;
         |      *)
         |          PREFIX=\"\${here}/\${PREFIX}\"
         |          ;;
         |   esac
EOF23
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT fixIndentStuff(<<"EOF24");
         |
         |   #---------------------------------------
         |   #
         |   #  Set PREFIX_$vn from PREFIX if we must.
         |   #
         |   #---------------------------------------
         |
         |   if [ "X\${PREFIX_$vn}" = "X" ]
         |   then
         |      PREFIX_$vn="\${PREFIX}"
         |   fi
EOF24
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF25");
         |fi
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: install under:" >&2
         |   echo "$scriptName: ...PREFIX=\\"\${PREFIX}\\" " >&2
EOF25
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT fixIndentStuff(<<"EOF26");
         |   if [ "X\${PREFIX_$vn}" != "X\${PREFIX}" ]
         |   then
         |      echo "$scriptName: ...PREFIX_$vn=\\"\${PREFIX_$vn}\\" " >&2
         |   fi
EOF26
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF27");
         |fi
         |
         |#---------------------------------------
         |#
         |#  Append a intermediate directory name
         |#  to the installation PREFIX directories
         |#  if appropriate...
         |#
         |#---------------------------------------
         |
         |if [ "X\${IntermediateName}" != "X" ]
         |then
         |   PREFIX=\"\${PREFIX}/\${IntermediateName}\"
EOF27
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT fixIndentStuff(<<"EOF28");
         |   PREFIX_$vn=\"\${PREFIX_$vn}/\${IntermediateName}\"
EOF28
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF29");
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Collect and report on information about the target system...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${Target_os}" = "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  The OS type and version...
         |   #
         |   #---------------------------------------
         |   cmd="uname -s"
         |   gives=`\${cmd} 2>konftest.log`
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: can't identify system type" >&2
         |      echo "$scriptName: ...[\${cmd} 2>konftest.log] returned exit code \${status}" >&2
         |      if [ -f "konftest.log" ]
         |      then
         |         echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |         cat konftest.log >&2
         |         echo "$scriptName\]" >&2
         |      fi
         |      Target_os=""
         |      Target_os_version=""
         |   else
         |      if [ "X\${gives}" = "X" ]
         |      then
         |         echo "$scriptName: can't identify system type" >&2
         |         echo "$scriptName: ...[\${cmd} 2>konftest.log] returned an empty string" >&2
         |         if [ -f "konftest.log" ]
         |         then
         |            echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |            cat konftest.log >&2
         |            echo "$scriptName\[" >&2
         |         fi
         |         Target_os=\"\"
         |         Target_os_version=\"\"
         |      else
         |         Target_os=\"\${gives}\"
         |         cmd="uname -r"
         |         gives=`\${cmd} 2>konftest.log`
         |         status=\$?
         |         if [ "X\${status}" != "X0" ]
         |         then
         |            echo "$scriptName: can't identify system type" >&2
         |            echo "$scriptName: ...[\${cmd} 2>konftest.log] returned exit code \${status}" >&2
         |            if [ -f "konftest.log" ]
         |            then
         |               echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |               cat konftest.log >&2
         |               echo "$scriptName\]" >&2
         |            fi
         |            Target_os_version=""
         |         else
         |            gotVersionNum=`echo "\${gives}" | sed 's/^[ ]*\\([0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^[0-9].*\\)\$/\\1/'`
         |            Target_os_version=\"\${gotVersionNum}\"
         |         fi
         |      fi
         |   fi
         |   rm -f "konftest.out"
         |   rm -f "konftest.log"
         |fi
         |
         |if [ "X\${Target_CC}" = "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  The C compiler and version...
         |   #
         |   #---------------------------------------
         |   Target_CC="\${Source_CC}"
         |   if [ "X\${Target_CC}" != "X" ]
         |   then
         |      bn=`basename \${Target_CC}`
         |      if [ "X\${bn}" != "X" ]
         |      then
         |         if [ "\${bn}" = "gcc" ]
         |         then
         |            cmd="gcc --version"
         |         elif [ "\${bn}" = "icc" ]
         |         then
         |            cmd="icc --version"
         |         elif [ "\${bn}" = "clang" ]
         |         then
         |            cmd="clang --version"
         |         elif [ "\${bn}" = "pgcc" ]
         |         then
         |            cmd="pgcc -V"
         |         else
         |            cmd=
         |         fi
         |         if [ "X\${cmd}" != "X" ]
         |         then
         |            gives=`\${cmd} 2>konftest.log`
         |            status=\$?
         |            if [ "X\${status}" = "X0" ]
         |            then
         |               gotVersionNum=`echo "\${gives}" | head -1 | sed 's/^.*[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^.0-9].*\\)*\$/\\1/'`
         |               if [ "X\${gotVersionNum}" = "X\${gives}" ]
         |               then
         |                  Target_CC_version="failed to match pattern"
         |               else
         |                  Target_CC_version="\${gotVersionNum}"
         |               fi
         |            else
         |               echo "$scriptName: ...[\${cmd} 2>konftest.log] returned exit code \${status}" >&2
         |               if [ -f "konftest.log" ]
         |               then
         |                  echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                  cat konftest.log >&2
         |                  echo "$scriptName\]" >&2
         |               fi
         |               Target_CC_version="\${cmd} failed"
         |            fi
         |            rm -f konftest.log
         |         else
         |            echo "$scriptName: can't identify C compiler version" >&2
         |            echo "$scriptName: ...don't know how to query \"\${bn}\" for version number" >&2
         |            Target_CC_version=""
         |         fi
         |      else
         |         Target_CC_version=""
         |      fi
         |   else
         |      Target_CC_version=""
         |   fi
         |fi
         |
         |if [ "X\${Target_CXX}" = "X" ]
         |then
         |   #---------------------------------------
         |   #
         |   #  The C++ compiler and version...
         |   #
         |   #---------------------------------------
         |   Target_CXX="\${Source_CXX}"
         |   if [ "X\${Target_CXX}" != "X" ]
         |   then
         |      bn=`basename \${Target_CXX}`
         |      if [ "X\${bn}" != "X" ]
         |      then
         |         if [ "\${bn}" = "g++" ]
         |         then
         |            cmd="g++ --version"
         |         elif [ "\${bn}" = "icpc" ]
         |         then
         |            cmd="icpc --version"
         |         elif [ "\${bn}" = "pgCC" ]
         |         then
         |            cmd="pgCC -V"
         |         else
         |            cmd=
         |         fi
         |         if [ "X\${cmd}" != "X" ]
         |         then
         |            gives=`\${cmd} 2>konftest.log`
         |            status=\$?
         |            if [ "X\${status}" = "X0" ]
         |            then
         |               gotVersionNum=`echo "\${gives}" | head -1 | sed 's/^.*[ ][ ]*\\([0-9][0-9]*\\.[0-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)\\([^.0-9].*\\)*\$/\\1/'`
         |               if [ "X\${gotVersionNum}" = "X\${gives}" ]
         |               then
         |                  Target_CXX_version="failed to match pattern"
         |               else
         |                  Target_CXX_version="\${gotVersionNum}"
         |               fi
         |            else
         |               echo "$scriptName: ...[\${cmd} 2>konftest.log] returned exit code \${status}" >&2
         |               if [ -f "konftest.log" ]
         |               then
         |                  echo "$scriptName\[    \\"konftest.log\\" contains:" >&2
         |                  cat konftest.log >&2
         |                  echo "$scriptName\]" >&2
         |               fi
         |               Target_CXX_version="\${cmd} failed"
         |            fi
         |            rm -f konftest.log
         |         else
         |            echo "$scriptName: can't identify C compiler version" >&2
         |            echo "$scriptName: ...don't know how to query \"\${bn}\" for version number" >&2
         |            Target_CXX_version=""
         |         fi
         |      else
         |         Target_CXX_version=""
         |      fi
         |   else
         |      Target_CXX_version=""
         |   fi
         |fi
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: supplied info:" >&2
         |   echo "$scriptName: ...Source_os                = [\${Source_os}]" >&2
         |   echo "$scriptName:    Source_os_version        = [\${Source_os_version}]" >&2
         |   echo "$scriptName:    Source_CC                = [\${Source_CC}]" >&2
         |   echo "$scriptName:    Source_CC_version        = [\${Source_CC_version}]" >&2
         |   echo "$scriptName:    Source_libc_verList      = [\${Source_libc_verList}]" >&2
         |   echo "$scriptName:    Source_libc_version      = [\${Source_libc_version}]" >&2
         |   echo "$scriptName:    Source_CXX               = [\${Source_CXX}]" >&2
         |   echo "$scriptName:    Source_CXX_version       = [\${Source_CXX_version}]" >&2
         |   echo "$scriptName:    Source_stdlibcxx_verList = [\${Source_stdlibcxx_verList}]" >&2
         |   echo "$scriptName:    Source_stdlibcxx_version = [\${Source_stdlibcxx_version}]" >&2
         |   echo "$scriptName:    Source_cxxABI_verList    = [\${Source_cxxABI_verList}]" >&2
         |   echo "$scriptName:    Source_cxxABI_version    = [\${Source_cxxABI_version}]" >&2
         |   echo "$scriptName: derived info:" >&2
         |   echo "$scriptName: ...Target_os                = [\${Target_os}]" >&2
         |   echo "$scriptName:    Target_os_version        = [\${Target_os_version}]" >&2
         |   echo "$scriptName:    Target_CC                = [\${Target_CC}]" >&2
         |   echo "$scriptName:    Target_CC_version        = [\${Target_CC_version}]" >&2
         |   echo "$scriptName:    Target_libc_verList      = [\${Target_libc_verList}]" >&2
         |   echo "$scriptName:    Target_libc_version      = [\${Target_libc_version}]" >&2
         |   echo "$scriptName:    Target_CXX               = [\${Target_CXX}]" >&2
         |   echo "$scriptName:    Target_CXX_version       = [\${Target_CXX_version}]" >&2
         |   echo "$scriptName:    Target_stdlibcxx_verList = [\${Target_stdlibcxx_verList}]" >&2
         |   echo "$scriptName:    Target_stdlibcxx_version = [\${Target_stdlibcxx_version}]" >&2
         |   echo "$scriptName:    Target_cxxABI_verList    = [\${Target_cxxABI_verList}]" >&2
         |   echo "$scriptName:    Target_cxxABI_version    = [\${Target_cxxABI_version}]" >&2
         |fi
         |
         |if [ "X\${JustQuery}" != "Xfalse" ]
         |then
         |   exit 0
         |fi
         |
         |#---------------------------------------
         |#
         |#  Create the (adjusted) installation
         |#  PREFIX directories if necessary...
         |#
         |#---------------------------------------
         |
         |if [ "X\${PREFIX}" != "X" ]
         |then
         |   if [ ! -d "\${PREFIX}" ]
         |   then
         |      if [ 1 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: creating directory \\"\${PREFIX}\\" " >&2
         |      fi
         |      mkdir "\${PREFIX}" >/dev/null 2>&1
         |      status=\$?
         |      if [ "X\${status}" != "X0" ]
         |      then
         |         echo "$scriptName: can't create directory \\"\${PREFIX}\\" " >&2
         |         echo "$scriptName: ...[mkdir \\"\${PREFIX}\\"] returned exit code \${status}" >&2
         |         exit 1
         |      fi
         |      if [ ! -d "\${PREFIX}" ]
         |      then
         |         echo "$scriptName: didn't create directory \\"\${PREFIX}\\" " >&2
         |         exit 1
         |      fi
         |      if [ 2 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: ...done" >&2
         |      fi
         |      if [ 0 -eq \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: created \\"\${PREFIX}\\" " >&2
         |      fi
         |   fi
         |fi
EOF29
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               my $vn = $bn;
               $vn    =~ tr/a-zA-Z0-9_/_/c;
               print SCRIPT fixIndentStuff(<<"EOF30");
         |
         |if [ "X\${PREFIX_$vn}" != "X" ]
         |then
         |   if [ ! -d "\${PREFIX_$vn}" ]
         |   then
         |      if [ 1 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: creating directory \\"\${PREFIX_$vn}\\" " >&2
         |      fi
         |      mkdir "\${PREFIX_$vn}" >/dev/null 2>&1
         |      status=\$?
         |      if [ "X\${status}" != "X0" ]
         |      then
         |         echo "$scriptName: can't create directory \\"\${PREFIX_$vn}\\" " >&2
         |         echo "$scriptName: ...[mkdir \\"\${PREFIX_$vn}\\"] returned exit code \${status}" >&2
         |         exit 1
         |      fi
         |      if [ ! -d "\${PREFIX_$vn}" ]
         |      then
         |         echo "$scriptName: didn't create directory \\"\${PREFIX_$vn}\\" " >&2
         |         exit 1
         |      fi
         |      if [ 2 -le \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: ...done" >&2
         |      fi
         |      if [ 0 -eq \${verbosityLevel} ]
         |      then
         |         echo "$scriptName: created \\"\${PREFIX_$vn}\\" " >&2
         |      fi
         |   fi
         |fi
EOF30
            }
         }
         if ($withPayload) {
            print SCRIPT fixIndentStuff(<<"EOF31");
         |
         |if [ "X\${debugging}" = "Xtrue" ]
         |then
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: contents of \"\${amNowIn}\" before extraction (of wrapper)" >&2
         |   /bin/ls -alF
         |fi
EOF31
         }
         else {
            print SCRIPT fixIndentStuff(<<"EOF31");
         |
         |if [ "X\${debugging}" = "Xtrue" ]
         |then
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: contents of \"\${amNowIn}\" " >&2
         |   /bin/ls -alF
         |fi
EOF31
         }
         if ($withPayload) {
         print SCRIPT fixIndentStuff(<<"EOF32");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  The self-extraction magic...
         |#
         |#  FIX: The untar process reports:
         |#
         |#          wrapper/
EOF32
         {
            my $bn;
            foreach $bn (sort keys %dirBasenames) {
               print SCRIPT fixIndentStuff(<<"EOF33");
         |#          wrapper/$bn.tar.gz
EOF33
            }
         }
         print SCRIPT fixIndentStuff(<<"EOF34");
         |#
         |#          gzip: stdin: unexpected end of file
         |#          tar: Child returned status 1
         |#          tar: Error is not recoverable: exiting now
         |#
         |#       Note that we've used a work-around: The wrapper tarball(=wrapper.tar)
         |#       is not compressed (thus avoiding the above problem). This may seem a
         |#       bit waseful but the contents of the wrapper directory are already
         |#       compressed tarballs, compressing the wrapper directory actually gives
         |#       very little improvement anyway.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: extracting wrapper tarball" >&2
         |fi
         |
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   nowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${nowIn}\" " >&2
         |   echo "$scriptName: ...run [awk '/^__PAYLOAD_BELOW__/ {print NR + 1; exit 0; }' \"\${commandPathname}\" 2>/dev/null]" >&2
         |fi
         |PAYLOAD_LINE=\`awk '/^__PAYLOAD_BELOW__/ {print NR + 1; exit 0; }' "\${commandPathname}"\`
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName:    gives: [\${PAYLOAD_LINE}]" >&2
         |   nowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${nowIn}\" " >&2
         |   echo "$scriptName: ...run [tail -n+\${PAYLOAD_LINE} \"\${commandPathname}\" > \"wrapper.tar\"]" >&2
         |fi
         |tail -n+\${PAYLOAD_LINE} "\${commandPathname}" >"wrapper.tar" 2>/dev/null
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName:    done" >&2
         |   nowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${nowIn}\" " >&2
         |   echo "$scriptName: ...run [tar -xf \"wrapper.tar\"]" >&2
         |fi
         |tar -xf "wrapper.tar" >/dev/null 2>&1
         |if [ "X\${status}" != "X0" ]
         |then
         |   echo "$scriptName: problem extracting tarball(=\"wrapper.tar\") from script(=\"\${commandPathname}\")" >&2
         |   echo "$scriptName: ...[tar -xf \"wrapper.tar\"] returned exit code \${status}" >&2 >&2
         |   exit 1
         |fi
         |
         |if [ 2 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: ...done" >&2
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  After extracting the wrapper directory from the wrapper directory from
         |#  the wrapper tarball we can toss the wrapper tarball (it was just a copy
         |#  extracter from the $scriptName script.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${keep}" != "Xtrue" ]
         |then
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      echo "$scriptName: cleanup tarball" >&2
         |      amNowIn="\`pwd\`"
         |      echo "$scriptName: ...in \"\${amNowIn}\" " >&2
         |      echo "$scriptName: ...run [rm \"wrapper.tar\"]" >&2
         |   fi
         |   rm "wrapper.tar"
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: can't cleanup the tarball(=\"wrapper.tar\")" >&2
         |      echo "$scriptName: ...[rm \"wrapper.tar\"] returned exit code \${status}" >&2
         |      exit 1
         |   fi
         |else
         |   echo "$scriptName: keeping tarball(=\"wrapper.tar\")" >&2
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: ...in \"\${amNowIn}\" " >&2
         |   lookFor="\${amNowIn}/wrapper.tar"
         |   if [ -f "\${lookFor}" ]
         |   then
         |      echo "$scriptName: ...have \"\${lookFor}\" " >&2
         |   fi
         |fi
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: \"\${amNowIn}\" after extraction..." >&2
         |   /bin/ls -alF
         |fi
EOF34
         }
         if ($withPayload) {
            print SCRIPT fixIndentStuff(<<"EOF35");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  The wrapper directory should now be in place. Remember that we're in the
         |#  temporary directory. Before further unwrapping we'll step in to the wrapper
         |#  directory check for pre- and post-install scripts (if they'd been supplied)
         |#  and each of the expected individual tarballs. If we find all of what is
         |#  expected we can then unwrap each individual tarball putting each its proper
         |#  place.
         |#
         |#-------------------------------------------------------------------------------
         |
         |cd "wrapper"
         |
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   amNowIn="\`pwd\`"
         |   echo "$scriptName: contents of \"\${amNowIn}\" " >&2
         |   /bin/ls -alF
         |fi
         |
         |allThere=true
EOF35
            if ($preInstallPathname ne "") {
               my $bn = basename($preInstallPathname);
               print SCRIPT fixIndentStuff(<<"EOF36");
         |
         |#---------------------------------------
         |#
         |#  Check for \"$bn\" (the pre-install
         |#  script)...
         |#
         |#---------------------------------------
         |
         |if [ ! -f "$bn" ]
         |then
         |   echo "$scriptName: seem to be missing \\"$bn\\" " >&2
         |   allThere=false
         |else
         |   if [ 2 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...have \\"$bn\\" in \\"wrapper\\" " >&2
         |   fi
         |fi
EOF36
            }
            if ($postInstallPathname ne "") {
               my $bn = basename($postInstallPathname);
               print SCRIPT fixIndentStuff(<<"EOF37");
         |
         |#---------------------------------------
         |#
         |#  Check for \"$bn\" (the post-install
         |#  script)...
         |#
         |#---------------------------------------
         |
         |if [ ! -f "$bn" ]
         |then
         |   echo "$scriptName: seem to be missing \\"$bn\\" " >&2
         |   allThere=false
         |else
         |   if [ 2 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...have \\"$bn\\" in \\"wrapper\\" " >&2
         |   fi
         |fi
EOF37
            }
            {
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  my $vn = $bn;
                  $vn    =~ tr/a-zA-Z0-9_/_/c;
                  print SCRIPT fixIndentStuff(<<"EOF38");
         |
         |#---------------------------------------
         |#
         |#  Check for the \"$bn\" tarball...
         |#
         |#---------------------------------------
         |
         |if [ ! -f "$bn.tar.gz" ]
         |then
         |   echo "$scriptName: seem to be missing \\"$bn.tar.gz\\" " >&2
         |   allThere=false
         |else
         |   if [ 3 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: ...have \\"$bn.tar.gz\\" in \\"wrapper\\" " >&2
         |   fi
         |fi
EOF38
               }
               print SCRIPT fixIndentStuff(<<"EOF39");
         |if [ "X\${allThere}" != "Xtrue" ]
         |then
         |   exit 1
         |fi
EOF39
            }
            if ($preInstallBasename ne "") {
               print SCRIPT fixIndentStuff(<<"EOF40");
            |
            |#-------------------------------------------------------------------------------
            |#
            |#  Run the pre-install script...
            |#
            |#  Note that this is done from the temporary wrapper directory and that the
            |#  prefix directories are passed as options on the command line (so that the
            |#  script knows where to find things.
            |#
            |#-------------------------------------------------------------------------------
            |
            |if [ -f "$preInstallBasename" ]
            |then
            |   amIn=\`pwd\`
            |   if [ 1 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: running pre-install script \\"\${PostInstallScriptName}\\" " >&2
            |   fi
EOF40
               my $theCmd = "\"./$preInstallBasename\"\${Vflag}";
               {
                  my $bn;
                  foreach $bn (sort keys %dirBasenames) {
                     my $vn  = $bn;
                     $vn     =~ tr/a-zA-Z0-9_/_/c;
                     $theCmd = $theCmd." --prefix-$bn=\"\${PREFIX_$vn}\"";
                  }
               }
               if ($preInstallStyle ne "binary") {
                  $theCmd = $preInstallStyle." ".$theCmd;
               }
               print SCRIPT fixIndentStuff(<<"EOF41");
            |   if [ "X\${debugging}" != "Xfalse" ]
            |   then
            |      echo "$scriptName: ...from \\"\${amIn}\\" " >&2
            |      echo "$scriptName:    run [$theCmd]" >&2
            |   fi
            |   $theCmd >&2
            |   status=\$?
            |   if [ "X\${status}" != "X0" ]
            |   then
            |      if [ "X\${debugging}" != "Xfalse" ]
            |      then
            |         echo "$scriptName:    ...failed, exit code \${status}" >&2
            |      fi
            |      echo "$scriptName: pre-install script(=\\"$preInstallBasename\\") failed" >&2
            |      echo "$scriptName: ...[$theCmd] returned exit code \${status}" >&2
            |      exit 1
            |   else
            |      if [ "X\${debugging}" != "Xfalse" ]
            |      then
            |         echo "$scriptName:    ...succeeded" >&2
            |      fi
            |   fi
            |   if [ 2 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: ...done" >&2
            |   fi
            |else
            |   echo "$scriptName: ...didn't find pre-install script \\"$preInstallBasename\\" " >&2
            |   exit 1
            |fi
EOF41
            }
            {
            print SCRIPT fixIndentStuff(<<"EOF42");
            |if [ 1 -le \${verbosityLevel} ]
            |then
            |   echo "$scriptName:" >&2
            |fi
EOF42
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  my $vn = $bn;
                  $vn    =~ tr/a-zA-Z0-9_/_/c;
                  print SCRIPT fixIndentStuff(<<"EOF43");
         |
         |#---------------------------------------
         |#
         |#   Unwrap the individual $bn.tar.gz
         |#   tarball to form the \${PREFIX_$vn}/$bn
         |#   directory.
         |#
         |#---------------------------------------
         |
         |wasIn="\`pwd\`"
         |if [ "X\${debugging}" != "Xfalse" ]
         |then
         |   echo "$scriptName: was in \\"\${wasIn}\\" " >&2
         |fi
         |cd "\${PREFIX_$vn}"
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: extracting \\"$bn\\" " >&2
         |   fi
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      nowIn="\`pwd\`"
         |      echo "$scriptName: ...in \\"\${nowIn}\\" " >&2
         |      echo "$scriptName:    run [tar -xf \\"\${wasIn}/$bn.tar.gz\\"]" >&2
         |   fi
         |   tar -xzf "\${wasIn}/$bn.tar.gz" 2>/dev/null
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: can't unwrap \\"$bn\\" " >&2
         |      echo "$scriptName: ...[tar -xzf \\"\\\${wasIn}/$bn.tar.gz\\"] returned exit code \${status}" >&2
         |      exit 1
         |   fi
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      echo "$scriptName:    done" >&2
         |      if [ -d "\${PREFIX_$vn}/$bn" ]
         |      then
         |         echo "$scriptName: ...found directory \\"\${PREFIX_$vn}/$bn\\" " >&2
         |      else
         |         echo "$scriptName: ...can't find directory \\"\${PREFIX_$vn}/$bn\\" " >&2
         |      fi
         |   fi
         |cd "\${wasIn}"
EOF43
               }
            }
            if ($postInstallBasename ne "") {
               print SCRIPT fixIndentStuff(<<"EOF44");
            |
            |#-------------------------------------------------------------------------------
            |#
            |#  Run the post-install script...
            |#
            |#  Note that this is done from the temporary wrapper directory and that the
            |#  prefix directories are passed as options on the command line (so that the
            |#  script knows where to find things.
            |#
            |#-------------------------------------------------------------------------------
            |
            |if [ -f "$postInstallBasename" ]
            |then
            |   amIn=\`pwd\`
            |   if [ 1 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: running post-install script \\"$postInstallBasename\\" " >&2
            |   fi
EOF44
            my $theCmd = "\"./$postInstallBasename\"\${Vflag}";
            {
               my $bn;
               foreach $bn (sort keys %dirBasenames) {
                  my $vn  = $bn;
                  $vn     =~ tr/a-zA-Z0-9_/_/c;
                  $theCmd = $theCmd." --prefix-$bn=\"\${PREFIX_$vn}\"";
               }
            }
            if ($postInstallStyle ne "binary") {
               $theCmd = $postInstallStyle." ".$theCmd;
            }
            print SCRIPT fixIndentStuff(<<"EOF45");
            |   if [ "X\${debugging}" != "Xfalse" ]
            |   then
            |      echo "$scriptName: ...from \\"\${amIn}\\" " >&2
            |      echo "$scriptName:    run [$theCmd]" >&2
            |   fi
            |   $theCmd >&2
            |   status=\$?
            |   if [ "X\${status}" != "X0" ]
            |   then
            |      if [ "X\${debugging}" != "Xfalse" ]
            |      then
            |         echo "$scriptName:    ...failed, exit code \${status}" >&2
            |      fi
            |      echo "$scriptName: post-install script(=\\"$postInstallBasename\\") failed" >&2
            |      echo "$scriptName: ...[$theCmd] returned exit code \${status}" >&2
            |      exit 1
            |   else
            |      if [ "X\${debugging}" != "Xfalse" ]
            |      then
            |         echo "$scriptName:    ...succeeded" >&2
            |      fi
            |   fi
            |   if [ 2 -le \${verbosityLevel} ]
            |   then
            |      echo "$scriptName: ...done" >&2
            |   fi
            |else
            |   echo "$scriptName: ...didn't find post-install script \\"$postInstallBasename\\" " >&2
            |   exit 1
            |fi
EOF45
            }
            print SCRIPT fixIndentStuff(<<"EOF46");
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName:" >&2
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Make some suggestions...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   makeBinSuggestion=false
         |   makeBothSuggestion=false
         |   makeLib64Suggestion=false
         |   makeLibSuggestion=false
         |   makeSuggestion=false
         |   if [ "X\${PREFIX_bin}" != X ]
         |   then
         |      makeSuggestion=true
         |      makeBinSuggestion=true
         |   fi
         |   if [ "X\${PREFIX_lib}" != X ]
         |   then
         |      makeSuggestion=true
         |      makeLibSuggestion=true
         |      if [ "X\${PREFIX_bin}" != X ]
         |      then
         |         makeBothSuggestion=true
         |      fi
         |   fi
         |   if [ "X\${PREFIX_lib64}" != X ]
         |   then
         |      makeSuggestion=true
         |      makeLib64Suggestion=true
         |      if [ "X\${PREFIX_bin}" != X ]
         |      then
         |         makeBothSuggestion=true
         |      fi
         |   fi
         |   if [ "X\${makeSuggestion}" != Xfalse ]
         |   then
         |      echo "$scriptName:" >&2
         |      if [ "X\${makeBothSuggestion}" != Xfalse ]
         |      then
         |         echo "$scriptName: suggest setting LD_LIBRARY_PATH and/or PATH using the prefix pathname" >&2
         |      else
         |         if [ "X\${makeBinSuggestion}" != Xfalse ]
         |         then
         |            echo "$scriptName: suggest setting PATH using the prefix pathname" >&2
         |         fi
         |         if [ "X\${makeLibSuggestion}" != Xfalse ]
         |         then
         |            echo "$scriptName: suggest setting LD_LIBRARY_PATH using the prefix pathname" >&2
         |         else
         |            if [ "X\${makeLib64Suggestion}" != Xfalse ]
         |            then
         |               echo "$scriptName: suggest setting LD_LIBRARY_PATH using the prefix pathname" >&2
         |            fi
         |         fi
         |      fi
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    when using bash" >&2
         |      echo "$scriptName:" >&2
         |      if [ "X\${makeLibSuggestion}" != Xfalse ]
         |      then
         |         echo "$scriptName:       LD_LIBRARY_PATH=\"\\\$LD_LIBRARY_PATH:\${PREFIX_lib}/\${LibDirBasename}\" ; export LD_LIBRARY_PATH" >&2
         |      else
         |         if [ "X\${makeLib64Suggestion}" != Xfalse ]
         |         then
         |            echo "$scriptName:       LD_LIBRARY_PATH=\"\\\$LD_LIBRARY_PATH:\${PREFIX_lib64}/\${LibDirBasename}\" ; export LD_LIBRARY_PATH" >&2
         |         fi
         |      fi
         |      if [ "X\${makeBinSuggestion}" != Xfalse ]
         |      then
         |         echo "$scriptName:       PATH=\"\\\$PATH:\${PREFIX_bin}/bin\" ; export PATH" >&2
         |      fi
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    when using csh" >&2
         |      echo "$scriptName:" >&2
         |      if [ "X\${makeLibSuggestion}" != Xfalse ]
         |      then
         |         echo "$scriptName:       setenv LD_LIBRARY_PATH \"\\\$LD_LIBRARY_PATH:\${PREFIX_lib}/\${LibDirBasename}\" " >&2
         |      else
         |         if [ "X\${makeLib64Suggestion}" != Xfalse ]
         |         then
         |            echo "$scriptName:       setenv LD_LIBRARY_PATH \"\\\$LD_LIBRARY_PATH:\${PREFIX_lib64}/\${LibDirBasename}\" " >&2
         |         fi
         |      fi
         |      if [ "X\${makeBinSuggestion}" != Xfalse ]
         |      then
         |         echo "$scriptName:       setenv PATH \"\\\$PATH:\${PREFIX_bin}/bin\" " >&2
         |         echo "$scriptName:       rehash" >&2
         |      fi
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:    You can use echo to quickly determine which shell is in use:" >&2
         |      echo "$scriptName:" >&2
         |      echo "$scriptName:       prompt: echo \\\$0" >&2
         |      echo "$scriptName:       csh" >&2
         |      echo "$scriptName:       prompt:" >&2
         |      echo "$scriptName:" >&2
         |   fi
         |fi
EOF46
         }
         print SCRIPT fixIndentStuff(<<"EOF47");
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  Cleanup...
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ "X\${keep}" != "Xtrue" ]
         |then
         |   if [ 1 -le \${verbosityLevel} ]
         |   then
         |      echo "$scriptName: cleanup" >&2
         |   fi
         |   if [ "X\${debugging}" != "Xfalse" ]
         |   then
         |      nowIn="\`pwd\`"
         |      echo "$scriptName: ...in \\"\${nowIn}\\" " >&2
         |      echo "$scriptName: ...run [rm -rf \\"\${MyTmpDir}\\"]" >&2
         |   fi
         |   rm -rf "\${MyTmpDir}" >/dev/null 2>&1
         |   status=\$?
         |   if [ "X\${status}" != "X0" ]
         |   then
         |      echo "$scriptName: can't cleanup the temporary directory(=\\"\${MyTmpDir}\\")" >&2
         |      echo "$scriptName: ...[rm -rf \\"\${MyTmpDir}\\"] returned exit code \${status}" >&2
         |      exit 1
         |   else
         |      if [ -d "\${MyTmpDir}" ]
         |      then
         |         echo "$scriptName: didn't cleanup the temporary directory(=\\"\${MyTmpDir}\\")" >&2
         |         echo "$scriptName: ...[rm -rf \\"\${MyTmpDir}\\"] failed" >&2
         |         echo "$scriptName:    directory \\"\${MyTmpDir}\\" is still there" >&2
         |         exit 1
         |      fi
         |   fi
         |else
         |   echo "$scriptName: note that the temporary directory(=\\"\${MyTmpDir}\\") has been left intact" >&2
         |fi
         |
         |#-------------------------------------------------------------------------------
         |#
         |#  All done.
         |#
         |#-------------------------------------------------------------------------------
         |
         |if [ 1 -le \${verbosityLevel} ]
         |then
         |   echo "$scriptName: all done" >&2
         |fi
         |
         |exit 0
         |
EOF47
         if ($withPayload) {
            print SCRIPT fixIndentStuff(<<"EOF48");
         |__PAYLOAD_BELOW__
EOF48
         }

         close(SCRIPT);

         my $Tend = time();
         my $dT   = $Tend - $Tstart;
         if (0 <= $dT) {
            if ($dT == 0) {
               print STDERR "mkinstaller:    done (in <1 second)\n" if (2 <= $verbosityLevel);
            }
            elsif ($dT == 1) {
               print STDERR "mkinstaller:    done (in $dT second)\n" if (2 <= $verbosityLevel);
            }
            else {
               print STDERR "mkinstaller:    done (in $dT seconds)\n" if (2 <= $verbosityLevel);
            }
         }
         else {
            print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
         }

         #-------------------------------------------------------------------------
         #
         #  Done generating the "script" part of the script, now append the wrapper
         #  tarball (the payload) to the end to form the self-extracting script.
         #
         #  At this point the script has assumed its proper name.
         #
         #-------------------------------------------------------------------------

         {
            my $Tstart = time();
            my $cmd;
            my $status;
            if ($withPayload) {
               print STDERR "mkinstaller: ...adding the payload (\"$TmpDirT/wrapper.tar\") to \"$scriptName\" script\n" if (1 <= $verbosityLevel);
               $cmd = "cat \"$TmpFile\" \"$TmpDirT/wrapper.tar\" > \"$scriptName\"";
            }
            else {
               print STDERR "mkinstaller: ...without payload!\n" if (1 <= $verbosityLevel);
               $cmd = "cat \"$TmpFile\" > \"$scriptName\"";
            }
            print STDERR "mkinstaller:    run [$cmd]\n" if $debugging;
            $status = system "$cmd 2>/dev/null";
            if ($status != 0) {
               print STDERR "mkinstaller:    ...failed\n" if $debugging;
               print STDERR "mkinstaller: can't form \"$scriptName\"\n";
               print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            print STDERR "mkinstaller:    ...done\n" if $debugging;
            if ( ! -f $scriptName) {
               print STDERR "mkinstaller:       but didn't generate \"$scriptName\"\n" if $debugging;
               print STDERR "mkinstaller: didn't form \"$scriptName\"\n";
               print STDERR "mkinstaller: ...[$cmd] failed\n";
               print STDERR "mkinstaller: ...can't find \"$scriptName\"\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            else {
               print STDERR "mkinstaller:       generated \"$scriptName\"\n" if $debugging;
            }

            my $Tend = time();
            my $dT   = $Tend - $Tstart;
            print STDERR "mkinstaller:       ...in $dT seconds\n" if $debugging;
            if (0 <= $dT) {
               if ($dT == 0) {
                  print STDERR "mkinstaller:    done (in <1 second)\n" if (2 <= $verbosityLevel);
               }
               elsif ($dT == 1) {
                  print STDERR "mkinstaller:    done (in $dT second)\n" if (2 <= $verbosityLevel);
               }
               else {
                  print STDERR "mkinstaller:    done (in $dT seconds)\n" if (2 <= $verbosityLevel);
               }
            }
            else {
               print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
            }
            {
               print STDERR "mkinstaller: ...mark \"$scriptName\" as executable\n" if $debugging;
               my $Tstart = time();
               print STDERR "mkinstaller: ...mark \"$scriptName\" as executable\n" if (1 <= $verbosityLevel);
               $cmd    = "chmod +x \"$scriptName\"";
               print STDERR "mkinstaller:    run [$cmd]\n" if $debugging;
               $status = system "$cmd >/dev/null 2>&1";
               if ($status != 0) {
                  print STDERR "mkinstaller:    ...failed\n" if $debugging;
                  print STDERR "mkinstaller: can't make \"$scriptName\" executable\n";
                  print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                  cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
                  exit 1;
               }
               else {
                  print STDERR "mkinstaller:    ...done\n" if $debugging;
               }
               my $Tend = time();
               my $dT   = $Tend - $Tstart;
               print STDERR "mkinstaller:       in $dT seconds\n" if $debugging;
               if (0 <= $dT) {
                  if ($dT == 0) {
                     print STDERR "mkinstaller:    done (in <1 second)\n" if (2 <= $verbosityLevel);
                  }
                  elsif ($dT == 1) {
                     print STDERR "mkinstaller:    done (in $dT second)\n" if (2 <= $verbosityLevel);
                  }
                  else {
                     print STDERR "mkinstaller:    done (in $dT seconds)\n" if (2 <= $verbosityLevel);
                  }
               }
               else {
                  print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
               }
            }

            #----------------------------------------------------------------------
            #
            #  The script now has the proper name, contains the payload,
            #  and has been given the proper permissions.
            #
            #  Time to generate a hash...
            #
            #----------------------------------------------------------------------

            if ($genSHA) {
               if ($use_hasher ne "") {
                  print STDERR "mkinstaller: ...generate a SHA-".$genSHA." hash\n" if $debugging;
                  my $how    = "";
                  my $Tstart = time();
                  print STDERR "mkinstaller: ...generate a SHA-".$genSHA." hash\n" if (1 <= $verbosityLevel);
                  my $hashFileName = $scriptName.".sha-".$genSHA;
                  print STDERR "mkinstaller:    as \"$hashFileName\"\n" if (2 <= $verbosityLevel);
                  my $cmd = quoteIfReqd($use_hasher).$use_hasherOpt." \"$scriptName\" >\"$hashFileName\"";
                  print STDERR "mkinstaller:    run [$cmd]\n" if $debugging;
                  $status = system "$cmd 2>/dev/null";
                  if ($status != 0) {
                     print STDERR "mkinstaller:    ...failed\n" if $debugging;
                     print STDERR "mkinstaller: can't create \"$hashFileName\" hash\n";
                     print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
                     $how  = "failed";
                  }
                  else {
                     print STDERR "mkinstaller:    ...done\n" if $debugging;
                     $how  = "done";
                  }
                  my $Tend = time();
                  my $dT   = $Tend - $Tstart;
                  print STDERR "mkinstaller:       in $dT seconds\n" if $debugging;
                  if (0 <= $dT) {
                     if ($dT == 0) {
                        print STDERR "mkinstaller:    $how (in <1 second)\n" if (2 <= $verbosityLevel);
                     }
                     elsif ($dT == 1) {
                        print STDERR "mkinstaller:    $how (in $dT second)\n" if (2 <= $verbosityLevel);
                     }
                     else {
                        print STDERR "mkinstaller:    $how (in $dT seconds)\n" if (2 <= $verbosityLevel);
                     }
                  }
                  else {
                     print STDERR "mkinstaller:    $how\n" if (2 <= $verbosityLevel);
                  }
               }
            }
         }
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
#== cut here ========================================================================================================== cut here ===
   }
   elsif ($OSclass eq "Windows-like") {
#== cut here ========================================================================================================== cut here ===

      #=========================================================================
      #
      #  This is a Windows-like host
      #
      #  The installer to be generated will actually be produced using Nullsoft's
      #  NSIS (Nullsoft Scriptable Install System) software. The mkinstaller
      #  script will generate the NSIS input script then use NSIS to generate
      #  the actual installer.
      #
      #=========================================================================

      print STDERR "mkinstaller: working on a \"$OSclass\" host\n" if $debugging;

      #---------------------------------------
      #
      #  Locate makensis (is required)...
      #
      #---------------------------------------

      print STDERR "mkinstaller: locate required \"makensis\" utility...\n" if $debugging;
      $use_makensis = lookForExecutable("makensis",\@myPath,$OSclass);
      if ($use_makensis eq "") {
         print STDERR "mkinstaller: can't locate required \"makensis\" utility\n";
         cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
         exit 1;
      }
      print STDERR "mkinstaller: ...\"$use_makensis\"\n" if $debugging;
      print STDERR "mkinstaller: ...using \"$use_makensis\"\n" if (1 <= $verbosityLevel);

      #---------------------------------------
      #
      #  Off to work...
      #
      #---------------------------------------

      my $NSISscriptName = "$here/$scriptName.nsi";
      my $removedOld     = 0;

      #---------------------------------------
      #
      #  Destroy existing NSIS script (if any)...
      #
      #---------------------------------------

      print STDERR "mkinstaller: cleanup existing NSIS script...\n" if $debugging;
      {
         print STDERR "mkinstaller: ...initial cleanup\n" if (1 <= $verbosityLevel);
         if ( -l $NSISscriptName) {
            if ( -e $NSISscriptName) {
               print STDERR "mkinstaller: \"$NSISscriptName\" is a symbolic-link not a file\n";
            }
            else {
               print STDERR "mkinstaller: \"$NSISscriptName\" is a broken symbolic-link not a file\n";
            }
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         elsif ( -f $NSISscriptName) {
            print STDERR "mkinstaller:    destroy existing \"".nativePathname($NSISscriptName)."\" script\n" if (1 <= $verbosityLevel);
            my $Ndeleted = unlink "$NSISscriptName";
            if ($Ndeleted < 1) {
               print STDERR "mkinstaller: can't destroy existing \"$NSISscriptName\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            if ( -f $NSISscriptName) {
               print STDERR "mkinstaller: didn't destroy existing \"$NSISscriptName\" file\n";
               cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
               exit 1;
            }
            print STDERR "mkinstaller:    ...done\n" if (2 <= $verbosityLevel);
            $removedOld = 1;
         }
         elsif ( -e $NSISscriptName) {
            print STDERR "mkinstaller: existing \"$NSISscriptName\" is not a file\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;

      #---------------------------------------
      #
      #  Generate NSIS script...
      #
      #---------------------------------------

      print STDERR "mkinstaller: create NSIS script...\n" if $debugging;
      {
         my $UninstallerName = "uninstaller.exe";
         if (1 <= $verbosityLevel) {
            if ($removedOld) {
               print STDERR "mkinstaller: ...create new NSIS script\n";
            }
            else {
               print STDERR "mkinstaller: ...create NSIS script\n";
            }
            print STDERR "mkinstaller:    \"$NSISscriptName\"\n" if (2 <= $verbosityLevel);
         }
         if ( ! open(SCRIPT,"> $NSISscriptName")) {
            print STDERR "mkinstaller: can't create/write \"$NSISscriptName\"\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         print SCRIPT "#-------------------------------------------------------------------------------\n";
         print SCRIPT "#\n";
         print SCRIPT "#  ".nativePathname($NSISscriptName)."\n";
         print SCRIPT "#\n";
         print SCRIPT "#  This NSIS input script was generated by mkinstaller ver. $mkinstaller_ver_name\n";
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
         print SCRIPT "#  for $ProjectName ver. $ProjectVer\n";
            }
            else {
         print SCRIPT "#  for $ProjectName.\n";
            }
         }
         print SCRIPT "#\n";
         print SCRIPT "#  The following command line was used:\n";
         print SCRIPT "#\n";
         print SCRIPT "#     ".$theCommandLine."\n";
         print SCRIPT "#\n";
         print SCRIPT "#-------------------------------------------------------------------------------\n";
         print SCRIPT "\n";
         print SCRIPT "Name                  \"".$scriptName."\"\n";
         print SCRIPT "OutFile               \"".$scriptName.".exe\"\n";
         if ($ProjectName ne "") {
            if ($ProjectVer ne "") {
         print SCRIPT "InstallDir            \$DESKTOP\\$ProjectName-$ProjectVer\n";
            }
            else {
         print SCRIPT "InstallDir            \$DESKTOP\\$ProjectName\n";
            }
         }
         else {
         print SCRIPT "InstallDir            \$DESKTOP\\$scriptName\n";
         }
         print SCRIPT "RequestExecutionLevel user\n";
         print SCRIPT "SetCompressor         /SOLID /FINAL lzma\n";
         print SCRIPT "\n";
         print SCRIPT "Section \"\"\n";
         print SCRIPT "   SetOutPath       \$INSTDIR\n";
         print SCRIPT "   WriteUninstaller \$INSTDIR\\".$UninstallerName."\n";
         my $bn;
         foreach $bn (sort keys %dirBasenames) {
            my $vn   = $bn;
            $vn      =~ tr/a-zA-Z0-9_/_/c;
            my @dirs = @{ $dirBasenames{$bn}{"pathnames"} };
            my $i;
            for ($i=0; $i<=$#dirs; $i+=1) {
               my $pathname = $dirs[$i];
               print STDERR "mkinstaller:    ...from \"$pathname\"\n" if (2 <= $verbosityLevel);
         print SCRIPT "   File /r          \"".nativePathname($pathname)."\"\n";
            }
         }
         print SCRIPT "SectionEnd\n";
         print SCRIPT "\n";
         print SCRIPT "Section \"Uninstall\"\n";
         print SCRIPT "   Delete           \$INSTDIR\\".$UninstallerName."\n";
         my $bn;
         foreach $bn (sort keys %dirBasenames) {
         print SCRIPT "   RMDir /r         \$INSTDIR\\$bn\n";
         }
         print SCRIPT "   RMDir            \$INSTDIR\n";
         print SCRIPT "SectionEnd\n";
         print SCRIPT "\n";
         close(SCRIPT);
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
      print STDERR "mkinstaller: compile NSIS script...\n" if $debugging;
      {
         print STDERR "mkinstaller: ...\"compiling\" ".nativePathname($NSISscriptName)."\n" if (1 <= $verbosityLevel);
         print STDERR "mkinstaller:    using \"".nativePathname($use_makensis)."\"\n" if (2 <= $verbosityLevel);
         my $cmd    = "\"$use_makensis\" ".quoteIfReqd(nativePathname($NSISscriptName));
         print STDERR "mkinstaller: ...run [$cmd]\n" if $debugging;
         my $status = system "$cmd >$devNull 2>&1";
         print STDERR "mkinstaller:    gives exit code $status\n" if $debugging;
         if ($status != 0) {
            print STDERR "mkinstaller:    ...failed, exit code $status\n" if $debugging;
            print STDERR "mkinstaller: can't compile \"".nativePathname($NSISscriptName).\" executable\n";
            print STDERR "mkinstaller: ...[$cmd] failed, returning exit code $status\n";
            cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
            exit 1;
         }
         else {
            print STDERR "mkinstaller:    ...succeeded\n" if $debugging;
         }
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
      }
      print STDERR "mkinstaller: ...done\n" if $debugging;
#== cut here ========================================================================================================== cut here ===
   }
   else {
      print STDERR "mkinstaller: can't identify the class of host\n";
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
      exit 1;
   }

   #---------------------------------------
   #
   #  Cleanup
   #
   #---------------------------------------

   print STDERR "mkinstaller: cleanup...\n" if $debugging;
   {
      cleanupTemps($TmpDirT,$keep,$verbosityLevel,$debugging);
   }
   print STDERR "mkinstaller: ...done\n" if $debugging;

   #----------------------------------------------------------------------------
   #
   #  All done
   #
   #----------------------------------------------------------------------------

   my $TendOverall = time();
   my $dToverall   = $TendOverall - $TstartOverall;
   if (0 <= $dToverall) {
      if ($dToverall == 0) {
         print STDERR "mkinstaller: all done (in <1 second)\n" if (1 <= $verbosityLevel);
      }
      elsif ($dToverall == 1) {
         print STDERR "mkinstaller: all done (in $dToverall second)\n" if (1 <= $verbosityLevel);
      }
      else {
         print STDERR "mkinstaller: all done (in $dToverall seconds)\n" if (1 <= $verbosityLevel);
      }
   }
   else {
      print STDERR "mkinstaller: all done\n" if (1 <= $verbosityLevel);
   }
   exit 0;

##============================================================================##
##============================================================================##
##                                                                            ##
##  Local functions...                                                        ##
##                                                                            ##
##============================================================================##
##============================================================================##

   #----------------------------------------------------------------------------
   #
   #  Cleanup any temporaries.
   #
   #  Note that it will issue warnings if content isn't all being deleted.
   #
   #----------------------------------------------------------------------------

   sub cleanupTemps {
      my $myTmpDirT      = shift;
      my $keep           = shift;
      my $verbosityLevel = shift;
      my $debugging      = shift;

      print STDERR "mkinstaller.cleanupTemps[ myTmpDirT=\"$myTmpDirT\", keep=$keep, verbosityLevel=$verbosityLevel...\n" if $debugging;
      if ( ! $keep) {
         print STDERR "mkinstaller.cleanupTemps: ...not keeping\n" if $debugging;
         print STDERR "mkinstaller: ...cleanup\n" if (1 <= $verbosityLevel);
         if ( -d "$myTmpDirT") {
            print STDERR "mkinstaller.cleanupTemps:    have \"$myTmpDirT\" directory\n" if $debugging;
            shouldDeletePathname("mkinstaller: ",$myTmpDirT);
         }
         else {
            print STDERR "mkinstaller.cleanupTemps:    don't have \"$myTmpDirT\" directory\n" if $debugging;
         }
         print STDERR "mkinstaller:    done\n" if (2 <= $verbosityLevel);
      }
      else {
         print STDERR "mkinstaller:    keeping \"$myTmpDirT\"\n" if $debugging;
      }
      print STDERR "mkinstaller.cleanupTemps] ...done\n" if $debugging;
   }

   #----------------------------------------------------------------------------
   #
   #  Output the copyright notice to stdout.
   #
   #----------------------------------------------------------------------------

   sub copyright {
      my $Nowners    = $#defaultCopyrightOwners + 1;
      my $Nstatement = $#defaultCopyrightStatement + 1;
      my $didOne     = 0;
      my $i;
      if (0 < $Nowners) {
         print "\n";
         for ($i=0; $i<$Nowners; $i+=1) {
            print $defaultCopyrightOwners[$i];
         }
         $didOne = 1;
      }
      if (0 < $Nstatement) {
         print "\n";
         for ($i=0; $i<$Nstatement; $i+=1) {
            print $defaultCopyrightStatement[$i];
         }
         $didOne = 1;
      }
      if ($didOne) {
         print "\n";
      }
   }

#== cut here ========================================================================================================== cut here ===
   #----------------------------------------------------------------------------
   #
   #  This function is used to figure-out the version number of the given
   #  compiler or linker. This code is quite complex and was derived from
   #  the code used in an autokonf generated configure script. This is only
   #  done on Linux hosts. Note that this function was derived from the code
   #  used in an autokonf generated cobfigure script. Changes made to this
   #  function should be propagated to autokonf.
   #
   #  See: totebag/src/autokonf/autokonf.pmain
   #
   #----------------------------------------------------------------------------

   sub mki_checkForCompilerVersion {
      my $pathname    = shift;
      print STDERR "mki_checkForCompilerVersion[ pathname=\"$pathname\"...\n" if $debugging;
      my $result      = "";

      my $theBasename = basename($pathname);
      print STDERR "mki_checkForCompilerVersion: ...basename is \"$theBasename\"\n" if $debugging;
      $_              = $theBasename;
      identify: {
                  #---------------------------------------
                  #
                  #  HP C++ compiler naming...
                  #
                  #---------------------------------------

                  /^aCC$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...HP C++ compiler name\n" if $debugging;
                        print STDERR "mki_checkForCompilerVersion:    on an HP, probably native\n" if $debugging;
                        my $cmd      = "$pathname -V 2>&1";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*aCC:\s+HP\s+ANSI\s+C\+\+\s+\S+\s+[AB]\.([0-9]+\.[0-9]+\S*)/) {
                           $result   = "CC $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Microsoft compiler naming...
                  #
                  #---------------------------------------

                  /^cl$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...Microsoft C/C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ( $OSclass eq "Windows-like") {
                           print STDERR "mki_checkForCompilerVersion:    on Windows, probably native\n" if $debugging;
                           my $Wpathname = makePathNative($pathname);
                           my $cmd       = "\"$Wpathname\" 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response  = `$cmd`;
                           my $status    = $?;
                           chomp $response;
                           $response     =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*Microsoft\s+.*\s+Optimizing Compiler Version ([0-9]+\.[0-9]+\S*)/) {
                              $result    = "cl $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Clang C/C++ compiler...
                  #
                  #     Note that clang and clang++ are
                  #     sometimes given funny names.
                  #
                  #---------------------------------------

                  /^(bg)?clang$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...clang C compiler name on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*\bclang\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "clang $2";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^.*\bLLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "clang $2";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*Apple\s+LLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)\s+.*\s+\(based on LLVM\s+([0-9]+\.[0-9]+).*\)/) {
                           $result   = "clang $2";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^(bg)?clang\+\+$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...clang C++ compiler name on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*\bclang\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "clang++ $2";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^.*\bLLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)/i) {
                           $result   = "clang++ $2";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*Apple\s+LLVM\s+version\s+(([0-9]+(\.[0-9]+(\.[0-9]+)?)?)\S*)\s+.*\s+\(based on LLVM\s+([0-9]+\.[0-9]+).*\)/) {
                           $result   = "clang++ $2";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Generic compiler naming...
                  #
                  #---------------------------------------

                  /^cc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...generic C compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "darwin") {
                           print STDERR "mki_checkForCompilerVersion:    on a mac, possibly gcc (GNU C)\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "hpux") {
                           print STDERR "mki_checkForCompilerVersion:    on an HP, probably native\n" if $debugging;
                           print STDERR "mki_checkForCompilerVersion:    ...create trivial C source file\n" if $debugging;
                           my $baseName = "dummy".$$;
                           my $srcName  = $baseName.".c";
                           my $objName  = $baseName.".o";
                           if (open(DUMMY,"> $srcName")) {
                              print DUMMY <<EOF;
int main ( )
{
   return 0;
}

EOF
                              close DUMMY;
                              print STDERR "mki_checkForCompilerVersion:       done\n" if $debugging;
                              my $cmd      = "$pathname -Ae -c -V $srcName 2>&1";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              my $response = `$cmd`;
                              my $status   = $?;
                              chomp $response;
                              $response    =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^.*ccom:\s+\S+\s+[AB]\.([0-9]+\.[0-9]+\S+)\s+HP\s+C\s+Compiler/) {
                                 $result   = "cc $1";
                                 print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              }
                              print STDERR "mki_checkForCompilerVersion:    ...cleanup\n" if $debugging;
                              unlink($objName);
                              unlink($srcName);
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       failed\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "irix64") {
                           print STDERR "mki_checkForCompilerVersion: ...on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "cc $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "osf") {
                           print STDERR "mki_checkForCompilerVersion: ...on an DEC, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*DEC\s+C\s+V([0-9]+\.\S+)\s+/) {
                              $result   = "cc $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "SunOS") {
                           print STDERR "mki_checkForCompilerVersion: ...on an SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "cc $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              $cmd      = "$pathname -version 2>&1";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response    =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "cc $1";
                                 print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion: ...not an HP, mac, SGI, or SUN\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*egcs-([0-9]+\.\S+)/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                              $result   = "gcc $1";
                              print STDERR "mki_checkForCompilerVersion:       case E\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "cc $1";
                              print STDERR "mki_checkForCompilerVersion:       case F\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case G (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^cxx$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...generic C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "osf") {
                           print STDERR "mki_checkForCompilerVersion:    on a DEC, probably native\n" if $debugging;
                           my $cmd      = "$pathname -V 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*DIGITAL\s+C\+\+\s+V([0-9]+\.\S+)\s+/) {
                              $result   = "cxx $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:    not a DEC\n" if $debugging;
                        }
                        last identify;
                     };

                  /^c\+\+$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...generic C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "darwin") {
                           print STDERR "mki_checkForCompilerVersion:    on a mac, possibly g++ (GNU C++)\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:    not a mac\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^CC$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...generic C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "darwin") {
                           print STDERR "mki_checkForCompilerVersion:    on a mac, possibly g++ (GNU C++)\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*\S+\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "irix64") {
                           print STDERR "mki_checkForCompilerVersion:    on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "CC $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "SunOS") {
                           print STDERR "mki_checkForCompilerVersion:    on a SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*CC:\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "CC $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              $cmd      = "$pathname -V 2>&1";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response    =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*CC:\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "CC $1";
                                 print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:    not an HP, mac, SGI, or SUN\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                              $result   = "g++ $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^f77$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...generic FORTAN 77 compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "irix64") {
                           print STDERR "mki_checkForCompilerVersion:    on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "f77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "SunOS") {
                           print STDERR "mki_checkForCompilerVersion:    on a SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.+\s+-f77\s+.+f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "f77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              $cmd      = "$pathname -V 2>&1";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response    =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^.+\s+-f77\s+.+f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "f77 $1";
                                 print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:    not an SGI or SUN\n" if $debugging;
                           my $cmd      = "$pathname --version";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                              $result   = "g77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*GNU\s+Fortran\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                              $result   = "g77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*GNU\s+Fortran\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "g77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                              $result   = "g77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^f90$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...generic FORTAN 90 compiler name on \"$OSname\"\n" if $debugging;
                        if ($OSname eq "hpux") {
                           print STDERR "mki_checkForCompilerVersion:    on an HP, probably native\n" if $debugging;
                           my $cmd      = "$pathname +version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*HP\s+F90\s+v([0-9]+\.[0-9]+\S*)/) {
                              $result   = "f90 $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "irix64") {
                           print STDERR "mki_checkForCompilerVersion:    on an SGI, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*MIPSpro\s+Compilers:\s+Version\s+([0-9]+\.\S+)/) {
                              $result   = "f90 $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        elsif ($OSname eq "SunOS") {
                           print STDERR "mki_checkForCompilerVersion:    on a SUN, probably native\n" if $debugging;
                           my $cmd      = "$pathname -version 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response = `$cmd`;
                           my $status   = $?;
                           chomp $response;
                           $response    =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                              $result   = "f77 $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                              $cmd      = "$pathname -V 2>&1";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response    =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                                 $result   = "f77 $1";
                                 print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                              }
                           }
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:    not an HP, SGI, or SUN\n" if $debugging;
                           print STDERR "mki_checkForCompilerVersion:    ...case A (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  GNU compilers...
                  #
                  #---------------------------------------

                  /^g77$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like g77 (GNU FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "g77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*GNU\s+Fortran\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "g77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*GNU\s+Fortran\s+([0-9]+\.\S+)/) {
                           $result   = "g77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "g77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^gcc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like gcc (GNU C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*gcc\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*gcc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*egcs-([0-9]+\.\S+)/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case E\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case F (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^gfortran$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like gfortran (GNU FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "gfortran $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*GNU\s+Fortran\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "gfortran $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "gfortran $1";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^g\+\+$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like g++ (GNU C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*\S+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*g\+\+\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*[^ \(]+\s+\([^\)]+\)\s+([0-9]+\.\S+)\s+.*Free\s+Software\s+Foundation/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*egcs-([0-9]+\.\S+)/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*([0-9]+\.[0-9]+(\.[0-9]+)?)/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case E\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case F (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Intel compilers...
                  #
                  #---------------------------------------

                  /^icc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like icc (Intel C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*icc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "icc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response;
                           $response =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "icc $1";
                              print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^icpc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like icpc (Intel C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*icpc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "icpc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response;
                           $response =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "icpc $1";
                              print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  /^ifort$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like ifort (Intel FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*ifort\s+\(IFORT\)\s+([0-9]+\.\S+)/) {
                           $result   = "ifort $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response;
                           $response =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*ifort\s+version\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "ifort $1";
                              print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Microsoft linker naming...
                  #
                  #---------------------------------------

                  /^link$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...Microsoft C/C++ compiler name on \"$OSname\"\n" if $debugging;
                        if ( $OSclass eq "Windows-like") {
                           print STDERR "mki_checkForCompilerVersion:    on Windows, probably native\n" if $debugging;
                           my $Wpathname = makePathNative($pathname);
                           my $cmd       = "\"$Wpathname\" 2>&1";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           my $response  = `$cmd`;
                           my $status    = $?;
                           chomp $response;
                           $response     =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^.*Microsoft\s+.*\s+Incremental\s+Linker\s+Version\s+([0-9]+\.[0-9]+\S*)/) {
                              $result    = "link $1";
                              print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  MPI compiler wrappers...
                  #
                  #---------------------------------------

                  /^mpicc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like mpicc (MPI C compiler) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*gcc\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*gcc\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "gcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*icc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "icc $1";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response;
                           $response =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "icc $1";
                              print STDERR "mki_checkForCompilerVersion:       case E\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case F (failed)\n" if $debugging;
                              $cmd      = "$pathname -V";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*pgcc\s+([0-9]+\.\S+)/) {
                                 $result = "pgcc $1";
                                 print STDERR "mki_checkForCompilerVersion:       case G\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case H (failed)\n" if $debugging;
                              }
                           }
                        }
                        last identify;
                     };

                  /^mpiCC$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like mpiCC (MPI C++ compiler) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*g\+\+\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*g\+\+\s+\([^\)]+\)\s+([0-9]+\.\S+)/) {
                           $result   = "g++ $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*icpc\s+\(ICC\)\s+([0-9]+\.\S+)/) {
                           $result   = "icpc $1";
                           print STDERR "mki_checkForCompilerVersion:       case C\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case D (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response;
                           $response =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "icpc $1";
                              print STDERR "mki_checkForCompilerVersion:       case E\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case F\n" if $debugging;
                              $cmd      = "$pathname -V";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*pgCC\s+([0-9]+\.\S+)/) {
                                 $result = "pgCC $1";
                                 print STDERR "mki_checkForCompilerVersion:       case G\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case G (failed)\n" if $debugging;
                              }
                           }
                        }
                        last identify;
                     };

                  /^mpif77$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like mpif77 (MPI FORTRAN 77 compiler) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname --version";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*GNU\s+Fortran\s+\(GCC\)\s+([0-9]+\.\S+)/) {
                           $result   = "g77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        elsif ($response =~ /^\s*ifort\s+\(IFORT\)\s+([0-9]+\.\S+)/) {
                           $result   = "ifort $1";
                           print STDERR "mki_checkForCompilerVersion:       case B\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case C (failed)\n" if $debugging;
                           $cmd      = "$pathname -v";
                           print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                           $response = `$cmd`;
                           $status   = $?;
                           chomp $response;
                           $response =~ tr!\n! !;
                           print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                           if ($response =~ /^\s*[Vv]ersion\s+([0-9]+\.[0-9]+(\S*))/) {
                              $result = "ifort $1";
                              print STDERR "mki_checkForCompilerVersion:       case D\n" if $debugging;
                           }
                           else {
                              print STDERR "mki_checkForCompilerVersion:       case E (failed)\n" if $debugging;
                              $cmd      = "$pathname -V";
                              print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                              $response = `$cmd`;
                              $status   = $?;
                              chomp $response;
                              $response =~ tr!\n! !;
                              print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                              if ($response =~ /^\s*pgf77\s+([0-9]+\.\S+)/) {
                                 $result = "pgf77 $1";
                                 print STDERR "mki_checkForCompilerVersion:       case F\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_checkForCompilerVersion:       case G (failed)\n" if $debugging;
                              }
                           }
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  Portland Group compilers...
                  #
                  #---------------------------------------

                  /^pgcc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like pgcc (PGI C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgcc\s+([0-9]+\.\S+)/) {
                           $result   = "pgcc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgCC$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like pgCC (PGI C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgCC\s+([0-9]+\.\S+)/) {
                           $result   = "pgCC $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgf77$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like pgf77 (PGI FORTRAN 77) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgf77\s+([0-9]+\.\S+)/) {
                           $result   = "pgf77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgf90$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like pgf90 (PGI FORTRAN 90) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgf90\s+([0-9]+\.\S+)/) {
                           $result   = "pgf90 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^pgf95$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like pgf95 (PGI FORTRAN 95) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*pgf95\s+([0-9]+\.\S+)/) {
                           $result   = "pgf95 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  SUN compilers...
                  #
                  #---------------------------------------

                  /^suncc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like suncc (SunPRO C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*cc:\s+Sun\s+C\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "cc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunCC$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like sunCC (SunPRO C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*CC:\s+Sun\s+C\+\+\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "CC $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunf77$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like sunf77 (SunPRO FORTRAN 77) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*-f77.*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "f77 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunf90$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like sunf90 (SunPRO FORTRAN 90) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "f90 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^sunf95$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like sunf95 (SunPRO FORTRAN 95) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -V";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd 2>&1`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^.*f90:\s+Sun\s+Fortran\s+95\s+([0-9]+\.[0-9]+\S*)/) {
                           $result   = "f95 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  #---------------------------------------
                  #
                  #  IBM compilers...
                  #
                  #---------------------------------------

                  /^xlf$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like xlf (IBM FORTRAN) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+Fortran\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "xlf $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlf90$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like xlf90 (IBM FORTRAN 90) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+Fortran\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "xlf90 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlf95$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like xlf95 (IBM FORTRAN 95) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+Fortran\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "xlf95 $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlc$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like xlc (IBM C) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+C\/C\+\+\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "xlc $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                  /^xlC$/

                     && do {
                        print STDERR "mki_checkForCompilerVersion: ...looks like xlC (IBM C++) on \"$OSname\"\n" if $debugging;
                        my $cmd      = "$pathname -qversion";
                        print STDERR "mki_checkForCompilerVersion:    run [$cmd]\n" if $debugging;
                        my $response = `$cmd`;
                        my $status   = $?;
                        chomp $response;
                        $response    =~ tr!\n! !;
                        print STDERR "mki_checkForCompilerVersion:    ...gives [$response]\n" if $debugging;
                        if ($response =~ /^\s*IBM\s+XL\s+C\/C\+\+\s+for\s+Blue\s+Gene,\s+V([0-9]+\.[0-9]+)/) {
                           $result   = "xlC $1";
                           print STDERR "mki_checkForCompilerVersion:       case A\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_checkForCompilerVersion:       case B (failed)\n" if $debugging;
                        }
                        last identify;
                     };

                }
      print STDERR "mki_checkForCompilerVersion] ...result is \"$result\"" if $debugging;
      if ($result ne "") {
         print STDERR " (success)\n" if $debugging;
      }
      else {
         print STDERR " (failure)\n" if $debugging;
      }
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Check for the availability of a command. If the given name is simple
   #  name (no /'s) then this macro tests if a program with the could be found
   #  in one of the directories listed in the established PATH environment
   #  variable and is marked executable. If the given name is not simple (an
   #  absolute or relative pathname) then this macro will test of the pathname
   #  is an executable. This may seem trivial and best answer directly using
   #  the -x operator provided by Perl but use of this macro also sets up the
   #  proper substitutions for later header file, makefile, and buildfile
   #  generation. Note that the name of the program must be double quoted.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_CHECK_PROG macro/test supplied with autokonf. Changes made
   #  to this function should be propagated to the original AK_CHECK_PROG
   #  macro/test.
   #
   #  See: totebag/src/autokonf/macros/check_prog
   #
   #----------------------------------------------------------------------------

   sub mki_check_prog {
      my @params = @_;
      my $result = 0;
      print STDERR "mki_check_prog[ starting...\n" if $debugging;
      my $N      = $#params + 1;
      if (0 < $N) {
         my $given         = $params[0];
         print STDERR "mki_check_prog: ...given \"$given\"\n" if $debugging;
         if ($given ne "") {
            my $programName   = basename($given);
            print STDERR "mki_check_prog:    basename is \"$programName\"\n" if $debugging;
            $_                = $programName;
                                s/^\s+//g;
                                s/\s+$//g;
                                s/\s+/_/g;
                                s/[^a-zA-Z0-9_]/_/g;
            my $programName_u = $_;
            print STDERR "mki_check_prog:           aka. \"$programName_u\"\n" if $debugging;
            print STDERR "mki_check_prog: ...existance of \"$programName\" already known?\n" if $debugging;

            if ( ! exists $check_prog_isSupported{$programName}) {
               $check_prog_isSupported{$programName} = 0;
               $check_prog_pathname{$programName}    = "";

               print STDERR "mki_check_prog:    no, must test\n" if $debugging;
               if ($programName != $given) {
                  my $pathname = $given;
                  print STDERR "mki_check_prog: ...\"$given\" is a pathname\n" if $debugging;
                  print STDERR "mki_check_prog:    check \"$pathname\"\n" if $debugging;
                  if (-f $pathname) {
                     print STDERR "mki_check_prog:    ...\"$pathname\" exists and is a file\n" if $debugging;
                     if (-x $pathname) {
                        print STDERR "mki_check_prog:       which is executable\n" if $debugging;
                        $check_prog_isSupported{$programName} = 1;
                        $check_prog_pathname{$programName}    = "$pathname";
                        print STDERR "mki_check_prog:    ...note its availability\n" if $debugging;
                     }
                     else {
                        print STDERR "mki_check_prog:    ...which is NOT executable\n" if $debugging;
                     }
                  }
                  else {
                     if ( -l $pathname) {
                        if ( -e $pathname) {
                           print STDERR "mki_check_prog:    ...\"$pathname\" exists and is a symbolic-link to something other than a file\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_check_prog:    ...\"$pathname\" exists and is a broken symbolic-link\n" if $debugging;
                        }
                     }
                     else {
                        if ( -e $pathname) {
                           print STDERR "mki_check_prog:    ...\"$pathname\" exists and but is not a file\n" if $debugging;
                        }
                        else {
                           print STDERR "mki_check_prog:    ...\"$pathname\" doesn't exist\n" if $debugging;
                        }
                     }
                  }
               }
               else {
                  print STDERR "mki_check_prog: ...\"$given\" is a simple name\n" if $debugging;
                  if ( exists $ENV{'PATH'} ) {
                     $myPath = $ENV{'PATH'};
                     @myPath = split /:/, $myPath;
                     my $i;
                     for ($i=0; $i<=$#myPath; ++$i) {
                        my $pathname = $myPath[$i]."/".$programName;
                        print STDERR "mki_check_prog:    check \"$pathname\"\n" if $debugging;
                        if (-f $pathname) {
                           print STDERR "mki_check_prog:    ...\"$pathname\" exists and is a file\n" if $debugging;
                           if (-x $pathname) {
                              print STDERR "mki_check_prog:       which is executable\n" if $debugging;
                              $check_prog_isSupported{$programName} = 1;
                              $check_prog_pathname{$programName}    = $pathname;
                              print STDERR "mki_check_prog:    ...note its availability\n" if $debugging;
                              last;
                           }
                           else {
                              print STDERR "mki_check_prog:       which isn't executable\n" if $debugging;
                           }
                        }
                        else {
                           if ( -l $pathname) {
                              if ( -e $pathname) {
                                 print STDERR "mki_check_prog:    ...\"$pathname\" exists and is a symbolic-link to something other than a file\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_check_prog:    ...\"$pathname\" exists and is a broken symbolic-link\n" if $debugging;
                              }
                           }
                           else {
                              if ( -e $pathname) {
                                 print STDERR "mki_check_prog:    ...\"$pathname\" exists and but is not a file\n" if $debugging;
                              }
                              else {
                                 print STDERR "mki_check_prog:    ...\"$pathname\" doesn't exist\n" if $debugging;
                              }
                           }
                        }
                     }
                  }
               }
            }
            else {
               print STDERR "mki_check_prog:    yes\n" if $debugging;
            }
            $result = $check_prog_isSupported{$programName};
         }
         else {
            print STDERR "mki_check_prog:    zero-length parameter\n" if $debugging;
         }
      }
      else {
         print STDERR "mki_check_prog: ...no parameters\n" if $debugging;
      }
      print STDERR "mki_check_prog]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #   Compare 2 version number strings. A version number string is a
   #   string formed from doit (period) separated numbers (aka. version
   #   components. In a regular expression form a version number is:
   #
   #      \d+(\.\d+)*
   #
   #   A version number never starts with a dot and may indeed contain
   #   not dots (has a single component). No prefixes or suffixes are
   #   allowed. Note this function isn't a test/macro, rather it acts
   #   in support of the testing process.
   #
   #   On success an integer value is returned: negative if the first
   #   version number is less than the second version number, zero if
   #   the version numbers are the same, or positive if the first version
   #   number is greater than the second version number (they are "out
   #   of order).
   #
   #   On failure a empty (zero length) string is returned.
   #
   #  See: totebag/src/autokonf/macros/cmp_version_nums
   #
   #----------------------------------------------------------------------------

   sub mki_cmp_version_nums {
      my $versionNumI = shift;
      my $versionNumJ = shift;
      my $result      = "";

      if ($versionNumI =~ /^\d+(\.\d+)*$/) {
         if ($versionNumJ =~ /^\d+(\.\d+)*$/) {
            my @componentsI = split /\./, $versionNumI;
            my @componentsJ = split /\./, $versionNumJ;
            my $Ni          = $#componentsI + 1;
            my $Nj          = $#componentsJ + 1;
            my $Nmin        = $Ni; $Nmin = $Nj if ($Nj < $Nmin);
            my $Nmax        = $Ni; $Nmax = $Nj if ($Nmax < $Nj);
            my $k;
            for ($k=0; $k<$Nmax; ++$k) {
               my $componentI;
               my $componentJ;
               if ($k < $Ni) {
                  $componentI = $componentsI[$k] + 0;
               }
               else {
                  $componentI = 0;
               }
               if ($k < $Nj) {
                  $componentJ = $componentsJ[$k] + 0;
               }
               else {
                  $componentJ = 0;
               }
               if ($componentI < $componentJ) {
                  $result = -1;
                  last;
               }
               elsif ($componentI == $componentJ) {
                  if ($k == $Nmax-1) {
                     $result = 0;
                     last;
                  }
               }
               else {
                  $result = 1;
                  last;
               }
            }
            if ($result eq "") {
               $result = 0;
            }
         }
      }
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to cleanup files that may have been left by a C++
   #  test. This is only done on Linux hosts. Note that this function was
   #  derived from the AK_CXX_CLEANUP macro/test supplied with autokonf.
   #  Changes made to this function should be propagated to the original
   #  AK_CXX_CLEANUP macro/test.
   #
   #  See: totebag/src/autokonf/macros/cxx_cleanup
   #
   #----------------------------------------------------------------------------

   sub mki_cxx_cleanup {
      my @params = @_;
      my $N      = $#params + 1;
      print STDERR "mki_cxx_cleanup[ starting...\n" if $debugging;
      my $result = 0;

      if ($N <= 0) {
         my $first    = 1;
         my $i        = 0;
         my @nameList = ( "konftest.cxx"
                        , "konftest.o"
                        , "konftest.obj"
                        , "konftest"
                        , "konftest.exe"
                        , "konftest.out"
                        , "konftest.log"
                        , "konftest.dSYM"
                        , "konfmain.cxx"
                        , "konfmain.o"
                        , "konfmain.obj"
                        , "konfmain.dSYM"
                        , "konffunc.cxx"
                        , "konffunc.o"
                        , "konffunc.obj"
                        , "konffunc.dSYM"
                        );

         for ($i=0; $i<=$#nameList; ++$i) {
            my $pathname = $nameList[$i];
            if (-e $pathname) {
               if ($first) {
                  print STDERR "mki_cxx_cleanup: ...delete \"$pathname\"\n" if $debugging;
                  $first = 0;
               }
               else {
                  print STDERR "mki_cxx_cleanup:    delete \"$pathname\"\n" if $debugging;
               }
               unlink($pathname);
            }
         }
         $result = 1;
      }
      else {
         print STDERR "mki_cxx_cleanup: ...too many parameters for mki_cxx_cleanup()\n" if $debugging;
         $result = 0;
      }

      print STDERR "mki_cxx_cleanup] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log and konftest.cxx files to stderr.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_CXX_DUMP_SRC_LOG macro/function supplied with autokonf. Changes
   #  made to this function should be propagated to the original AK_CXX_DUMP_SRC_LOG
   #  macro/function.
   #
   #  See: totebag/src/autokonf/macros/cxx_dump_src_log
   #
   #----------------------------------------------------------------------------

   sub mki_cxx_dump_src_log {
      my @params  = @_;
      my $N       = $#params + 1;
      my $result  = 0;
      print STDERR "mki_cxx_dump_src_log[ starting...\n" if $debugging;
      my $srcname = "";
      my $ok;
      if ($N == 0) {
         $srcname = "konftest.cxx";
         $ok      = 1;
      }
      elsif ($N == 1) {
         $srcname = "$params[0]";
         $ok      = 1;
      }
      else {
         $ok      = 0;
      }
      if ($ok) {
         mki_dump_log();
         mki_dump_file($srcname);
         $result = 1;
      }
      else {
         print STDERR "mki_cxx_dump_src_log: ...too many parameters for mki_cxx_dump_src_log()\n" if $debugging;
         $result = 0;
      }
      print STDERR "mki_cxx_dump_src_log]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log and konftest.cxx files to stderr.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_CXX_DUMP_SRC_LOG macro/function supplied with autokonf. Changes
   #  made to this function should be propagated to the original AK_CXX_DUMP_SRC_LOG
   #  macro/function.
   #
   #  See: totebag/src/autokonf/macros/dump_file
   #
   #----------------------------------------------------------------------------

   sub mki_dump_file {
      my @params   = @_;
      my $N        = $#params + 1;
      my $result   = 0;
      print STDERR "mki_dump_file[ starting...\n" if $debugging;
      my $filename = "";
      my $ok;
      if ($N == 0) {
         $filename = "konftest.c";
         $ok       = 1;
      }
      elsif ($N == 1) {
         $filename = "$params[0]";
         $ok       = 1;
      }
      else {
         $ok       = 0;
      }

      if ($ok) {
         if (-f $filename) {
            print STDERR "mki_dump_file: ...\"$filename\" is a file\n" if $debugging;
            if (-s $filename) {
               if ( open(mki_fromOutFile, "< $filename") ) {
                  print STDERR "mki_dump_file: ...the contents of \"$filename\"\n" if $debugging;
                  print STDERR "{-------------------------------------------------------------------------------\n";
                  print STDERR "$_" while <mki_fromOutFile>;
                  print STDERR "}-------------------------------------------------------------------------------\n";
                  close mki_fromOutFile;
               }
               else {
                  print STDERR "mki_dump_file: ...can't read \"$filename\"\n" if $debugging;
               }
            }
            else {
               print STDERR "mki_dump_file: ...\"$filename\" is empty\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_dump_file: ...can't find \"$filename\" is empty\n" if $debugging;
         }
      }
      else {
         print STDERR "mki_dump_file: ...too many parameters for mki_dump_file()\n" if $debugging;
      }
      print STDERR "mki_dump_file] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Dump the contents of the konftest.log file to stderr. This is only done
   #  on Linux hosts. Note that this function was derived from the AK_DUMP_LOG
   #  macro/function supplied with autokonf. Changes made to this function
   #  should be propagated to the original AK_DUMP_LOG macro/function.
   #
   #  See: totebag/src/autokonf/macros/dump_log
   #
   #----------------------------------------------------------------------------

   sub mki_dump_log {
      my @params = @_;
      my $N      = $#params + 1;
      my $result = 0;
      print STDERR "mki_dump_log[ starting...\n" if $debugging;
      if ($N <= 0) {
         my @fileList = ( "konftest.out"
                        , "konftest.log"
                        );
         my $i        = 0;
         for ($i=0; $i<=$#fileList; ++$i) {
            my $filename = $fileList[$i];
            mki_dump_file($filename);
         }
         $result = 1;
      }
      else {
         print STDERR "mki_dump_log: ...too many parameters for mki_cxx_dump_src_log()\n" if $debugging;
         $result = 0;
      }
      print STDERR "mki_dump_log]...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Get the version numbers for the OS version. This is only done on
   #  UNIX-like hosts.
   #
   #----------------------------------------------------------------------------

   sub mki_os_version {
      print STDERR "mki_os_version[ starting...\n" if $debugging;
      my $result;
      if ($use_uname eq "") {
         print STDERR "mki_os_version: ...locate \"uname\" utility\n" if $debugging;
         if (mki_check_prog("uname")) {
            print STDERR "mki_os_version:    have \"uname\" utility\n" if $debugging;
            $use_uname = $check_prog_pathname{"uname"};
            print STDERR "mki_os_version:    using \"$use_uname\"\n" if $debugging;
         }
         else {
            print STDERR "mki_os_version: ...can't locate \"uname\"\n" if $debugging;
         }
      }
      else {
         print STDERR "mki_os_version: ...already located \"uname\" utility\n" if $debugging;
         print STDERR "mki_os_version:    using \"$use_uname\"\n" if $debugging;
      }
      if ($use_uname ne "") {
         my $cmd = "$use_uname -r";
         print STDERR "mki_os_version: ...run [$use_uname]\n" if $debugging;
         if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
            print STDERR "mki_os_version:    done\n" if $debugging;
            if ( -f "konftest.out" ) {
               print STDERR "mki_os_version:    and found \"konftest.out\"\n" if $debugging;
               if ( open(mki_OUTPUT, "< konftest.out") ) {
                  print STDERR "mki_os_version: ...parse results\n" if $debugging;
                  my $versionNumber = "";
                  while (<mki_OUTPUT>) {
                     chomp;
                     print STDERR "mki_os_version:    got: [$_]\n" if $debugging;
                     parseResults: {
                                      /^\s*(\d+(\.\d+)*)(\D.*)?$/

                                         && do {
                                           print STDERR "mki_os_version:    ...case 1:\n" if $debugging;
                                           $versionNumber = $1;
                                           print STDERR "mki_os_version:       found [$versionNumber]\n" if $debugging;
                                           last parseResults;
                                        };

                                      /^(.*)$/

                                         && do {
                                           print STDERR "mki_os_version:    ...case 2:\n" if $debugging;
                                           last parseResults;
                                        };
                                   }
                  }
                  close mki_OUTPUT;
                  if ($versionNumber ne "") {
                     print STDERR "mki_os_version:    done, gives [$versionNumber]\n" if $debugging;
                     $result = $versionNumber;
                  }
               }
               else {
                  print STDERR "mki_os_version:    but can't read \"konftest.out\"\n" if $debugging;
                  $result = "";
               }
            }
            else {
               print STDERR "mki_os_version:    but can't find \"konftest.out\"\n" if $debugging;
               $result = "";
            }
         }
         else {
            print STDERR "mki_os_version:    failed\n" if $debugging;
            $result = "";
         }
      }
      else {
         $result = "";
      }
      print STDERR "mki_os_version] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Run a given command. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_RUN_COMMAND macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to
   #  the original AK_RUN_COMMAND macro/function.
   #
   #  See: totebag/src/autokonf/macros/run_command
   #
   #----------------------------------------------------------------------------

   sub mki_run_command {
      my @params = @_;
      my $N      = $#params + 1;
      my $result = 0;
      print STDERR "mki_run_command[ starting...\n" if $debugging;

      if ($N == 1) {
         my $cmd            = $params[0];
         $mki_run_command_theStatus = -1;
         if ($cmd ne "") {
            #-------------------------------
            #
            #  Run the command...
            #
            my $ok     = 0;
            my $status = 0;
            print STDERR "mki_run_command: ...run [$cmd]\n" if $debugging;
            $status = 0xffff & system "$cmd";
            if ($status == 0) {
               print STDERR "mki_run_command:    returned $status, ok\n" if $debugging;
               $mki_run_command_theStatus    = $status;
               $result                       = 1;
            }
            elsif ($status == 0xff00) {
               print STDERR "mki_run_command:    returned 0xFF00, command failed: $!\n" if $debugging;
               $mki_run_command_theStatus    = -1;
               $result                       = 0;
            }
            elsif (($status & 0xff) == 0) {
               $status >>= 8;
               print STDERR "mki_run_command:    returned $status, error\n" if $debugging;
               $mki_run_command_theStatus    = $status;
               $result                       = 0;
            }
            else {
               print STDERR "mki_run_command:    returned $status, " if $debugging;
               if ($status & 0x80) {
                  $status &= ~0x80;
                  print STDERR "coredump from " if $debugging;
               }
               print STDERR "signal $status\n" if $debugging;
               $mki_run_command_theStatus    = -1;
               $result                       = 0;
            }
         }
      }
      elsif ($N < 1) {
         print STDERR "mki_run_command: ...too few parameters for mki_run_command()\n" if $debugging;
         $result = 0;
      }
      else {
         print STDERR "mki_run_command: ...too many parameters for mki_run_command()\n" if $debugging;
         $result = 0;
      }
      print STDERR "mki_run_command] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  Sort an array of strings representing version numbers. The sort is
   #  reverse: high to low (descending order). Note that this function isn't
   #  a test/macro, rather it acts in support of the testing process.
   #  This is only done on Linux hosts. Note that this function was derived
   #  from the AK_SORT_VERSION_LIST macro/function supplied with autokonf.
   #  Changes made to this function should be propagated to the original
   #  AK_SORT_VERSION_LIST macro/function.
   #
   #  NOTE: A version number is a string of dot separated integer numbers:
   #
   #           \d+(\.\d+)*
   #
   #  See: totebag/src/autokonf/macros/sort_version_list
   #
   #----------------------------------------------------------------------------

   sub mki_sort_version_list {
      my @versionNums = @_;
      my $N           = $#versionNums + 1;
      print STDERR "mki_sort_version_list[ starting...\n" if $debugging;
      if (1 < $N) {
         print STDERR "mki_sort_version_list: ...sort $N version numbers\n" if $debugging;
         {
            print STDERR "mki_sort_version_list:    given:\n" if $debugging;
            my $k;
            for ($k=0; $k<$N; ++$k) {
               my $versionNum = $versionNums[$k];
               print STDERR "mki_sort_version_list:       [$versionNum]\n" if $debugging;
            }
         }
         print STDERR "mki_sort_version_list: ...start the actual sorting process\n" if $debugging;
         my $changed = 0;
         my $swapped = 1;
         while ($swapped) {
            $swapped = 0;
            my $i;
            my $j;
            for ($i=0,$j=1; $j<$N; ++$i,++$j) {
               my $versionNumI = $versionNums[$i];
               my $versionNumJ = $versionNums[$j];
               my $d           = mki_cmp_version_nums($versionNumI,$versionNumJ);
               if ($d eq "") {
                  print STDERR "mki_sort_version_list:    problem comparing [$versionNumI]\n" if $debugging;
                  print STDERR "mki_sort_version_list:                  and [$versionNumJ]\n" if $debugging;
                  goto theExit;
               }
               #
               #  Reverse order: sort high to low
               #
               if ($d < 0) {
                  $versionNums[$i] = $versionNumJ;
                  $versionNums[$j] = $versionNumI;
                  $swapped         = 1;
                  $changed         = 1;
               }
            }
         }
         print STDERR "mki_sort_version_list:    done\n" if $debugging;
         if ($changed) {
            print STDERR "mki_sort_version_list:    gives:\n" if $debugging;
            my $k;
            for ($k=0; $k<$N; ++$k) {
               my $versionNum = $versionNums[$k];
               print STDERR "mki_sort_version_list:       [$versionNum]\n" if $debugging;
            }
         }
      }
      else {
         print STDERR "mki_sort_version_list: ...no version numbers to sort\n" if $debugging;
      }
   theExit:
      print STDERR "mki_sort_version_list] ...done\n" if $debugging;
      return @versionNums;
   }

   #----------------------------------------------------------------------------
   #
   #  Get the version numbers for the C++ ABI, Standard C++ library, and the
   #  glibc library. This is only done on Linux hosts. Note that this function
   #  was derived from the AK_STDLIBCXX_VERSION macro/function supplied with
   #  autokonf. Changes made to this function should be propagated to the
   #  original AK_STDLIBCXX_VERSION macro/function.
   #
   #  See: totebag/src/autokonf/macros/stdlibcxx_version
   #
   #----------------------------------------------------------------------------

   sub mki_stdlibcxx_version {
      print STDERR "mki_stdlibcxx_version[ starting...\n" if $debugging;
      my $ok              = 0;
      $result             = 0;
      @CC_libcVerList     = ( );
      $CC_libcVersion     = ( );
      $CXX_libcxxPathname = "";
      @CXX_libcxxVerList  = ( );
      $CXX_libcxxVersion  = "";
      @CXX_abiVerList     = ( );
      $CXX_abiVersion     = "";
      $isKnown            = 0;
      if (mki_check_prog("ldd")) {
         print STDERR "mki_stdlibcxx_version: ...have \"ldd\" utility\n" if $debugging;
         my $use_ldd = $check_prog_pathname{"ldd"};
         print STDERR "mki_stdlibcxx_version:    using \"$use_ldd\"\n" if $debugging;
         if (mki_check_prog("fgrep")) {
            my $use_fgrep = $check_prog_pathname{"fgrep"};
            print STDERR "mki_stdlibcxx_version: ...have \"fgrep\" utility\n" if $debugging;
            print STDERR "mki_stdlibcxx_version:    using \"$use_fgrep\"\n" if $debugging;
            if (mki_check_prog("strings")) {
               my $use_strings = $check_prog_pathname{"strings"};
               print STDERR "mki_stdlibcxx_version: ...have \"strings\" utility\n" if $debugging;
               print STDERR "mki_stdlibcxx_version:    using \"$use_strings\"\n" if $debugging;
               my $answeredTheQuestion = 0;
               if ( ! $answeredTheQuestion) {
                  print STDERR "mki_stdlibcxx_version: ...initialize findings\n" if $debugging;
                  @CC_libcVerList     = ( );
                  $CXX_libcxxPathname = "";
                  @CXX_libcxxVerList  = ( );
                  @CXX_abiVerList     = ( );

                  #-------------------------------
                  #
                  #  Generate the first test file...
                  #
                  print STDERR "mki_stdlibcxx_version: ...generate primary (complex) test code\n" if $debugging;
                  if ( ! open(mki_srcFile, "> konftest.cxx") ) {
                     print STDERR "mki_stdlibcxx_version:    can't create/write \"konftest.cxx\"\n" if $debugging;
                  }
                  else {
                     #
                     #  Note that this test code may seem stupid and
                     #  an overkill but it ensures that a standard C++
                     #  library facility is used (a vector) and that
                     #  the vector is both written in to and read from
                     #  to avoid warnings.
                     #
                     print mki_srcFile fixIndentStuff(<<"EOFc");
                     |// Generated by macro: mki_stdlibcxx_version()
                     |#include <vector>
                     |
                     |int main ( int argc, char *argv[] )
                     |{  int                      i;
                     |   std::vector<const char*> v;
                     |
                     |   for (i=0; i<argc; ++i) {
                     |      v.push_back(argv[i]);
                     |   }
                     |   for (i=0; i<argc; ++i) {
                     |      if (v[i]) {
                     |         ;
                     |      }
                     |      else {
                     |         return 1;
                     |      }
                     |   }
                     |   return 0;
                     |}
                     |
EOFc
                     close mki_srcFile;
                     $ok = 1;
                     print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                  }
                  if ($ok) {
                     #{--------------------------------------
                     #
                     #  Try to compile and link it. Note
                     #  that if a binary executable is
                     #  successfully created then a copy
                     #  of it is tucked-away for future
                     #  reference.
                     #
                     print STDERR "mki_stdlibcxx_version: ...compile and link test code\n" if $debugging;
                     if (mki_try_cxx_link()) {
                        print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                        my $producedBinary      = "";
                        if ( -f "konftest") {
                           $producedBinary      = "konftest";
                        }
                        else {
                           $producedBinary      = "";
                        }
                        if ($producedBinary ne "") {
                           print STDERR "mki_stdlibcxx_version: ...examine \"$producedBinary\" using ldd and fgrep\n" if $debugging;
                           my $cmd = "\"$use_ldd\" \"./$producedBinary\" | \"$use_fgrep\" 'libstdc++'";
                           print STDERR "mki_stdlibcxx_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                           if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                              print STDERR "mki_stdlibcxx_version:    ...done\n" if $debugging;
                              if ( -f "konftest.out" ) {
                                 print STDERR "mki_stdlibcxx_version:    found \"konftest.out\"\n" if $debugging;
                                 if ( open(mki_OUTPUT, "< konftest.out") ) {
                                    print STDERR "mki_stdlibcxx_version: ...parse results\n" if $debugging;
                                    my $libVersion  = "";
                                    my $libPathname = "";
                                    my $count = 0;
                                    while (<mki_OUTPUT>) {
                                       chomp;
                                       print STDERR "mki_stdlibcxx_version:    got: [$_]\n" if $debugging;
                                       parseResults: {
                                                       /^\s*(libstdc\+\+\.so(\.(\S+)))\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $3;
                                                             $libPathname   = $4;
                                                             print STDERR "mki_stdlibcxx_version:    ...case 1:\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libName     = [$libName]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count        += 1;
                                                             last parseResults;
                                                          };

                                                       /^\s*(libstdc\+\+-(\S+)\.so\S+)\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $2;
                                                             $libPathname   = $3;
                                                             print STDERR "mki_stdlibcxx_version:    ...case 2:\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libName     = [$libName]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count        += 1;
                                                             last parseResults;
                                                          };

                                                       /^(.*)$/

                                                          && do {
                                                             print STDERR "mki_stdlibcxx_version:    ...case 3:\n" if $debugging;
                                                             last parseResults;
                                                          };

                                                     }
                                    }
                                    close mki_OUTPUT;
                                    print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                                    if ($count <= 0) {
                                       print STDERR "mki_stdlibcxx_version:    didn't find a Standard C++ library pathname\n" if $debugging;
                                    }
                                    elsif ($count == 1) {
                                       print STDERR "mki_stdlibcxx_version:    found a Standard C++ library pathname\n" if $debugging;
                                       $CXX_libcxxPathname = $libPathname;
                                       print STDERR "mki_stdlibcxx_version:    cleanup a bit\n" if $debugging;
                                       unlink("konftest.out");
                                       unlink("konftest.log");
                                       print STDERR "mki_stdlibcxx_version: ...examine \"$libPathname\" using strings\n" if $debugging;
                                       my $cmd = "\"$use_strings\" \"$libPathname\"";
                                       print STDERR "mki_stdlibcxx_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                                       if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                                          print STDERR "mki_stdlibcxx_version:    ...done\n" if $debugging;
                                          if ( -f "konftest.out" ) {
                                             print STDERR "mki_stdlibcxx_version:    found \"konftest.out\"\n" if $debugging;
                                             if ( open(mki_OUTPUT, "< konftest.out") ) {
                                                print STDERR "mki_stdlibcxx_version: ...parse results\n" if $debugging;
                                                my $first_cxxabi_verNum = "";
                                                my $first_libcxx_verNum = "";
                                                my $first_libc_verNum   = "";
                                                while (<mki_OUTPUT>) {
                                                   chomp;
                                                   print STDERR "mki_stdlibcxx_version:    got: [$_]\n" if $debugging;
                                                   parseResults: {
                                                                   /^\s*GLIBCXX_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 1:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;
                                                                         my $idx                                = $#CXX_libcxxVerList + 1;
                                                                         $CXX_libcxxVerList[$idx] = $libcxxVersion;
                                                                         $isKnown                               = 1;
                                                                         $first_libcxx_verNum                   = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBCPP_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 2:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;
                                                                         my $idx                  = $#CXX_libcxxVerList + 1;
                                                                         $CXX_libcxxVerList[$idx] = $libcxxVersion;
                                                                         $isKnown                 = 1;
                                                                         $first_libcxx_verNum     = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CXXABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 3:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx               = $#CXX_abiVerList + 1;
                                                                         $CXX_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown              = 1;
                                                                         $first_cxxabi_verNum  = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CPPABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 4:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx               = $#CXX_abiVerList + 1;
                                                                         $CXX_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown              = 1;
                                                                         $first_cxxabi_verNum  = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBC_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 5:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C libVersion    = [$libcVersion]\n" if $debugging;
                                                                         my $idx                              = $#CC_libcVerList + 1;
                                                                         $CC_libcVerList[$idx] = $libcVersion;
                                                                         $isKnown                             = 1;
                                                                         $first_libc_verNum                   = $libcVersion if $first_libc_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^(.*)$/

                                                                      && do {
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 6:\n" if $debugging;
                                                                         last parseResults;
                                                                      };

                                                                 }
                                                }
                                                close mki_OUTPUT;
                                                print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                                                if ($isKnown) {
                                                   $answeredTheQuestion = 1;
                                                }
                                             }
                                             else {
                                                print STDERR "mki_stdlibcxx_version: ...can't read \"konftest.out\"\n" if $debugging;
                                             }
                                          }
                                          else {
                                             print STDERR "mki_stdlibcxx_version:    can't find \"konftest.out\"\n" if $debugging;
                                          }
                                       }
                                       else {
                                          print STDERR "mki_stdlibcxx_version:    ...failed\n" if $debugging;
                                          mki_cxx_dump_src_log();
                                       }
                                    }
                                    else {
                                       print STDERR "mki_stdlibcxx_version:    found multiple Standard C++ library pathnames\n" if $debugging;
                                    }
                                 }
                                 else {
                                    print STDERR "mki_stdlibcxx_version: ...can't read \"konftest.out\"\n" if $debugging;
                                 }
                              }
                              else {
                                 print STDERR "mki_stdlibcxx_version:    can't find \"konftest.out\"\n" if $debugging;
                              }
                           }
                           else {
                              print STDERR "mki_stdlibcxx_version:    ...failed\n" if $debugging;
                              mki_cxx_dump_src_log();
                           }
                           print STDERR "mki_stdlibcxx_version:    cleanup\n" if $debugging;
                           unlink("konftest.out");
                           unlink("konftest.log");
                           unlink($producedBinary);
                        }
                        else {
                           print STDERR "mki_stdlibcxx_version:    but didn't produce a binary\n" if $debugging;
                        }
                     }
                     else {
                        print STDERR "mki_stdlibcxx_version:    failed\n" if $debugging;
                        mki_cxx_dump_src_log();
                     }
                     #}--------------------------------------
                     mki_cxx_cleanup();
                  }
               }
               if ( ! $answeredTheQuestion) {
                  print STDERR "mki_stdlibcxx_version: ...initialize findings\n" if $debugging;
                  @CC_libcVerList     = ( );
                  $CXX_libcxxPathname = "";
                  @CXX_libcxxVerList  = ( );
                  @CXX_abiVerList     = ( );

                  #-------------------------------
                  #
                  #  Generate the alternate test file...
                  #
                  print STDERR "mki_stdlibcxx_version: ...generate alternate (simple) test code\n" if $debugging;
                  if ( ! open(mki_srcFile, "> konftest.cxx") ) {
                     print STDERR "mki_stdlibcxx_version:    can't create/write \"konftest.cxx\"\n" if $debugging;
                  }
                  else {
                     #
                     #  this test code can give trouble as it doesn't
                     #  actually require use of the Standard C++ library
                     #  and so the "ldd" utility may not detect its
                     #  use.
                     #
                     print mki_srcFile fixIndentStuff(<<"EOFc");
                     |// Generated by macro: mki_stdlibcxx_version()
                     |
                     |int main ( )
                     |{  return 0;
                     |}
                     |
EOFc
                     close mki_srcFile;
                     $ok = 1;
                     print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                  }
                  if ($ok) {
                     #{--------------------------------------
                     #
                     #  Try to compile and link it. Note
                     #  that if a binary executable is
                     #  successfully created then a copy
                     #  of it is tucked-away for future
                     #  reference.
                     #
                     if (mki_try_cxx_link()) {
                        my $producedBinary      = "";
                        if ( -f "konftest") {
                           $producedBinary      = "konftest";
                        }
                        else {
                           $producedBinary      = "";
                        }
                        if ($producedBinary ne "") {
                           print STDERR "mki_stdlibcxx_version: ...examine \"$producedBinary\" using ldd and fgrep\n" if $debugging;
                           my $cmd = "\"$use_ldd\" \"./$producedBinary\" | \"$use_fgrep\" 'libstdc++'";
                           print STDERR "mki_stdlibcxx_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                           if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                              print STDERR "mki_stdlibcxx_version:    ...done\n" if $debugging;
                              if ( -f "konftest.out" ) {
                                 print STDERR "mki_stdlibcxx_version:    found \"konftest.out\"\n" if $debugging;
                                 if ( open(mki_OUTPUT, "< konftest.out") ) {
                                    print STDERR "mki_stdlibcxx_version: ...parse results\n" if $debugging;
                                    my $libVersion  = "";
                                    my $libPathname = "";
                                    my $count       = 0;
                                    while (<mki_OUTPUT>) {
                                       chomp;
                                       print STDERR "mki_stdlibcxx_version:    got: [$_]\n" if $debugging;
                                       parseResults: {
                                                       /^\s*(libstdc\+\+\.so(\.(\S+)))\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $3;
                                                             $libPathname   = $4;
                                                             print STDERR "mki_stdlibcxx_version:    ...case 1:\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libName     = [$libName]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count          += 1;
                                                             last parseResults;
                                                          };

                                                       /^\s*(libstdc\+\+-(\S+)\.so\S+)\s+=>\s+(\S+).*$/

                                                          && do {
                                                             my $libName    = $1;
                                                             my $libVersion = $2;
                                                             $libPathname   = $3;
                                                             print STDERR "mki_stdlibcxx_version:    ...case 2:\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libName     = [$libName]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libVersion  = [$libVersion]\n" if $debugging;
                                                             print STDERR "mki_stdlibcxx_version:          libPathname = [$libPathname]\n" if $debugging;
                                                             $count          += 1;
                                                             last parseResults;
                                                          };

                                                       /^(.*)$/

                                                          && do {
                                                             print STDERR "mki_stdlibcxx_version:    ...case 3:\n" if $debugging;
                                                             last parseResults;
                                                          };

                                                     }
                                    }
                                    close mki_OUTPUT;
                                    print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                                    if ($count <= 0) {
                                       print STDERR "mki_stdlibcxx_version:    didn't find a Standard C++ library pathname\n" if $debugging;

                                    }
                                    elsif ($count == 1) {
                                       print STDERR "mki_stdlibcxx_version:    found a Standard C++ library pathname\n" if $debugging;
                                       $CXX_libcxxPathname = $libPathname;
                                       print STDERR "mki_stdlibcxx_version:    cleanup a bit\n" if $debugging;
                                       unlink("konftest.out");
                                       unlink("konftest.log");
                                       print STDERR "mki_stdlibcxx_version: ...examine \"$libPathname\" using strings\n" if $debugging;
                                       my $cmd = "\"$use_strings\" \"$libPathname\"";
                                       print STDERR "mki_stdlibcxx_version:    run [$cmd >konftest.out 2>konftest.log]\n" if $debugging;
                                       if (mki_run_command("$cmd >konftest.out 2>konftest.log")) {
                                          print STDERR "mki_stdlibcxx_version:    ...done\n" if $debugging;
                                          if ( -f "konftest.out" ) {
                                             print STDERR "mki_stdlibcxx_version:    found \"konftest.out\"\n" if $debugging;
                                             if ( open(mki_OUTPUT, "< konftest.out") ) {
                                                print STDERR "mki_stdlibcxx_version: ...parse results\n" if $debugging;
                                                my $first_cxxabi_verNum = "";
                                                my $first_libcxx_verNum = "";
                                                my $first_libc_verNum   = "";
                                                while (<mki_OUTPUT>) {
                                                   chomp;
                                                   print STDERR "mki_stdlibcxx_version:    got: [$_]\n" if $debugging;
                                                   parseResults: {
                                                                   /^\s*GLIBCXX_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 1:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;

                                                                         my $idx                                = $#CXX_libcxxVerList + 1;
                                                                         $CXX_libcxxVerList[$idx] = $libcxxVersion;
                                                                         $isKnown                               = 1;
                                                                         $first_libcxx_verNum                   = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBCPP_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 2:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ lib Version = [$libcxxVersion]\n" if $debugging;
                                                                         my $idx                  = $#CXX_libcxxVerList + 1;
                                                                         $CXX_libcxxVerList[$idx] = $libcxxVersion;
                                                                         $isKnown                 = 1;
                                                                         $first_libcxx_verNum     = $libcxxVersion if $first_libcxx_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CXXABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 3:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx               = $#CXX_abiVerList + 1;
                                                                         $CXX_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown              = 1;
                                                                         $first_cxxabi_verNum  = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*CPPABI_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcxxAbiVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 4:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C++ ABI Version = [$libcxxAbiVersion]\n" if $debugging;
                                                                         my $idx               = $#CXX_abiVerList + 1;
                                                                         $CXX_abiVerList[$idx] = $libcxxAbiVersion;
                                                                         $isKnown              = 1;
                                                                         $first_cxxabi_verNum  = $libcxxAbiVersion if $first_cxxabi_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^\s*GLIBC_([.0-9]+)\S*\s*$/

                                                                      && do {
                                                                         my $libcVersion = $1;
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 5:\n" if $debugging;
                                                                         print STDERR "mki_stdlibcxx_version:          C libVersion    = [$libcVersion]\n" if $debugging;
                                                                         my $idx                              = $#CC_libcVerList + 1;
                                                                         $CC_libcVerList[$idx] = $libcVersion;
                                                                         $isKnown                             = 1;
                                                                         $first_libc_verNum                   = $libcVersion if $first_libc_verNum eq "";
                                                                         last parseResults;
                                                                      };

                                                                   /^(.*)$/

                                                                      && do {
                                                                         print STDERR "mki_stdlibcxx_version:    ...case 6:\n" if $debugging;
                                                                         last parseResults;
                                                                      };

                                                                 }
                                                }
                                                close mki_OUTPUT;
                                                print STDERR "mki_stdlibcxx_version:    done\n" if $debugging;
                                                if ($isKnown) {
                                                   $answeredTheQuestion = 1;
                                                }
                                             }
                                             else {
                                                print STDERR "mki_stdlibcxx_version: ...can't read \"konftest.out\"\n" if $debugging;
                                             }
                                          }
                                          else {
                                             print STDERR "mki_stdlibcxx_version:    can't find \"konftest.out\"\n" if $debugging;
                                          }
                                       }
                                       else {
                                          print STDERR "mki_stdlibcxx_version:    ...failed\n" if $debugging;
                                          mki_cxx_dump_src_log();
                                       }
                                    }
                                    else {
                                       print STDERR "mki_stdlibcxx_version:    found multiple Standard C++ library pathnames\n" if $debugging;
                                    }
                                 }
                                 else {
                                    print STDERR "mki_stdlibcxx_version: ...can't read \"konftest.out\"\n" if $debugging;
                                 }
                              }
                              else {
                                 print STDERR "mki_stdlibcxx_version:    can't find \"konftest.out\"\n" if $debugging;
                              }
                           }
                           else {
                              print STDERR "mki_stdlibcxx_version:    ...failed\n" if $debugging;
                              mki_cxx_dump_src_log();
                           }
                           print STDERR "mki_stdlibcxx_version:    cleanup\n" if $debugging;
                           unlink("konftest.out");
                           unlink("konftest.log");
                           unlink($producedBinary);
                        }
                        else {
                           print STDERR "mki_stdlibcxx_version:    but didn't produce a binary\n" if $debugging;
                        }
                     }
                     else {
                        mki_cxx_dump_src_log();
                     }
                     #}--------------------------------------
                     mki_cxx_cleanup();
                  }
               }
            }
            else {
               print STDERR "mki_stdlibcxx_version: ...don't have \"strings\" utility\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_stdlibcxx_version: ...don't have \"fgrep\" utility\n" if $debugging;
         }
      }
      else {
         print STDERR "mki_stdlibcxx_version: ...don't have \"ldd\" utility\n" if $debugging;
      }

      if ($isKnown) {
         print STDERR "mki_stdlibcxx_version: ...found some library version number(s)\n" if $debugging;
         my $Ncxxabi = $#CXX_abiVerList + 1;
         if (1 <= $Ncxxabi) {
            @CXX_abiVerList = mki_sort_version_list(@CXX_abiVerList);
            my $i;
            for ($i=0; $i<$Ncxxabi; ++$i) {
               my $versionNum = $CXX_abiVerList[$i];
               if ($i == 0) {
                  print STDERR "mki_stdlibcxx_version:    C++ ABI version ........................" if $debugging;
               }
               elsif ($i == 1) {
                  if ($Ncxxabi == 2) {
                     print STDERR "mki_stdlibcxx_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print STDERR "mki_stdlibcxx_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print STDERR "mki_stdlibcxx_version:          .................................." if $debugging;
               }
               print STDERR " $versionNum\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_stdlibcxx_version:    C++ ABI version ........................" if $debugging;
            print STDERR " unknown\n" if $debugging;
         }
         my $Nlibcxx = $#CXX_libcxxVerList + 1;
         if (1 <= $Nlibcxx) {
            @CXX_libcxxVerList = mki_sort_version_list(@CXX_libcxxVerList);
            my $i;
            for ($i=0; $i<$Nlibcxx; ++$i) {
               my $versionNum = $CXX_libcxxVerList[$i];
               if ($i == 0) {
                  print STDERR "mki_stdlibcxx_version:    Standard C++ library version ..........." if $debugging;
               }
               elsif ($i == 1) {
                  if ($Nlibcxx == 2) {
                     print STDERR "mki_stdlibcxx_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print STDERR "mki_stdlibcxx_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print STDERR "mki_stdlibcxx_version:          .................................." if $debugging;
               }
               print STDERR " $versionNum\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_stdlibcxx_version:    Standard C++ library version ..........." if $debugging;
            print STDERR " unknown\n" if $debugging;
         }
         my $Nlibc = $#CC_libcVerList + 1;
         if (1 <= $Nlibc) {
            @CC_libcVerList = mki_sort_version_list(@CC_libcVerList);
            my $i;
            for ($i=0; $i<$Nlibc; ++$i) {
               my $versionNum = $CC_libcVerList[$i];
               if ($i == 0) {
                  print STDERR "mki_stdlibcxx_version:    C library version ......................" if $debugging;
               }
               elsif ($i == 1) {
                  if ($Nlibc == 2) {
                     print STDERR "mki_stdlibcxx_version:       supports version ...................." if $debugging;
                  }
                  else {
                     print STDERR "mki_stdlibcxx_version:       supports versions ..................." if $debugging;
                  }
               }
               else {
                  print STDERR "mki_stdlibcxx_version:          .................................." if $debugging;
               }
               print STDERR " $versionNum\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_stdlibcxx_version:    C library version ......................" if $debugging;
            print STDERR " unknown\n" if $debugging;
         }
         $result = 1;
      }
      else {
         print STDERR "mki_stdlibcxx_version: ...didn't find any library version numbers\n" if $debugging;
         $stdlibcxx_version_isKnown = 0;
      }

      if ($producedBinary ne "") {
         if ( -f $producedBinary) {
            print STDERR "mki_stdlibcxx_version: ...delete \"$producedBinary\"\n" if $debugging;
            unlink($producedBinary);
         }
         if ( -f "konftest.out") {
            unlink("konftest.out");
         }
         if ( -f "konftest.log") {
            unlink("konftest.log");
         }
      }

      print STDERR "mki_stdlibcxx_version] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an object file by using the C++ compiler.
   #  Note that by default it will try to form an object file from the
   #  "konftest.cxx" file. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_TRY_CXX_COMPILE macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to the
   #  original AK_TRY_CXX_COMPILE macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_cxx_compile
   #
   #----------------------------------------------------------------------------

   sub mki_try_cxx_compile {
      my @params  = @_;
      my $N       = $#params + 1;
      my $result  = 0;
      print STDERR "mki_try_cxx_compile[ starting...\n" if $debugging;

      my $ok      = 0;
      my $srcname = "";
      my $objname = "";
      if ($N == 0) {
         $srcname = "konftest.cxx";
         $objname = "konftest.o";
         $ok      = 1;
      }
      elsif ($N == 1) {
         $srcname = "$params[0]";
         $objname = $srcname;
         $objname =~ s/\.cxx$/.o/;
         $ok      = 1;
      }
      else {
         $ok      = 0;
      }
      if ($ok) {
         if ( -f "$objname" ) {
            print STDERR "mki_try_cxx_compile: ...delete existing \"\"\n" if $debugging;
            while ( -f "$objname" ) {
               unlink("$objname");
            }
         }
         print STDERR "mki_try_cxx_compile: ...using $CXX_name for the C++ compiler\n" if $debugging;
         if ($CXX_name ne "") {
            print STDERR "mki_try_cxx_compile: ...compile \"$srcname\" to produce \"$objname\"\n" if $debugging;
            my $cmd = "$CXX_name -c $CXX_options $srcname";
            $cmd    = "$cmd >konftest.log 2>&1";
            print STDERR "mki_try_cxx_compile:    run [$cmd]\n" if $debugging;
            if (mki_run_command($cmd)) {
               print STDERR "mki_try_cxx_compile:    ...done\n" if $debugging;
               if ( -f $objname ) {
                  print STDERR "mki_try_cxx_compile:    found \"$objname\"\n" if $debugging;
                  $result = 1;
               }
               else {
                  print STDERR "mki_try_cxx_compile:    can't find \"$objname\"\n" if $debugging;
               }
            }
            else {
               print STDERR "mki_try_cxx_compile:    ...failed\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_try_cxx_compile: ...don't know what compiler to use\n" if $debugging;
         }
         if ( ! $result) {
            mki_cxx_dump_src_log("$srcname");
         }
      }

      print STDERR "mki_try_cxx_compile] ...done(=$result)\n" if $debugging;
      return $result;
   }

   #----------------------------------------------------------------------------
   #
   #  This function is used to form an executable by using the C++ linker.
   #  Note that by default it will try to form an executable from the
   #  "konftest.o" file. This is only done on Linux hosts. Note that this
   #  function was derived from the AK_TRY_CXX_LINK macro/function supplied
   #  with autokonf. Changes made to this function should be propagated to the
   #  original AK_TRY_CXX_LINK macro/function.
   #
   #  See: totebag/src/autokonf/macros/try_cxx_link
   #
   #----------------------------------------------------------------------------

   sub mki_try_cxx_link {
      my @params = @_;
      my $N      = $#params + 1;
      print STDERR "mki_try_cxx_link[ starting...\n" if $debugging;
      my $result = 0;

      print STDERR "mki_try_cxx_link: ...compile\n" if $debugging;
      if (mki_try_cxx_compile()) {
         print STDERR "mki_try_cxx_link:    done\n" if $debugging;
         if ( -f "konftest" ) {
            print STDERR "mki_try_cxx_link: ...delete existing \"konftest\"\n" if $debugging;
            while ( -f "konftest" ) {
               unlink("konftest");
            }
         }
         my $cmd = "$CXX_name $CXX_options -o konftest konftest.o -lm";
         $cmd    = "$cmd >konftest.log 2>&1";
         print STDERR "mki_try_cxx_link: ...run [$cmd]\n" if $debugging;
         if (mki_run_command($cmd)) {
            print STDERR "mki_try_cxx_link:    done\n" if $debugging;
            if ( -f "konftest" ) {
               print STDERR "mki_try_cxx_link:    found \"konftest\"\n" if $debugging;
               if ( -x "konftest" ) {
                  print STDERR "mki_try_cxx_link:    which is executable\n" if $debugging;
                  $result = 1;
               }
               else {
                  print STDERR "mki_try_cxx_link:    which isn't executable\n" if $debugging;
               }
            }
            else {
               print STDERR "mki_try_cxx_link:    can't find \"konftest\"\n" if $debugging;
            }
         }
         else {
            print STDERR "mki_try_cxx_link:    failed\n" if $debugging;
         }
         if ( ! $result) {
            mki_cxx_dump_src_log();
         }
      }
      else {
         print STDERR "mki_try_cxx_link:    failed\n" if $debugging;
      }
      print STDERR "mki_try_cxx_link] ...done(=$result)\n" if $debugging;
      return $result;
   }

#== cut here ========================================================================================================== cut here ===
}

# MyUniqueFileId: d1e4e179-f5ab-4da0-a4b3-3904cdc4feb2
#-------------------------------------------------------------------------------
#
#  This subroutine is used to translate a relative pathname to an absolute
#  pathname.
#
#  see: totebag/src/perl-lib/absname.psub
#
#-------------------------------------------------------------------------------

sub absname {
   my $pathname = shift;
   my $result   = "";
   if ($pathname =~ /^[\/\\]/) {
      $result   = $pathname;
   }
   else {
      my $here  = getWorkingDirectory();
      $result   = joinpath($here,$pathname);
   }
   $result      = fixpath($result);
   return $result;
}

# MyUniqueFileId: c16cf2c9-02f4-48a7-bf6f-6d74697af801
#-------------------------------------------------------------------------------
#
#  Basename from pathname.
#
#  This function is used to extract the basename (the final component) from a
#  given pathname. Note that this kind of operation is generally available in
#  the File module.
#
#  This function uses: fixpath()
#
#  see: totebag/src/perl-lib/basename.psub
#
#-------------------------------------------------------------------------------

sub basename {
   my $pathname = shift(@_);
   $_           = fixpath($pathname);
   parse: {
             /^(.+)[\/\\]([^\/\\]*)$/

                && do {
                   return $2;
                };

             /^[\/\\]([^\/\\]*)$/

                && do {
                   return $1;
                };

             /^([^\/\\]*)$/

                && do {
                   return $1;
                };

          }
}

# MyUniqueFileId: c74b22fd-6ce7-417f-95b3-89ed86a69cbe
#-------------------------------------------------------------------------------
#
#  This subroutine deletes one or more directories and all of the content.
#  Note that it is assumed that a directory tree only contains directories,
#  files, and/or symbolic-links. An array of pathnames that could not be
#  deleted is returned.
#
#  see: totebag/src/perl-lib/deletePathnames.psub
#
#  Note: This function appears to be a lot more complex than neccessary. It
#        not only requests that given pathnames (and recursive contents) be
#        removed, it also checks to see that it's all gone (returning any
#        remaining pathnames). The real problem here is that NFS can get in
#        the way by inserting temporary .nfsXXX..XXX files. This can prevent
#        a what should be empty directory from being removed (it doesn't look
#        empty).
#
#-------------------------------------------------------------------------------

sub deletePathnames {
   print STDERR "deletePathnames[ starting...\n" if $debugging;
   my @failures  = ( );
   my $Nfailures = 0;
   my $rootPathname;
   foreach $rootPathname (@_) {
      print STDERR "deletePathnames: ...working \"".$rootPathname."\"\n" if $debugging;
      my $oldCount = -1;
      my $newCount = 0;
      if ($rootPathname ne "") {
         #---------------------------------------
         #
         #  We first recursivly crawl the directory
         #  tree forming a list of pathnames that
         #  appear to exist. The size of this list
         #  also serves as the initial pathname
         #  count; we'll be watching the pathname
         #  count -- looping while it continues
         #  to shrink or becomes empty
         #
         #---------------------------------------
         print STDERR "deletePathnames{    build initial pathname list\n" if $debugging;
         my @pathnames  = ();
         my $rootExists = 0;
         if ( -l $rootPathname) {
            $rootExists = 1;
         }
         elsif ( -e $rootPathname) {
            $rootExists = 1;
         }
         if ($rootExists) {
            my $idx          = $#pathnames + 1;
            $pathnames[$idx] = $rootPathname;
            my $i;
            for ($i=0; $i<=$#pathnames; ++$i) {
               my $pathname = $pathnames[$i];
               if ( -l $pathname) {
                  print STDERR "deletePathnames:    l \"".$pathname."\"\n" if $debugging;
               }
               elsif ( -f $pathname) {
                  print STDERR "deletePathnames:    f \"".$pathname."\"\n" if $debugging;
               }
               elsif ( -d $pathname ) {
                  print STDERR "deletePathnames:    d \"".$pathname."\"\n" if $debugging;
                  if (! opendir(DIR,$pathname)) {
                     print STDERR $sponsor."can't read directory \"$pathname\"\n" if $sponsor;
                     $result = 0;
                  }
                  else {
                     while (defined($tmp = readdir(DIR))) {
                        if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                           my $idx          = $#pathnames + 1;
                           $pathnames[$idx] = $pathnames[$i]."/"."$tmp";
                           print STDERR "deletePathnames:    \"".$pathnames[$idx]."\"\n" if $debugging;
                        }
                     }
                     closedir(DIR);
                  }
               }
               else {
                  print STDERR "deletePathnames:    ? \"".$pathname."\"\n" if $debugging;
               }
            }
         }
         print STDERR "deletePathnames}    done\n" if $debugging;
         $oldCount = $#pathnames + 1;
         if ($oldCount == 1) {
            print STDERR "deletePathnames: ...have $oldCount pathname at/under \"".$rootPathname."\"\n" if $debugging;
         }
         else {
            print STDERR "deletePathnames: ...have $oldCount pathnames at/under \"".$rootPathname."\"\n" if $debugging;
         }
         if (1 <= $oldCount) {
            my $cycle = 0;
            my $done  = 0;
            while ( ! $done) {
               my $haveNFS  = 0;
               $cycle      += 1;
               #---------------------------------------
               #
               #  Use the pathnames list to remove things.
               #  Once we've gone through the list, we'll
               #  rebuild the list and check for a change
               #  in the list size. We'll loop so long as
               #  the list shrinks or until it becomes
               #  empty.
               #
               #---------------------------------------
               if (getOSclass() eq "UNIX-like") {
                  #---------------------------------------
                  #
                  #  If this is a UNIX-like" system, try
                  #  using rm to delete each in the list.
                  #  Note that this is done in a bottom-up
                  #  fashion so that directory content is
                  #  removed before the directory.
                  #
                  #---------------------------------------
                  print STDERR "deletePathnames{ ...a UNIX-like host, try using rm ...\n" if $debugging;
                  for ($i=$#pathnames; 0<=$i; $i--) {
                     my $pathname   = $pathnames[$i];
                     my $stillThere = 0;
                     if ( -l $pathname) {
                        $stillThere = 1;
                     }
                     elsif ( -e $pathname) {
                        $stillThere = 1;
                     }
                     else {
                        $stillThere = 0;
                     }
                     if ($stillThere) {
                        my $bn = basename($pathname);
                        if ($bn =~ /^\.nfs[^\/]*$/) {
                           $haveNFS = 1;
                           print STDERR "deletePathnames:    \"".$pathname."\" looks like a .nfs file\n" if $debugging;
                        }
                        my $cmd      = "rm -rf \"$pathname\"";
                        print STDERR "deletePathnames:    run: [$cmd]\n" if $debugging;
                        my $status   = system "$cmd >/dev/null 2>&1";
                        if ($status != 0) {
                           my $code = $status >> 8;
                           print STDERR "deletePathnames:    ...[$cmd] failed, code $code" if $debugging;
                           if ($status & 127) {
                              my $signum = $status & 127;
                              print STDERR ", signal $signum" if $debugging;
                           }
                           if ($status & 127) {
                              print STDERR ", core dumped" if $debugging;
                           }
                           print STDERR "\n" if $debugging;
                        }
                     }
                  }
                  print STDERR "deletePathnames}    done\n" if $debugging;
               }
               #---------------------------------------
               #
               #  Now we go through the list and use
               #  Perl rmdir() and/or unlink() functions
               #  to delete things. Note that this is
               #  done in a bottom-up fashion so that
               #  directory content is removed before
               #  the directory.
               #
               #---------------------------------------
               print STDERR "deletePathnames{ ...removing the Perl way\n" if $debugging;
               for ($i=$#pathnames; 0<=$i; $i--) {
                  my $pathname = $pathnames[$i];
                  my $bn       = basename($pathname);
                  if ($bn =~ /^\.nfs[^\/]*$/) {
                     $haveNFS = 1;
                     print STDERR "deletePathnames:    \"".$pathname."\" looks like a .nfs file\n" if $debugging;
                  }
                  if ( -l $pathname) {
                     print STDERR "deletePathnames:    l \"".$pathname."\"\n" if $debugging;
                     if ( ! unlink($pathname)) {
                        print STDERR "deletePathnames:      ...unlink(\"".$pathname."\") failed\n" if $debugging;
                        print STDERR "deletePathnames:         ".$!."\n" if $debugging;
                     }
                  }
                  elsif ( -d $pathname) {
                     print STDERR "deletePathnames:    d \"".$pathname."\"\n" if $debugging;
                     if ( ! rmdir($pathname)) {
                        print STDERR "deletePathnames:      ...rmdir(\"".$pathname."\") failed\n" if $debugging;
                        print STDERR "deletePathnames:         ".$!."\n" if $debugging;
                     }
                  }
                  elsif ( -f $pathname) {
                     print STDERR "deletePathnames:    f \"".$pathname."\"\n" if $debugging;
                     if ( ! unlink($pathname)) {
                        print STDERR "deletePathnames:      ...unlink(\"".$pathname."\") failed\n" if $debugging;
                        print STDERR "deletePathnames:         ".$!."\n" if $debugging;
                     }
                  }
                  elsif ( -e $pathname) {
                     print STDERR "deletePathnames:    ? \"".$pathname."\"\n" if $debugging;
                     if ( ! unlink($pathname)) {
                        print STDERR "deletePathnames:      ...unlink(\"".$pathname."\") failed\n" if $debugging;
                        print STDERR "deletePathnames:         ".$!."\n" if $debugging;
                     }
                  }
                  else {
                     print STDERR "deletePathnames:    ! \"".$pathname."\" is gone\n" if $debugging;
                  }
               }
               print STDERR "deletePathnames}    done\n" if $debugging;
               if (2 <= $cycle) {
                  if ($haveNFS) {
                     my $moved = 0;
                     my $here  = getWorkingDirectory();
                     if ($here ne "") {
                        print STDERR "deletePathnames:    cd to \"/\"\n" if $debugging;
                        if (chdir("/")) {
                           $moved = 1;
                        }
                        else {
                           print STDERR "deletePathnames:    ...failed\n" if $debugging;
                        }
                     }
                     print STDERR "deletePathnames:    pause for NFS cache\n" if $debugging;
                     sleep 61;
                     if ($moved) {
                        print STDERR "deletePathnames:    cd back to \"$here\"\n" if $debugging;
                        if ( ! chdir($here)) {
                           print STDERR "deletePathnames:    ...failed\n" if $debugging;
                        }
                     }
                  }
               }
               #---------------------------------------
               #
               #  We again recursivly crawl the directory
               #  tree to rebuild the list of pathnames
               #  that still appear to exist. We keep
               #  looping while it continues to shrink.
               #
               #---------------------------------------
               print STDERR "deletePathnames{    rebuild pathname list\n" if $debugging;
               @pathnames     = ();
               my $rootExists = 0;
               if ( -l $rootPathname) {
                  $rootExists = 1;
               }
               elsif ( -e $rootPathname) {
                  $rootExists = 1;
               }
               if ($rootExists) {
                  my $idx          = $#pathnames + 1;
                  $pathnames[$idx] = $rootPathname;
                  my $i;
                  for ($i=0; $i<=$#pathnames; ++$i) {
                     my $pathname = $pathnames[$i];
                     if ( -l $pathname) {
                        print STDERR "deletePathnames:    l \"".$pathname."\"\n" if $debugging;
                     }
                     elsif ( -f $pathname) {
                        print STDERR "deletePathnames:    f \"".$pathname."\"\n" if $debugging;
                     }
                     elsif ( -d $pathname ) {
                        print STDERR "deletePathnames:    d \"".$pathname."\"\n" if $debugging;
                        if (! opendir(DIR,$pathname)) {
                           print STDERR $sponsor."can't read directory \"$pathname\"\n" if $sponsor;
                           $result = 0;
                        }
                        else {
                           while (defined($tmp = readdir(DIR))) {
                              if (($tmp ne "" ) && ($tmp ne ".") && ($tmp ne "..")) {
                                 my $idx          = $#pathnames + 1;
                                 $pathnames[$idx] = $pathnames[$i]."/"."$tmp";
                                 print STDERR "deletePathnames:    \"".$pathnames[$idx]."\"\n" if $debugging;
                              }
                           }
                           closedir(DIR);
                        }
                     }
                     else {
                        print STDERR "deletePathnames:    ? \"".$pathname."\"\n" if $debugging;
                     }
                  }
               }
               print STDERR "deletePathnames}    done\n" if $debugging;
               $newCount = $#pathnames + 1;
               if ($newCount == 1) {
                  print STDERR "deletePathnames: ...now have $newCount pathname at/under \"".$rootPathname."\"\n" if $debugging;
               }
               else {
                  print STDERR "deletePathnames: ...now have $newCount pathnames at/under \"".$rootPathname."\"\n" if $debugging;
               }
               if (($newCount <= 0) || ($oldCount <= $newCount)) {
                  if ($newCount <= 0) {
                     print STDERR "deletePathnames:    nothing left to do\n" if $debugging;
                  }
                  elsif ($oldCount <= $newCount) {
                     print STDERR "deletePathnames:    no change\n" if $debugging;
                  }
                  $done     = 1;
               }
               else {
                  $oldCount = $newCount;
                  $newCount = 0;
                  $done     = 0;
               }
            }
            #---------------------------------------
            #
            #  Add any leftovers to the failure list.
            #  This is the last chance to see if
            #  something has disappeared.
            #
            #---------------------------------------
            print STDERR "deletePathnames{    form the failure list\n" if $debugging;
            for ($i=0; $i<=$#pathnames; ++$i) {
               my $pathname    = $pathnames[$i];
               my $stillExists = 0;
               if ( -l $pathname) {
                  $stillExists = 1;
                  print STDERR "deletePathnames:    l \"".$pathname."\"\n" if $debugging;
               }
               elsif ( -d $pathname) {
                  $stillExists = 1;
                  print STDERR "deletePathnames:    d \"".$pathname."\"\n" if $debugging;
               }
               elsif ( -f $pathname) {
                  $stillExists = 1;
                  print STDERR "deletePathnames:    f \"".$pathname."\"\n" if $debugging;
               }
               elsif ( -e $pathname) {
                  $stillExists = 1;
                  print STDERR "deletePathnames:    ? \"".$pathname."\"\n" if $debugging;
               }
               else {
                  $stillExists = 0;
               }
               if ($stillExists) {
                  my $idx         = $#failures + 1;
                  $failures[$idx] = $pathname;
                  $Nfailures     += 1;
               }
            }
            print STDERR "deletePathnames}    done\n" if $debugging;
         }
         else {
            print STDERR "deletePathnames:    nothing to do\n" if $debugging;
         }
      }
   }
   print STDERR "deletePathnames] ...done(={" if $debugging;
   my $N = $#failures + 1;
   if (1 <= $N) {
      my $pathname = $failures[0];
      print STDERR "\"".$pathname."\"" if $debugging;
      if (2 <= $N) {
         if (3 <= $N) {
            print STDERR ", ... " if $debugging;
         }
         $pathname = $failures[$#failures];
         print STDERR ", \"".$pathname."\"" if $debugging;
      }
   }
   print STDERR "})\n" if $debugging;
   return @failures;
}

# MyUniqueFileId: 8beb72f4-0e19-46e2-effb-336240c9fb42
#-------------------------------------------------------------------------------
#
#  Dirname of pathname.
#
#  This function is used to extract the directory name (all but the final
#  component) from a given pathname. Note that this kind of operation is
#  generally available in the File module.
#
#  This function uses: fixpath()
#
#  see: totebag/src/perl-lib/dirname.psub
#
#-------------------------------------------------------------------------------

sub dirname {
   my $pathname = shift(@_);
   $_           = fixpath($pathname);
   parse: {
             /^(.+)[\/\\]([^\/\\]*)$/

                && do {
                   return $1;
                };

             /^([\/\\])([^\/\\]*)$/

                && do {
                   return $1;
                };

             /^([^\/\\]*)$/

                && do {
                   return ".";
                };

          }
}

# MyUniqueFileId: 5d2ae091-e40c-43d2-e81f-811e7bdf3ef7
#--------------------------------------------------------------------------------
#
#  Use the appropriate environment variable(s) to figure-out where the home
#  directory of the user is...
#
#  1) Try HOME environment variable
#  2) Try HOMEDRIVE and HOMEPATH environment variables
#  3) Try USERPROFILE environment variable
#
#  see: totebag/src/perl-lib/findHomeDirectory.psub
#
#--------------------------------------------------------------------------------

sub findHomeDirectory {
   my $result = "";
   #---------------------------------------
   #
   #  First try HOME environment variable...
   #
   if ($result eq "") {
      if ( exists $ENV{'HOME'}) {
         $result = $ENV{'HOME'};
         $result =~ tr/\\/\//;
         if ( ! -d $result) {
            $result = "";
         }
      }
   }
   #---------------------------------------
   #
   #  ...then try HOMEDRIVE and HOMEPATH
   #     environment variables...
   #
   if ($result eq "") {
      if ( exists $ENV{'HOMEDRIVE'}) {
         my $HOMEDRIVE = $ENV{'HOMEDRIVE'};
         if ( exists $ENV{'HOMEPATH'}) {
            my $HOMEPATH = $ENV{'HOMEPATH'};
            $result      = "$HOMEDRIVE$HOMEPATH";
            $result      =~ tr/\\/\//;
            if ( ! -d $result) {
               $result = "";
            }
         }
      }
   }
   #---------------------------------------
   #
   #  ...finally try USERPROFILE environment
   #     variables...
   #
   if ($result eq "") {
      if ( exists $ENV{'USERPROFILE'}) {
         $result = $ENV{'USERPROFILE'};
         $result =~ tr/\\/\//;
         if ( ! -d $result) {
            $result = "";
         }
      }
   }
   return $result;
}

# MyUniqueFileId: c58e95af-7811-46b9-ba94-c63e6b2ed7ee
#-------------------------------------------------------------------------------
#
#  Decide where to place tempfiles.
#
#  0) Try the pathname in in the environment variable that
#     was passed as the single parameter.
#  1) Try the pathname in TMPDIR
#  2) Try the pathname in TMP
#  3) Try the pathname in TEMP
#  4) Try ~/tmp (tmp under home directory)
#  5) Try c:<usrProf>\AppData\Local\temp directory
#  6) Try /tmp
#  7) Try /var/tmp
#  8) Try c:\Temp
#  9) Try c:\Windows\Temp
#  10) Try .
#
#  Note that 5, 8, and 9 are only applicable on Windows-like hosts.
#
#  This function uses: findHomeDirectory(),
#                      getOSclass()
#
#  see: totebag/src/perl-lib/findTempDir.psub
#
#-------------------------------------------------------------------------------

sub findTempDir {
   my $envVarName = shift;
   my $tmpdir     = "";

   #---------------------------------------
   #
   #  First try the given environment variable...
   #
   if ($tmpdir eq "") {
      if ($envVarName ne "") {
         if ( exists $ENV{$envVarName}) {
            my $trydir = $ENV{$envVarName};
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
               }
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try TMPDIR environment variable...
   #
   if ($tmpdir eq "") {
      if ( exists $ENV{'TMPDIR'}) {
         my $trydir = $ENV{'TMPDIR'};
         if ( -d $trydir) {
            if ( -w $trydir) {
               $tmpdir = $trydir;
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try TMP environment variable...
   #
   if ($tmpdir eq "") {
      if ( exists $ENV{'TMP'}) {
         my $trydir = $ENV{'TMP'};
         if ( -d $trydir) {
            if ( -w $trydir) {
               $tmpdir = $trydir;
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try TEMP environment variable...
   #
   if ($tmpdir eq "") {
      if ( exists $ENV{'TEMP'}) {
         my $trydir = $ENV{'TEMP'};
         if ( -d $trydir) {
            if ( -w $trydir) {
               $tmpdir = $trydir;
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try tmp subdirectory of the
   #     user's home directory...
   #
   if ($tmpdir eq "") {
      #---------------------------------------
      #
      #  Find the user's home directory
      #
      my $theHomeDir = findHomeDirectory();
      if ($theHomeDir ne "") {
         if ( -d $theHomeDir) {
            my $trydir = $theHomeDir."/tmp";
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
               }
            }
         }
      }
   }

   if ($tmpdir eq "") {
      if (getOSclass() eq "Windows-like") {

         #---------------------------------
         #
         #  ...then try "c:<usrProf>\AppData\Local\Temp"
         #     directory...
         #
         if ( exists $ENV{'USERPROFILE'} ) {
            my $usrProf   = $ENV{'USERPROFILE'};
            if ($usrProf ne "") {
               my $trydir = "$usrProf\\AppData\\Local\\Temp";
               if ( -d $trydir) {
                  if ( -w $trydir) {
                     $tmpdir = $trydir;
                  }
               }
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...then try "/tmp" directory...
   #
   if ($tmpdir eq "") {
      my $trydir = "/tmp";
      if ( -d $trydir) {
         if ( -w $trydir) {
            $tmpdir = $trydir;
         }
      }
   }

   if ($tmpdir eq "") {
      if (getOSclass() eq "Windows-like") {

         #---------------------------------
         #
         #  ...then try "c:\Temp" directory...
         #
         if ($tmpdir eq "") {
            my $trydir = "c:\\Temp";
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
               }
            }
         }

         #---------------------------------
         #
         #  ...then try "c:\Windows\Temp" directory...
         #
         if ($tmpdir eq "") {
            my $trydir = "c:\\Windows\\Temp";
            if ( -d $trydir) {
               if ( -w $trydir) {
                  $tmpdir = $trydir;
               }
            }
         }
      }
   }

   #---------------------------------------
   #
   #  ...finally try "." directory...
   #
   if ($tmpdir eq "") {
      my $trydir = ".";
      if ( -w $trydir) {
         $tmpdir = $trydir;
      }
   }

   return $tmpdir;
}

# MyUniqueFileId: dde1497c-fc31-40f3-d176-bec0f0a9de83
#-------------------------------------------------------------------------------
#
#  This little function is used to deal with indented "here" documents. It
#  just strips away leading spaces/tabs up to and including a vertical bar.
#
#  see: totebag/src/perl-lib/fixIndentStuff.psub
#
#-------------------------------------------------------------------------------

sub fixIndentStuff {
   my $tmp = shift;
   $tmp    =~ s/^\|?[ \t]*\|//gm;
   return $tmp;
}

# MyUniqueFileId: 2e9bd476-985f-408b-feb6-4fdb9639eed5
#-------------------------------------------------------------------------------
#
#  "Fixing" a pathname. This gets rid of excess dots and such that don't
#  make any difference but are hard to read.
#
#  Note that this function uses: getOSclass()
#
#  see: totebag/src/perl-lib/fixpath.psub
#
#-------------------------------------------------------------------------------

sub fixpath {
   my $pathname = shift;
   my $result   = "";
   my $abslash;
   my $useslash;
   if (getOSclass() eq "UNIX-like") {
      $useslash = "/";
   }
   else {
      $useslash = "\\";
   }
   if ($pathname ne "") {
      if ($pathname eq ".") {
         #---------------------------------------
         #
         #  Trivial "."
         #
         $result = ".";
      }
      elsif (($pathname eq "/") || ($pathname eq "\\")) {
         #---------------------------------------
         #
         #  Trivial "/"
         #
         $result = $pathname;
      }
      else {
         #---------------------------------------
         #
         #  If non-trivial first get rid of repeated slashes (/)...
         #
         $pathname =~ s![/\\][/\\]*!$useslash!;
         #---------------------------------------
         #
         #  Note if absolute or relative. If absolute
         #  then toss the leading slash for now...
         #
         if ( $pathname =~ /^\//) {
            $pathname =~ s!^/!!;
            $absolute = 1;
            $abslash  = "/";
         }
         elsif ( $pathname =~ /^\\/) {
            $pathname =~ s!^\\!!;
            $absolute = 1;
            $abslash  = "\\";
         }
         else {
            $absolute = 0;
            $abslash  = "";
         }
         #---------------------------------------
         #
         #  Split the pathname up into components...
         #
         @components = split(/[\/\\]/,$pathname);
         #---------------------------------------
         #
         #  Scan for single dots and remove them...
         #
         $changed = 1;
         while ($changed) {
            $changed = 0;
            my $j;
            for ($j=0; $j<=$#components; $j+=1) {
               if ($components[$j] eq ".") {
                  splice(@components,$j,1);
                  $changed = 1;
               }
            }
         }
         #---------------------------------------
         #
         #  Scan for double dots and resolve them...
         #
         if (1 <= $#components) {
            $changed = 1;
            while ($changed) {
               $changed = 0;
               if ($absolute && ($components[0] eq "..")) {
                  splice(@components,0,1);
                  $changed = 1;
               }
               else {
                  my $j;
                  for ($j=1; $j<=$#components; $j+=1) {
                     if (($components[$j] eq "..") && ($components[$j-1] ne "..")) {
                        splice(@components,$j-1,2);
                        $changed = 1;
                     }
                  }
               }
            }
         }
         #
         #  Output what we've found...
         #
         if ($#components < 0) {
            if ($absolute) {
               $result = $abslash;
            }
            else {
               $result = ".";
            }
         }
         else {
            if ($absolute) {
               $result = $abslash;
            }
            else {
               $result = "";
            }
            my $j;
            for ($j=0; $j<=$#components; $j+=1) {
               if (0 < $j) {
                  $result = $result . $useslash;
               }
               $result = $result . $components[$j];
            }
         }
      }
   }
   return $result;
}

# MyUniqueFileId: 14888b4a-e281-4663-9f7c-63017caea3ca
#-------------------------------------------------------------------------------
#
#  Get the OS class.
#
#  This function is used to determine the OS class of of the host system.
#
#  Returns: Any of:
#
#              "UNIX-like"
#              "Windows-like"
#              "unknown" (failure)
#
#  see: totebag/src/perl-lib/getOSclass.psub
#
#-------------------------------------------------------------------------------

sub getOSclass {
   my $result;
   #---------------------------------------
   #
   #  First try to use a (fast) direct
   #  method...
   #
   my $theOSname = $^O;
   if ($theOSname =~ /^linux$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^MSWin32$/) {
      $result = "Windows-like";
   }
   elsif ($theOSname =~ /^darwin$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^freebsd$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^solaris$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^aix$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^dec_osf$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^hpux$/) {
      $result = "UNIX-like";
   }
   elsif ($theOSname =~ /^irix$/) {
      $result = "UNIX-like";
   }
   else {
      #---------------------------------------
      #
      #  The hard way...
      #
      #  If it isn't directly known, try to
      #  figure it out the hard way. UNIX-like
      #  hosts use colons (:) as the separator
      #  in PATH, but Windows-like hosts use
      #  semicolons (;).
      #
      #  Note: Must check for semicolons first
      #        (Windows) as Windows may have
      #        colons too as drive letter
      #        separators.
      #
      if ( defined $ENV{'PATH'} ) {
         my $tmpPath = $ENV{'PATH'};
         if ($tmpPath =~ /;/) {
            $result = "Windows-like";
         }
         elsif ($tmpPath =~ /:/) {
            $result = "UNIX-like";
         }
         else {
            $result = "unknown";
         }
      }
      else {
         $result = "unknown";
      }
   }
   return $result;
}

# MyUniqueFileId: c01f73fc-3153-477a-c68b-cbb74bc9526f
#-------------------------------------------------------------------------------
#
#  Get the current working directory.
#
#  This function is used to determine the current working directory. Note
#  that this sort of thing is generally supplied by a standard module but
#  Perl installations have been sometimes found to lack this (rarely but...).
#  Note that this does this operation the hard way.
#
#  This function uses: findHomeDirectory(),
#                      findTempDir(),
#                      getOSclass(),
#
#  see: totebag/src/perl-lib/getWorkingDirectory.psub
#
#-------------------------------------------------------------------------------

sub getWorkingDirectory {
   my $callerIs = shift;
   print STDERR "getWorkingDirectory[ starting...\n" if $debugging;
   my $exitCode;
   my $gives;
   my $tmpdir   = findTempDir("");
   my $osClass  = getOSclass();
   if ($osClass eq "UNIX-like") {
      print STDERR "getWorkingDirectory: ...UNIX-like\n" if $debugging;
      my $tmpFile = "$tmpdir/pwd-$$.tmp";;
      print STDERR "getWorkingDirectory: ...run: [pwd 2>$tmpFile]\n" if $debugging;
      $gives      = `pwd 2>$tmpFile`;
      $exitCode   = $? + 0;
      chomp $gives;
      unlink $tmpFile if -f $tmpFile;
   }
   elsif ($osClass eq "Windows-like") {
      print STDERR "getWorkingDirectory: ...Windows-like\n" if $debugging;
      my $tmpFile = "$tmpdir\\pwd-$$.tmp";
      $gives      = `cd 2>$tmpFile`;
      print STDERR "getWorkingDirectory: ...run: [cd 2>$tmpFile]\n" if $debugging;
      $exitCode   = $? + 0;
      chomp $gives;
      unlink $tmpFile if -f $tmpFile;
   }
   else {
      $gives    = "";
      $exitCode = 1;
   }
   if ($exitCode != 0) {
      print STDERR "$callerIscan't determine current working directory\n";
      $gives = "";
   }
   print STDERR "getWorkingDirectory] ...done(=\"".$gives."\")\n" if $debugging;
   return $gives;
}

# MyUniqueFileId: d9ff6301-50cf-45f8-ec93-88caac284048
#-------------------------------------------------------------------------------
#
#  This function is used to join pathname fragments or component to form a
#  single pathname. The result is normalized.
#
#  This function uses: basename(),
#                      fixpath(),
#                      getOSclass()
#
#  see: totebag/src/perl-lib/joinpath.psub
#
#-------------------------------------------------------------------------------

sub joinpath {
   my @theComponents  = @_;
   my $Ncomponents    = $#theComponents + 1;
   my $wasSpecialCase = 0;
   my $result;

   if ($Ncomponents == 2) {
      my $Lpart = $theComponents[0];
      my $Rpart = $theComponents[1];
      if ($Lpart eq ".") {
         my $bn = basename($Rpart);
         if ($Rpart eq $bn) {
            if (getOSclass() eq "UNIX-like") {
               $result      = $Lpart."/".$Rpart;
            }
            else {
               $result      = $Lpart."\\".$Rpart;
            }
            $wasSpecialCase = 1;
         }
      }
   }

   if ( ! $wasSpecialCase) {
      $result = $theComponents[0];
      if (0 < $#theComponents) {
         my $i;
         for ($i=1; $i<=$#theComponents; ++$i) {
            my $component = $theComponents[$i];
            if (getOSclass() eq "UNIX-like") {
               if ($component =~ "^/") {
                  $result = $component;
               }
               else {
                  $result = $result."/".$component;
               }
            }
            else {
               if ($component =~ '^\\\\') {
                  $result = $component;
               }
               else {
                  $result = $result."\\".$component;
               }
            }
            $result = fixpath($result);
         }
      }
      else {
         $result = fixpath($result);
      }
   }
   return $result;
}

# MyUniqueFileId: 1bcb3952-6c59-4cbf-b8de-fb66028261f3
#-------------------------------------------------------------------------------
#
#  Use the path to locate an executable.
#
#  This function uses the array of directory pathnames that had been previously
#  extracted from the PATH environment variable to locate an executable with
#  the given name. The caller is expected to supply the name of the executable
#  (a reference to) the @myPath array, and the osClass (see getOSclass() function).
#
#  Parameters: The executable name (basename with or without .exe extension)
#              A reference to an array of directory pathnames (from PATH).
#              The OS class ("UNIX-like" or "Windows-like").
#
#  Uses: joinpath
#
#  see: totebag/src/perl-lib/lookForExecutable.psub
#
#-------------------------------------------------------------------------------

sub lookForExecutable {
   my ($theName,$myPathRef,$osClass) = @_;
   my @myPath      = @{$myPathRef};
   print STDERR "lookForExecutable[ theName=[$theName], myPath=..., osClass=[$osClass]...\n" if $debugging;
   my $usePathname = "";
   if ($osClass eq "Windows-like") {
      print STDERR "lookForExecutable: ...host is Windows-like\n" if $debugging;
      my $i;
      for ($i=0; $i<=$#myPath; $i+=1) {
         my $pathname = joinpath($myPath[$i],$theName.".exe");
         print STDERR "lookForExecutable:    consider [$pathname]\n" if $debugging;
         if (-f $pathname) {
            print STDERR "lookForExecutable:    ...found\n" if $debugging;
            $usePathname = $pathname;
            last;
         }
      }
   }
   elsif ($osClass eq "UNIX-like") {
      print STDERR "lookForExecutable: ...host is UNIX-like\n" if $debugging;
      my $i;
      for ($i=0; $i<=$#myPath; $i+=1) {
         my $pathname = joinpath($myPath[$i],$theName);
         print STDERR "lookForExecutable:    consider [$pathname]\n" if $debugging;
         if (-f $pathname) {
            if (-x $pathname) {
               print STDERR "lookForExecutable:    ...found\n" if $debugging;
               $usePathname = $pathname;
               last;
            }
         }
      }
   }
   else {
      print STDERR "lookForExecutable: ...host is not Windows- or UNIX-like\n" if $debugging;
      $usePathname = "";
   }
   print STDERR "lookForExecutable] ...done(=[$usePathname]\n" if $debugging;
   return $usePathname;
}

# MyUniqueFileId: 28f944a3-7816-48a9-ece1-7c8281e5cf68
#-------------------------------------------------------------------------------
#
#  Convert pathname to a native form.
#
#  This function is used to convert the given pathname to a form appropriate
#  for this class of system (UNIX- or Windows-like).
#
#  This function uses: getOSclass(),
#                      makePathUNIXlike(),
#                      makePathWindowslike()
#
#  see: totebag/src/perl-lib/makePathNative.psub
#
#-------------------------------------------------------------------------------

sub makePathNative {
   my $pathname   = shift;
   my $result;
   my $theOsClass = getOSclass();
   if ($theOsClass eq "UNIX-like") {
      $result = makePathUNIXlike($pathname);
   }
   elsif ($theOsClass eq "Windows-like") {
      $result = makePathWindowslike($pathname);
   }
   else {
      $result = "";
   }
   return $result;
}

# MyUniqueFileId: eae774dc-5ad0-4907-c3cc-2118873fdcb7
#-------------------------------------------------------------------------------
#
#  Translate all backslashes in the given pathname to forward slashes. Thus
#  converting it to a UNIX-like style.
#
#  see: totebag/src/perl-lib/makePathUNIXlike.psub
#
#-------------------------------------------------------------------------------

sub makePathUNIXlike {
   my $pathname = shift;
   $pathname    =~ tr/\\/\//;
   return $pathname;
}

# MyUniqueFileId: b27b57d9-57b2-4cfe-aa34-1af9efb86152
#-------------------------------------------------------------------------------
#
#  Translate all forward slashes in the given pathname to backslashes. Thus
#  converting it to a Windows-like style.
#
#  see: totebag/src/perl-lib/makePathWindowslike.psub
#
#-------------------------------------------------------------------------------

sub makePathWindowslike {
   my $pathname = shift;
   $pathname    =~ tr/\//\\/;
   return $pathname;
}

# MyUniqueFileId: b90a4088-bb21-40f6-a8be-7ef0f940fb1b
#-------------------------------------------------------------------------------
#
#  This function is used to create a directory...
#
#     mkDirectory($pathname,$pflag)
#
#        $pathname
#
#           The pathname of the directory which is to be created.
#
#        $pflag
#
#           A flag, set if the parent (grandparent, ...) is to be created
#           if necessary. Analogous to mkdir's -p option.
#
#  Note: this function may call:
#
#           dirname
#
#-------------------------------------------------------------------------------

sub mkDirectory {
   my $pathname = shift;
   my $pFlag    = shift;
   my $sponsor  = shift;

   my $result;
   if ( -e $pathname) {
      if ( -d $pathname) {
         $result = 1;
      }
      else {
         $result = 0;
      }
   }
   else {
      if ($pFlag) {
         my $haveParent;
         my $Dname = dirname(pathname);
         if ( -d $Dname) {
            $haveParent = 1;
         }
         else {
            $haveParent = mkDirectory($Dname);
         }
         if ($haveParent) {
            $result = mkdir($pathname,0777);
         }
         else {
            $result = 0;
         }
      }
      else {
         $result = mkdir($pathname,0777);
      }
   }
   return result;
}

# MyUniqueFileId: 6af5ed70-509a-46e3-c366-c864743c9ac3
#-------------------------------------------------------------------------------
#
#  This subroutine deletes a single pathname (directory, file, or symbolic-link)
#  If it can't be properly deleted then it will fail with an error message.
#
#  see: totebag/src/perl-lib/mustDeletePathname.psub
#
#-------------------------------------------------------------------------------

sub mustDeletePathname {
   my $callerIs  = shift;
   my $pathname  = shift;
   print STDERR "mustDeletePathname[ callerIs=\"".$callerIs."\", pathname=\"".$pathname."\"...\n" if $debugging;
   my $result    = 1;
   if ($pathname ne "") {
      my @failures  = deletePathnames($pathname);
      my $Nfailures = $#failures + 1;
      if (1 <= $Nfailures) {
         $result = 0;
         my $count;
         my $failedOn;
         foreach $failedOn (@failures) {
            $count += 1;
            print STDERR $callerIs."error -- can't delete \"$failedOn\"\n";
            if (10 <= $count) {
               print STDERR $callerIs."  :        :     :\n";
               my $lastOne = $failures[$#failures];
               print STDERR $callerIs."error -- can't delete \"$lastOne\"\n";
               last;
            }
         }
         exit 1;
      }
   }
   else {
      $result = 0;
   }
   print STDERR "mustDeletePathname] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: 5ff433a4-57d8-46b9-fd0c-b4cdb3cc330d
#-------------------------------------------------------------------------------
#
#  Convert canonical pathname to native pathname.
#
#     This function is used to convert the given pathname from the UNIX-style
#     canonical form (with forward slashes) to the native form (which on
#     Windows-like systems uses backslashes). It will also strip unneeded
#     enclosing quotes or add enclosing quotes if they're needed.
#
#  This function uses: makePathNative()
#
#  see: totebag/src/perl-lib/nativePathname.psub
#
#-------------------------------------------------------------------------------

sub nativePathname {
   my $canonical = shift;
   my $native    = $canonical;
   #
   #  Strip enclosing quotes (if any)
   #
   if ($native =~ /^"(.*)"$/) {
      $native = $1;
   }
   #
   #  Translate to the native form
   #
   $native    = makePathNative($native);
   #
   #  (re)wrap with quotes if the
   #  pathname contains spaces.
   #
   if ($native =~ /\s/) {
      $native = "\"".$native."\"";
   }
   return $native;
}

# MyUniqueFileId: 37ea004f-1e46-4707-d3fd-2f830492fbae
#-------------------------------------------------------------------------------
#
#  Return pathname of null device.
#
#  This is the pseudo-file which absorbs but doesn't preserve characters. When
#  read it always returns EOF. On UNIX-like systems this is "/dev/null" but on
#  Windows-like systems this is simply "nul" (case insensitive). On any other
#  system (not UNIX- or Windows-like) an empty string is returned.
#
#  This function uses: getOSclass()
#
#  see: totebag/src/perl-lib/nullPathname.psub
#
#-------------------------------------------------------------------------------

sub nullPathname {
   my $result;
   my $theOSclass = getOSclass();
   if ($theOSclass eq "UNIX-like") {
      $result = "/dev/null";
   }
   elsif ($theOSclass eq "Windows-like") {
      $result = "nul";
   }
   else {
      $result = "";
   }
   return $result;
}

# MyUniqueFileId: 3c057bb8-8eba-4030-b741-8d0a25a3b1f5
#-------------------------------------------------------------------------------
#
#  "Quoting" a pathname. This function returns a copy of the given pathname
#  with quotes if the given pathname contains any "special" characters.
#
#-------------------------------------------------------------------------------

sub quoteIfReqd {
   my $pathname     = shift;
   my $told_osStyle = shift;
   my $result       = "";
   if ($pathname ne "") {
      if ($told_osStyle eq "") {
         $told_osStyle = getOSclass();
      }
      if ($told_osStyle eq "UNIX-like") {
         $_      = $pathname;
                   s/(['"`<>|;\s()\[\]\?\#\$^&\*=\\])/\\$1/g;
         $result = $_;
      }
      else {
         $_      = $pathname;
                   s/(['"<>|\s()^&@])/\\$1/g;
         $result = $_;
      }
   }
   return $result;
}

# MyUniqueFileId: cc8ac2e4-bd0d-4c17-c64a-e852bed0d90f
#-------------------------------------------------------------------------------
#
#  This subroutine deletes a single pathname (directory, file, or symbolic-link)
#  If it can't be properly deleted then it will produce a warning message.
#
#  see: totebag/src/perl-lib/shouldDeletePathname.psub
#
#-------------------------------------------------------------------------------

sub shouldDeletePathname {
   my $callerIs  = shift;
   my $pathname  = shift;
   print STDERR "shouldDeletePathname[ callerIs=\"".$callerIs."\", pathname=\"".$pathname."\"...\n" if $debugging;
   my $result    = 1;
   if ($pathname ne "") {
      my @failures  = deletePathnames($pathname);
      my $Nfailures = $#failures + 1;
      if (1 <= $Nfailures) {
         $result = 0;
         my $count;
         my $failedOn;
         foreach $failedOn (@failures) {
            $count += 1;
            print STDERR $callerIs."warning -- can't delete \"$failedOn\"\n";
            if (10 <= $count) {
               print STDERR $callerIs."   :         :     :\n";
               my $lastOne = $failures[$#failures];
               print STDERR $callerIs."warning -- can't delete \"$lastOne\"\n";
               last;
            }
         }
      }
   }
   else {
      $result = 0;
   }
   print STDERR "shouldDeletePathname] ...done(=$result)\n" if $debugging;
   return $result;
}

# MyUniqueFileId: 7b1bd298-6cb1-478a-8d02-9eee62a15d0a
#-------------------------------------------------------------------------------
#
#  This function is used to read a given file returning the contents of
#  the ENTIRE FILE as an array of strings (retaining all embedded whitespace).
#
#-------------------------------------------------------------------------------

sub slurpPathnameIntoArray {
   my $pathname  = shift;
   my $sponsor   = shift;
   my @contents;
   if ( open(F, "< $pathname") ) {
      while (<F>) {
         chomp;
         $contents[$#contents+1] = $_;
      }
      close F;
   }
   else {
      if ($sponsor ne "") {
         print STDERR $sponsor.": can't find/read \"$pathname\"\n" if $sponsor ne "";
         exit 1;
      }
   }
   return @contents;
}

# MyUniqueFileId: d10a2ee1-2593-4a09-fd40-f6314a9dd348
#-------------------------------------------------------------------------------
#
#  This function is used to extract the suffix from a given pathname. Note
#  that this kind of operation is generally available in the File module.
#
#-------------------------------------------------------------------------------

sub suffix {
   my $pathname = shift(@_);
   my $result   = "";
   if ( $pathname =~ /^(.+)(\.[^\/\\.]+)$/ ) {
      $result = $2;
   }
   else {
      $result = "";
   }
   return $result;
}

# MyUniqueFileId: 31fb3037-130d-4150-fe5e-d0e8e636135e
#-------------------------------------------------------------------------------
#
#  Unquote a string (generally a pathname). Returns a copy of the given string
#  with any enclosing quotes (double or single) removed.
#
#-------------------------------------------------------------------------------

sub unquote {
   my $given  = shift;
   my $result = "";
   if ($given =~ /^"(.*)"$/) {
      $result = $1;
   }
   elsif ($given =~ /^'(.*)'$/) {
      $result = $1;
   }
   else {
      $result = $given;
   }
   return $result;
}

# MyUniqueFileId: 4a1ca40a-2769-45a8-dd88-74686e4806a7
#-------------------------------------------------------------------------------
#
#  This is the subroutine which generates help output for the mkinstaller
#  tool itself. Somehow we've got to merge common functionality with html
#  the replicated work is just awful.
#
#-------------------------------------------------------------------------------

sub help {
   print fixIndentStuff(<<"EOF1");
   |
   |mkinstaller(1x)                                                  mkinstaller(1x)
   |
   |NAME
   |    mkinstaller -- Generate self-extracting installer.
   |
   |USAGE
   |    mkinstaller --copyright
   |    mkinstaller --help
   |    mkinstaller --html <pathname>
   |    mkinstaller --vernum
   |    mkinstaller --version
   |
   |    mkinstaller [<options> ...] <pathname> ...
   |
   |DESCRIPTION
   |    This script is used to generate an "installer" script implemented as
   |    a Bourne-shell script on UNIX-like systems (such as Linux or OSX) or
   |    as a binary executable on Windows-like systems. This generated installer
   |    supports a number of options for specifying the where the various
   |    directories are to be installed (prefix directory pathnames).
   |
   |    UNIX-like host
   |
   |       On a UNIX-like host (such as Linux or OSX) the generated installer
   |       script is implemented as a self-extracting Bourne-shell script
   |       carrying a tarball as a payload. mkinstaller requires tar on UNIX-like
   |       hosts.
   |
   |       The installer script construction process:
   |
   |          1) Determination of a suitable temp directory. Much of the work
   |             done by the mkinstaller script is done in a temp directory.
   |          2) Creation of a top level temporary directory under which all
   |             other temporaries will be created. Creation of an "accumulator",
   |             an "intermediate" and a "wrapper" directory in the top level
   |             temp directory. A tarup/untar process will use both the
   |             "intermediate" and "accumulator" directories to merge given
   |             directories with the same basename. The "wrapper" directory
   |             will be used to carry the individual directory tarballs.
   |          3) From each of the specified directories to be installed such
   |             as .../bin, .../lib, specified on the mkinstaller command line
   |             tarup the individual directory forming tarballs in the wrapper
   |             directory in the temp directory.
   |          4) Tarup the temporary wrapper directory for eventual inclusion
   |             in the generated installer.
   |          5) Generate the text of the "installer" script in the temporary
   |             directory customizing it with with options for specifying an
   |             overall prefix directory and individual prefixes for each of
   |             the directories specified on the mkinstaller command line.
   |          6) Add the tarball built in (4) to the end of the script generated
   |             in (5) forming the distribution self-extracting installation
   |             script in the directory where mkinstaller was run.
   |          7) Cleanup.
   |
   |          In the end the only product is the desired distribution self-
   |          extracting installation script in the directory where the
   |          mkinstaller command was run. Everything else produced along the
   |          way (directories and files) is considered temporary and is
   |          destroyed.
   |
   |          Note that the name of the installer is specified using the -c <name>
   |          or --create=<name> option to mkinstaller. However if the -c <name>
   |          or --create=<name> option is not used then mkinstaller will try
   |          to come-up with a reasonable name:
   |
   |             1) If the --project-name=<name> and --project-version=<version>
   |                was used then the name of the generated installer will be:
   |
   |                   <name>-<version>-installer
   |
   |             2) If the --project-name=<name> was used but not the
   |                --project-version option the name of the generated
   |                installer will be:
   |
   |                   <name>-installer
   |
   |             3) If neither the --project-name nor the --project-version
   |                option the name of the generated installer will be:
   |
   |                   installer
   |
   |          As is typical for a UNIX-like environment, the generated script
   |          has no extension.
   |
   |       How the generated installer script works on a UNIX-like target:
   |
   |          1) The installer script locates itself. This may seem to be an
   |             obvious and or silly question but the actual location of the
   |             script file is necessary for the actual extraction (the script
   |             file must be read by the standard "tail" utility).
   |          2) Determination of a suitable temp directory. Much of the work
   |             done by the generated installer script is done in a temp
   |             directory. Creation of a top level temporary directory under
   |             which all other temporaries will be created. This temp
   |             directory is created under the standard temp directory
   |             determined at the start of this step (see NOTES).
   |          3) PREFIX and PREFIX_xxx values are established from command
   |             line options. If appropriate options aren't supplied to
   |             install all directories then the installer script will propmpt
   |             for the necessary pathname(s). The installer script will
   |             create the directories if necessary.
   |          4) The tarball embedded in the installer script is extracted from
   |             the installer script into the temp directory created in (2).
   |          5) The tarball in (4) is unwrapped revealing one or more tarballs
   |             (one for each installation directory such as bin.tar.gz/
   |             include.tar.gz/ lib.tar.gz/ ...). If a pre-install script was
   |             supplied to mkinstaller when the generated installer script
   |             was produced then it will be revealed at this time. Similarly
   |             if a post-install script was supplied to mkinstaller when the
   |             generated installer script was produced then it will also be
   |             revealed at this time. Note that neither of these scripts if
   |             supplied and revealed are actually executed in this step. See
   |             steps (6) and (8).
   |          6) If (5) revealed a pre-install script then it will be executed
   |             by the approptiate interpreter. Note that each of the PREFIX
   |             directories will be supplied as an option to this pre-install
   |             script (such as --prefix_bin=<pathname>). Also note at this time
   |             the individual tarballs representing the directories to install
   |             have NOT be unwrapped.
   |          7) Each individual tarball revealed in (5) is unwrapped into the
   |             approperiate PREFIX directory overlying anything already
   |             there.
   |          8) If (5) revealed a post-install script then it will be executed
   |             by the approptiate interpreter. Note that each of the PREFIX
   |             directories will be supplied as an option to this post-install
   |             script (such as --prefix_bin=<pathname>).
   |          9) Cleanup.
   |
   |    Windows-like host
   |
   |       On a Windows-like host (such as Windows 7) the generated installer
   |       is implemented as a binary execurable which is actually generated
   |       under the covers by NSIS (Nullsoft Scripted Install System).
   |
   |       The installer construction process:
   |
   |          1) Determination of a suitable temp directory. Much of the work
   |             done by the mkinstaller script is done in a temp directory.
   |          2) Generation of a .nsi script file.
   |          3) MakeNSIS is used to "compile" the .nsi script forming a
   |             .exe binary executable.
   |
   |          The .exe binary executable formed in step (3) is the product of the
   |          mkinstaller script and may be shipped to customers to perform the
   |          desired installation on their Windows system.
   |
   |          Note that the name of the installer is specified using the -c <name>
   |          or --create=<name> option to mkinstaller. However if the -c <name>
   |          or --create=<name> option is not used then mkinstaller will try
   |          to come-up with a reasonable name:
   |
   |             1) If the --project-name=<name> and --project-version=<version>
   |                was used then the name of the generated installer will be:
   |
   |                   <name>-<version>-installer.exe
   |
   |             2) If the --project-name=<name> was used but not the
   |                --project-version option the name of the generated
   |                installer will be:
   |
   |                   <name>-installer.exe
   |
   |             3) If neither the --project-name nor the --project-version
   |                option the name of the generated installer will be:
   |
   |                   installer.exe
   |
   |          If the name is specified using the -c <name> or --create=<name>
   |          option then the name should NOT included a .exe extension. The
   |          makensis tool which actually produces the binary executable
   |          will add the necessary extension.
   |
   |       Running the generated installer:
   |
   |          -- The default use of the generated installer will produce a
   |             new directory on the user's desktop.
   |
   |                prompt> installer.exe
   |
   |          -- A different prefix may be specified using the /D option:
   |
   |                prompt> installer.exe /D=E:\bozo\reposit
   |
   |             Note that the prefix directory will be creates as necessary
   |             however the uninstaller will only (recursively delete) the
   |             final directory component. In the above example only
   |             E:\bozo\reposit will be (recursivly deleted, but the
   |             directory E:\bozo will be left intact.
   |
   |       Note that the generated installer will pop-up a progress bar dialog
   |       box to indicate the installation progress.
   |
   |OPTIONS
   |    "mkinstaller" supports the following options:
   |
   |        --copyright
   |
   |            Output copyright and license info to <stdout> and quit.
   |
   |        --help
   |
   |            Output this man page to <stdout> and quit.
   |
   |        --html <pathname>
   |
   |            Output this man page as HTML to the given file pathname and quit.
   |
   |        --vernum
   |
   |            Output version number to <stdout> and quit.
   |
   |        --version
   |
   |            Output version number and revision date to <stdout> and quit.
   |
   |        -c <name>
   |        --create=<name>
   |
   |            The name of the script to generate. It is generally not advisable
   |            to include a suffix (aka. extension) as part of the script name.
   |            Also note that this is not a pathname, is is the simple name of
   |            the script file which is to be created in the current directory.
   |            By default the script will be named "installer".
   |
   |        --cc=<string>
   |
   |            The C compiler name and version number that had been used in
   |            building the software being installed. Note that the string
   |            is expected to a blank separated pair: the name and version
   |            number. The default is the string "- -" (meaning "unknown"
   |            or "don't care"). For example:
   |
   |                --cc="gcc 4.5.1"
   |
   |            Note that at this time only the C compiler name is used. This
   |            option has been replaced by the --CC=<name> and --CC-options=<string>
   |            options.
   |
   |        --cxx=<string>
   |
   |            The C++ compiler name and version number that had been used
   |            in building the software being installed. Note that the string
   |            is expected to a blank separated pair: the name and version
   |            number. The default is the string "- -" (meaning "unknown"
   |            or "don't care"). For example:
   |
   |                --cxx="g++ 4.5.1"
   |
   |            Note that at this time only the C++ compiler name is used. This
   |            option has been replaced by the --CXX=<name> and --CXX-options=<string>
   |            options.
   |
   |        CC=<name>
   |        --CC=<name>
   |
   |            Used to specify the name of the C compiler used. If a pathname
   |            is supplied, only the basename will be used. For historical
   |            reasons the leading double-dash is optional.
   |
   |        CC-options=<string>
   |        --CC-options=<string>
   |
   |            Used to specify the options to be used with the C compiler used.
   |            Only special options such as the language standard assumed are
   |            to be specified. Define -D<name>, include pathname -I<pathname>,
   |            and library pathname -L<pathname> (along with library names) are
   |            not normally used. The normal compile-only option -c is used by
   |            default. Note that the <string> of options should be quoted.
   |            For historical reasons the leading double-dash is optional.
   |
   |        CXX=<name>
   |        --CXX=<name>
   |
   |            Used to specify the name of the C++ compiler used. If a pathname
   |            is supplied, only the basename will be used. For historical
   |            reasons the leading double-dash is optional.
   |
   |        CXX-options=<string>
   |        --CXX-options=<string>
   |
   |            Used to specify the options to be used with the C++ compiler used.
   |            Only special options such as the language standard assumed are
   |            to be specified. Define -D<name>, include pathname -I<pathname>,
   |            and library pathname -L<pathname> (along with library names) are
   |            not normally used. The normal compile-only option -c is used by
   |            default. Note that the <string> of options should be quoted.
   |
   |        --contact=<address>
   |
   |            A contact email address. There is no default contact address.
   |
   |        -d
   |        --debug
   |
   |            Produce extra output useful when debugging the "mkinstaller"
   |            script itself.
   |
   |        --follow
   |
   |            Follow symbolic links for directory pathnames to will be
   |            embedded as tarballs within the generated installer script.
   |            By default such symbolic links are not permitted.
   |
   |            Note that Windows-like systems do not support symbolic-links.
   |
   |        --fortran=<string>
   |
   |            The FORTRAN compiler name and version number that had been
   |            used in building the software being installed. Note that the
   |            string is expected to a blank separated pair: the name and
   |            version number. The default is the string "- -" (meaning
   |            "unknown" or "don't care").
   |
   |            Example:
   |
   |            --fortran="gfortran 4.5.1"
   |
   |        --intermediate-dir=<name>
   |        --version-dir=<name>
   |
   |            Use the given simple name as an intermediate directory name
   |            (aka. a version directory name) to be added under the PREFIX
   |            directory pathname as given to the installer at installation
   |            time in to which the directories will be installed. The
   |            default is no such intermediate directory, the installations
   |            will be done in the PREFIX directory as given at installation
   |            time.
   |
   |        --nofollow
   |
   |            Don't follow symbolic links for directory pathnames to will be
   |            embedded as tarballs within the generated installer script.
   |            When such symbolic-links are detected and error message will
   |            be produced and the script will terminate (after cleaning-up).
   |            This is the default behavior.
   |
   |            Note that Windows-like systems do not support symbolic-links.
   |
   |        --nosha
   |
   |            Don't generate a SHA hash file for the generated script. This
   |            is the default behaviour.
   |
   |        --nonstd
   |
   |            Don't bother with any search for standard directory names such
   |            as bin, lib, or include, (see the --std option). Instead just
   |            simply use the directory pathname as given. Note that such a
   |            search would only done when the given directory pathnames don't
   |            include those with standard base names as bin, lib, or include.
   |
   |        --os=<string>
   |
   |            The OS on the system on which the installer is being generated.
   |            This string is encoded in the installer script as an aid in
   |            determining if the generated script is applicable to the
   |            system where it is run. The default is to use uname -s and
   |            uname -r to determine this string.
   |
   |        --postinstall-binary=<pathname>
   |
   |            The pathname of a binary executable which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |        --postinstall-perl=<pathname>
   |
   |            The pathname of a Perl script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |            Such post-install Perl scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --postinstall-python=<pathname>
   |
   |            The pathname of a Python script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |            Such post-install Python scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --postinstall-sh=<pathname>
   |
   |            The pathname of a Bourne-shell script which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer after all of the payload directories have been
   |            extracted and installed.
   |
   |            Such post-install Bourne-shell scripts are not generally
   |            supported on Windows systems as the Bourne-shell is not
   |            generally found on Windows systems.
   |
   |        --preinstall-binary=<pathname>
   |
   |            The pathname of a binary executable which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |        --preinstall-perl=<pathname>
   |
   |            The pathname of a Perl script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |            Such pre-install Perl scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --preinstall-python=<pathname>
   |
   |            The pathname of a Python script which is to be included with
   |            the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |            Such pre-install Python scripts are not generally supported
   |            on Windows systems as Perl is not generally found on Windows
   |            systems.
   |
   |        --preinstall-sh=<pathname>
   |
   |            The pathname of a Bourne-shell script which is to be included
   |            with the installer's payload. It will be run by the generated
   |            installer before all of the payload directories have been
   |            extracted and installed.
   |
   |            Such pre-install Bourne-shell scripts are not generally
   |            supported on Windows systems as the Bourne-shell is not
   |            generally found on Windows systems.
   |
   |        --prjnam=<name>
   |        --project-name=<name>
   |
   |            The name of the project to be installed by the generated
   |            installer script. There is no default project name.
   |
   |        --prjver=<A>.<B>[.<C>[.<D>]][<suffix>]
   |        --project-version=<A>.<B>[.<C>[.<D>]][<suffix>]
   |
   |            The version number of the project to be installed by the
   |            generated installer script. Note that the given version number
   |            is expected to have 2, 3, or 4 dot-separated numeric components
   |            and an optional suffix. If the --project-version option is used
   |            then the --project-version option must also be used. There is
   |            no default project version number.
   |
   |        --sha-1
   |        --sha-160
   |        --sha-256
   |        --sha-384
   |        --sha-512
   |
   |            Generate a SHA hash of the generated script. The hash file
   |            will have the same name as the generated script but with an
   |            added ".sha-nnn" suffix (where nnn is one of 1, 160, 256,
   |            384, or 512). Note that --sha-1 and --sha-160 are synonymous.
   |
   |        --std
   |
   |            If none of the given directory pathnames have basenames such
   |            as bin, lib, or include then look for immediate subdirectories
   |            of the given directory pathnames with such basenames. If any
   |            have such standard base names then replace the given directory
   |            pathname with all of the immediate subdirectory pathnames. See
   |            the --nonstd option.
   |
   |        -v[<digit>]
   |        --verbose[<digit>]
   |
   |            Operate in a verbose mode.
   |
   |            Repeating this option increases the amount of output produced.
   |            Note that the option may end with an optional digit which
   |            indicates a repetition count. Thus the option:
   |
   |               -v3
   |
   |            is equavalent to:
   |
   |               -v -v -v
   |
   |        -w <pathname>
   |        --with-notice=<pathname>
   |
   |            The pathname of a textfile which contains the copyright
   |            notice that is to be output by the generated installer script
   |            when the installer's --copyright option is used. By default
   |            the generated installer doesn't support a --copyright option.
   |
   |        --with-payload
   |
   |            Include the payload with the generated script. This results
   |            in a useful installer script that will actually install the
   |            supplied directories under the indicated prefix directory (see
   |            the --prefix=... and the --intermediate-dir=... options. This
   |            is the default behavior.
   |
   |        --without-payload
   |
   |            Don't include the payload with the generated script. This
   |            results in an ineffective installer script that won't actually
   |            install anything. It does however go through much of the other
   |            parts of the process and so may be an aid when debugging the
   |            generated installer.
   |
   |        <pathname>
   |
   |            The pathnames of one or more directories which will be
   |            embedded as tarballs within the generated installer script.
   |            Typical directory basenames are: bin, include, lib, ... Note
   |            that at least one such directory pathname is required.
   |
   |            The basename of this pathname may not contain any spaces or
   |            tabs however the directory component (if any) may.
   |
   |RETURNS
   |    "mkinstaller" returns the standard exit codes:
   |
   |       0 -- success
   |       1 -- failure
   |
   |ENVIRONMENT
   |    "mkinstaller" refers to the following environment variables:
   |
   |        DEBUG_mkinstaller
   |
   |            Generate extra output which is only usefull when debugging the
   |            "mkinstaller" script itself.
   |
   |        INEFFECTIVE_mkinstaller
   |
   |            If this environment variable has been set then the generated
   |            script will lack a payload and may not even be runable. Note
   |            that this feature is almost never used except when debugging
   |            the script generation process.
   |
   |        MKINSTALLER_TMPDIR
   |
   |            Consider this pathname before considering TMPDIR (see
   |            step (0) in the NOTES section below).
   |
   |INPLEMENTATION
EOF1
   if ($OSclass eq "Windows-like") {
      print "    \"mkinstaller\" is implemented as a Perl script that is wrapped in\n";
      print "    a binary executable to avoid any Windows registry entanglements.\n";
   }
   else {
      print "    \"mkinstaller\" is implemented as a Perl script.\n";
   }
   print fixIndentStuff(<<"EOF2");
   |
   |SEE ALSO
   |    makensis(1), NSIS, pshaw(1x), sh(1), sha1sum(1), sha256sum(1), sha384sum(1), sha512sum(1), tar(1)
   |
   |NOTES
   |    The directory where temporary files are to be placed is determined
   |    as follows:
   |
   |        0) If MKINSTALLER_TMPDIR is defined and is not empty then
   |           consider its value as a directory pathname. If this pathname
   |           exists and is a directory and is writable then temporary
   |           files will be placed in this directory. Otherwise...
   |        1) If TMPDIR is defined and is not empty then consider its
   |           value as a directory pathname. If this pathname exists
   |           and is a directory and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        2) If TMP is defined and is not empty then consider its
   |           value as a directory pathname. If this pathname exists
   |           and is a directory and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        3) If TEMP is defined and is not empty then consider its
   |           value as a directory pathname. If this pathname exists
   |           and is a directory and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        4) If the user's home directory can be determined and if
   |           this home directory contains a subdirectory named tmp
   |           that is itself writable then temporary files will be
   |           placed in this directory. Otherwise...
   |        5) If "C:<userProfile>\\AppData\\Local\\temp" exists and
   |           is a writable directory then temporary files will be
   |           placed in this directory. Otherwise...
   |        6) If "/tmp" exists and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        7) If "/var/tmp" exists and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        8) If "C:\\Temp" exists and is writable then temporary files
   |           will be placed in this directory. Otherwise...
   |        9) If "C:\\Windows\\Temp" exists and is writable then temporary
   |           files will be placed in this directory. Otherwise...
   |       10) If the current directory is writable then temporary files
   |           will be placed in the current directory. Otherwise...
   |       11) A fatal error message will be sent to <stderr> and
   |           the program will exit with a non-zero exit code.
   |
   |    Note that 5, 8, and 9 are only applicable on Windows-like hosts.
   |
   |AUTHOR
   |    Jim Reus (jim.reus\@gmail.com)
   |
   |CONTACT
   |    Please contact:
   |
   |        totebag.help (totebag.help\@gmail.com) with questions.
   |
   |        totebag.bugs (totebag.bugs\@gmail.com) to report problems.
   |
   |        totebag.more (totebag.more\@gmail.com) to request enhancements.
   |
   |
   |    Be sure to provide as much information as possible.
   |
EOF2
   exit 0;
}

# MyUniqueFileId: 86c5676c-f385-41d3-c876-6e18a9b0ea51
#-------------------------------------------------------------------------------
#
#  This is the subroutine which generates help output for the mkinstaller
#  tool itself. Somehow we've got to merge common functionality with html
#  the replicated work is just awful.
#
#-------------------------------------------------------------------------------

sub html {
   my $pathname = shift;
   if (! open(HTML,"> $pathname")) {
      print STDERR "mkinstaller: can't create/write \"$pathname\"\n";
      exit 1;
   }
   print HTML fixIndentStuff(<<"EOF1");
   |<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
   |<html>
   |   <!-- --------------------------------------------------------------------------------------------------------------------------->
   |   <a name="mkinstaller"></a>
   |   <head>
   |      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   |      <meta name="GENERATOR" content="arg 1.7.1">
   |      <link rel="shortcut icon" href="../../icons/myShortcutIcon.png">
   |      <title>mkinstaller - Generate self-extracting installer.</title>
   |   </head>
   |   <body>
   |      <h3>
   |         <center>
   |            <nobr>
   |               mkinstaller (rev. $mkinstaller_ver_name)
   |            </nobr>
   |         </center>
   |      </h3>
   |
   |      <h3>
   |         NAME
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i>&nbsp;-&nbsp;Generate self-extracting installer.
   |      </blockquote>
   |
   |      <h3>
   |         SYNOPSIS
   |      </h3>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--copyright</b>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--help</b>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--html</b>&nbsp;&nbsp;<i>pathname</i>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--vernum</b>
   |      </blockquote>
   |      <blockquote>
   |         <b>mkinstaller</b> <b>--version</b>
   |      </blockquote>
   |      <br>
   |      <blockquote>
   |         <b>mkinstaller</b>
   |         <big>[</big><i>options</i> ...<big>]</big>
   |         <i>pathname</i> ...
   |      </blockquote>
   |      <br>
   |
   |      <h3>
   |         DESCRIPTION
   |      </h3>
   |      <blockquote>
   |         This script is used to generate an "installer" script implemented as
   |         a Bourne-shell script on UNIX-like systems (such as Linux or OSX) or
   |         as a binary executable on Windows-like systems. This generated installer
   |         supports a number of options for specifying the where the various
   |         directories are to be installed (prefix directory pathnames).
   |      </blockquote>
   |      <blockquote>
   |         <b>UNIX-like Host</b>
   |         <blockquote>
   |            On a UNIX-like host (such as Linux or OSX) the generated installer
   |            script is implemented as a self-extracting Bourne-shell script
   |            carrying a tarball as a payload. <i>mkinstaller</i> requires <i>tar</i> on UNIX-like
   |            hosts.
   |         </blockquote>
   |         <blockquote>
   |            The installer script construction process:
   |            <blockquote>
   |               <ol>
   |                  <li>Determination of a suitable temp directory. Much of the work
   |                      done by the mkinstaller script is done in a temp directory.
   |                  </li>
   |                  <li>Creation of a top level temporary directory under which all
   |                      other temporaries will be created. Creation of an "accumulator",
   |                      an "intermediate" and a "wrapper" directory in the top level
   |                      temp directory. A tarup/untar process will use both the
   |                      "intermediate" and "accumulator" directories to merge given
   |                      directories with the same basename. The "wrapper" directory
   |                      will be used to carry the individual directory tarballs.
   |                  </li>
   |                  <li>From each of the specified directories to be installed such
   |                      as .../bin, .../lib, specified on the mkinstaller command line
   |                      tarup the individual directory forming tarballs in the wrapper
   |                      directory in the temp directory.
   |                  </li>
   |                  <li>Tarup the temporary wrapper directory for eventual inclusion
   |                      in the generated installer.
   |                  </li>
   |                  <li>Generate the text of the "installer" script in the temporary
   |                      directory customizing it with with options for specifying an
   |                      overall prefix directory and individual prefixes for each of
   |                      the directories specified on the mkinstaller command line.
   |                  </li>
   |                  <li>Add the tarball built in (4) to the end of the script generated
   |                      in (5) forming the distribution self-extracting installation
   |                      script in the directory where <i>mkinstaller</i> was run.
   |                  </li>
   |                  <li>Cleanup.
   |                  </li>
   |               </ol>
   |               In the end the only product is the desired distribution self-
   |               extracting installation script in the directory where the
   |               <i>mkinstaller</i> command was run. Everything else produced along the
   |               way (directories and files) is considered temporary and is
   |               destroyed.
   |            </blockquote>
   |            <blockquote>
   |               Note that the name of the installer is specified using the <b><big><code>-c</code></big></b> <i>name</i>
   |               or <b><big><code>--create=</code></big></b><i>name</i> option to <i>mkinstaller</i>. However if the <b><big><code>-c</code></big></b> <i>name</i>
   |               or <b><big><code>--create=</code></big></b><i>name</i> option is not used then <i>mkinstaller</i> will try
   |               to come-up with a reasonable name:
   |               <blockquote>
   |                  <ol>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> and <b><big><code>--project-version=</code></big></b><i>version</i>
   |                         was used then the name of the generated installer will be:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-</code></big></b><i>version</i><b><big><code>-installer</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> was used but not the
   |                         <b><big><code>--project-version</code></big></b> option the name of the generated
   |                         installer will be:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-installer</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If neither the <b><big><code>--project-name</code></big></b> nor the <b><big><code>--project-version</code></big></b>
   |                         option the name of the generated installer will be:
   |                         <blockquote>
   |                            <b><big><code>installer</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                  </ol>
   |               </blockquote>
   |               As is typical for a UNIX-like environment, the generated script
   |               has no extension.
   |            </blockquote>
   |            How the generated installer script works on a UNIX-like target:
   |            <blockquote>
   |               <ol>
   |                  <li>The installer script locates itself. This may seem to be an
   |                      obvious and or silly question but the actual location of the
   |                      script file is necessary for the actual extraction (the script
   |                      file must be read by the standard "tail" utility).
   |                  </li>
   |                  <li>Determination of a suitable temp directory. Much of the work
   |                      done by the generated installer script is done in a temp
   |                      directory. Creation of a top level temporary directory under
   |                      which all other temporaries will be created. This temp
   |                      directory is created under the standard temp directory
   |                      determined at the start of this step (see NOTES).
   |                  </li>
   |                  <li>PREFIX and PREFIX_<i>xxx</i> values are established from command
   |                      line options. If appropriate options aren't supplied to
   |                      install all directories then the installer script will propmpt
   |                      for the necessary pathname(s). The installer script will
   |                      create the directories if necessary.
   |                  </li>
   |                  <li>The tarball embedded in the installer script is extracted from
   |                      the installer script into the temp directory created in (2).
   |                  </li>
   |                  <li>The tarball in (4) is unwrapped revealing one or more tarballs
   |                      (one for each installation directory such as <b><big><code>bin.tar.gz</code></big></b>
   |                      <b><big><code>include.tar.gz</code></big></b> <b><big><code>lib.tar.gz</code></big></b> ...). If a pre-install script was
   |                      supplied to <i>mkinstaller</i> when the generated installer script
   |                      was produced then it will be revealed at this time. Similarly
   |                      if a post-install script was supplied to mkinstaller when the
   |                      generated installer script was produced then it will also be
   |                      revealed at this time. Note that neither of these scripts if
   |                      supplied and revealed are actually executed in this step. See
   |                      steps (6) and (8).
   |                  </li>
   |                  <li>If (5) revealed a pre-install script then it will be executed
   |                      by the approptiate interpreter. Note that each of the PREFIX
   |                      directories will be supplied as an option to this pre-install
   |                      script (such as <b><big><code>--prefix_bin=</code></big></b><i>pathname</i>). Also note at this time
   |                      the individual tarballs representing the directories to install
   |                      have NOT be unwrapped.
   |                  </li>
   |                  <li>Each individual tarball revealed (5) is unwrapped into the
   |                      approperiate PREFIX directory overlying anything already
   |                      there.
   |                  </li>
   |                  <li>If (5) revealed a post-install script then it will be executed
   |                      by the approptiate interpreter. Note that each of the PREFIX
   |                      directories will be supplied as an option to this post-install
   |                      script (such as <b><big><code>--prefix_bin=</code></big></b><i>pathname</i>).
   |                  </li>
   |                  <li>Cleanup.
   |                  </li>
   |               </ol>
   |            </blockquote>
   |         </blockquote>
   |         <b>Windows-like Host</b>
   |         <blockquote>
   |            On a Windows-like host (such as Windows 7) the generated installer
   |            is implemented as a binary execurable which is actually generated
   |            under the covers by <i>NSIS</i> (Nullsoft Scripted Install System).
   |            <i>mkinstaller</i> requires <i>makensis</i> on Windows-like hosts.
   |         </blockquote>
   |         <blockquote>
   |            The installer construction process:
   |            <blockquote>
   |               <ol>
   |                  <li>Determination of a suitable temp directory. Much of the work
   |                      done by the <i>mkinstaller</i> script is done in a temp directory.
   |                  </li>
   |                  <li>Generation of a <b><big><code>.nsi</code></big></b> script file.
   |                  </li>
   |                  <li><i>MakeNSIS</i> is used to "compile" the <b><big><code>.nsi</code></big></b> script forming a
   |                      <b><big><code>.exe</code></big></b> binary executable.
   |                  </li>
   |               </ol>
   |               The <b><big><code>.exe</code></big></b> binary executable formed in step (3) is the product of the
   |               <i>mkinstaller</i> script and may be shipped to customers to perform the
   |               desired installation on their Windows system.
   |            </blockquote>
   |            <blockquote>
   |               Note that the name of the installer is specified using the <b><big><code>-c</code></big></b> <i>name</i>
   |               or <b><big><code>--create=</code></big></b><i>name</i> option to <i>mkinstaller</i>. However if the <b><big><code>-c</code></big></b> <i>name</i>
   |               or <b><big><code>--create=</code></big></b><i>name</i> option is not used then <i>mkinstaller</i> will try
   |               to come-up with a reasonable name:
   |               <blockquote>
   |                  <ol>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> and <b><big><code>--project-version=</code></big></b><i>version</i>
   |                         was used then the name of the generated installer will be:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-</code></big></b><i>version</i><b><big><code>-installer.exe</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If the <b><big><code>--project-name=</code></big></b><i>name</i> was used but not the
   |                         <b><big><code>--project-version</code></big></b> option the name of the generated
   |                         installer will be:
   |                         <blockquote>
   |                            <i>name</i><b><big><code>-installer.exe</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                     <li>If neither the <b><big><code>--project-name</code></big></b> nor the <b><big><code>--project-version</code></big></b>
   |                         option the name of the generated installer will be:
   |                         <blockquote>
   |                            <b><big><code>installer.exe</code></big></b>
   |                         </blockquote>
   |                     </li>
   |                  </ol>
   |               </blockquote>
   |               If the name is specified using the <b><big><code>-c</code></big></b> <i>name</i> or <b><big><code>--create=</code></big></b><i>name</i>
   |               option then the name should NOT included a <b><big><code>.exe</code></big></b> extension. The
   |               <i>makensis</i> tool which actually produces the binary executable
   |               will add the necessary extension.
   |            </blockquote>
   |         </blockquote>
   |         <blockquote>
   |            Running the generated installer:
   |            <blockquote>
   |               <ul>
   |                  <li>The default use of the generated installer will produce a
   |                      new directory on the user's desktop.
   |                      <blockquote>
   |                         <i>prompt</i>&gt; <b><big><code>installer.exe</code></big></b>
   |                      </blockquote>
   |                  </li>
   |                  <li>A different prefix may be specified using the <b><big><code>/D</code></big></b> option:
   |                      <blockquote>
   |                         <i>prompt</i>&gt; <b><big><code>installer.exe /D=E:\\bozo\\reposit</code></big></b>
   |                      </blockquote>
   |                      Note that the prefix directory will be creates as necessary
   |                      however the uninstaller will only (recursively) delete the
   |                      final directory component. In the above example only
   |                      <b><big><code>E:\\bozo\\reposit</code></big></b> will be (recursivly deleted, but the
   |                      directory <b><big><code>E:\\bozo</code></big></b> will be left intact.
   |                  </li>
   |               </ul>
   |               Note that the generated installer will pop-up a progress bar dialog
   |               box to indicate the installation progress.
   |            </blockquote>
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         OPTIONS
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i> supports the following options:
   |         <blockquote>
   |
   |            <b>--copyright</b>
   |            <blockquote>
   |               Output copyright and license to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>--help</b>
   |            <blockquote>
   |               Output this man page to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>--html</b>&nbsp;&nbsp;<i>pathname</i>
   |            <blockquote>
   |               Output this man page as HTML to the given file pathname and quit.
   |            </blockquote>
   |
   |            <b>--vernum</b>
   |            <blockquote>
   |               Output version number to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>--version</b>
   |            <blockquote>
   |               Output version number and revision date to <i>stdout</i> and quit.
   |            </blockquote>
   |
   |            <b>-c</b> <i>name</i> <br>
   |            <b>--create=</b><i>name</i>
   |            <blockquote>
   |               The name of the script to generate. It is generally not advisable
   |               to include a suffix (aka. extension) as part of the script name.
   |               Also note that this is <i>not</i> a pathname, is is the simple name of
   |               the script file which is to be created in the current directory.
   |               By default the script will be named "installer".
   |            </blockquote>
   |
   |            <b>--cc=</b><i>string</i>
   |            <blockquote>
   |               The C compiler name and version number that had been used in
   |               building the software being installed. Note that the string
   |               is expected to a blank separated pair: the name and version
   |               number. The default is the string "- -" (meaning "unknown"
   |               or "don't care"). For example:
   |               <blockquote>
   |                  --cc="gcc 4.5.1"
   |               </blockquote>
   |               Note that at this time only the C compiler name is used.
   |               This option has been replaced by the <b><big><code>--CC=</code></big></b><i>name</i> and <b><big><code>--CC-options=</code></big></b><i>string</i> options.
   |            </blockquote>
   |
   |            <b>--cxx=</b><i>string</i>
   |            <blockquote>
   |               The C++ compiler name and version number that had been used
   |               in building the software being installed. Note that the string
   |               is expected to a blank separated pair: the name and version
   |               number. The default is the string "- -" (meaning "unknown"
   |               or "don't care"). For example:
   |               <blockquote>
   |                  --cxx="g++ 4.5.1"
   |               </blockquote>
   |               Note that at this time only the C++ compiler name is used.
   |               This option has been replaced by the <b><big><code>--CXX=</code></big></b><i>name</i> and <b><big><code>--CXX-options=</code></big></b><i>string</i> options.
   |            </blockquote>
   |
   |            <b>CC=</b><i>name</i> <br>
   |            <b>--CC=</b><i>name</i>
   |            <blockquote>
   |               Used to specify the name of the C compiler used. If a pathname
   |               is supplied, only the basename will be used. For historical
   |               reasons the leading double-dash is optional.
   |            </blockquote>
   |
   |            <b>CC-options=</b><i>string</i> <br>
   |            <b>--CC-options=</b><i>string</i>
   |            <blockquote>
   |               Used to specify the options to be used with the C compiler used.
   |               Only special options such as the language standard assumed are
   |               to be specified. Define <b><big><code>-D</code></big></b><i>name</i>, include pathname <b><big><code>-I</code></big></b><i>pathname</i>,
   |               and library pathname <b><big><code>-L</code></big></b><i>pathname</i> (along with library names) are
   |               not normally used. The normal compile-only option <b><big><code>-c</code></big></b> is used by
   |               default. Note that the <i>string</i> of options should be quoted.
   |               For historical reasons the leading double-dash is optional.
   |            </blockquote>
   |
   |            <b>CXX=</b><i>name</i> <br>
   |            <b>--CXX=</b><i>name</i>
   |            <blockquote>
   |               Used to specify the name of the C++ compiler used. If a pathname
   |               is supplied, only the basename will be used. For historical
   |               reasons the leading double-dash is optional.
   |            </blockquote>
   |
   |            <b>CXX-options=</b><i>string</i> <br>
   |            <b>--CXX-options=</b><i>string</i>
   |            <blockquote>
   |               Used to specify the options to be used with the C++ compiler used.
   |               Only special options such as the language standard assumed are
   |               to be specified. Define <b><big><code>-D</code></big></b><i>name</i>, include pathname <b><big><code>-I</code></big></b><i>pathname</i>,
   |               and library pathname <b><big><code>-L</code></big></b><i>pathname</i> (along with library names) are
   |               not normally used. The normal compile-only option <b><big><code>-c</code></big></b> is used by
   |               default. Note that the <i>string</i> of options should be quoted.
   |            </blockquote>
   |
   |            <b>--contact=</b><i>address</i>
   |            <blockquote>
   |               A contact email address. There is no default contact address.
   |            </blockquote>
   |
   |            <b>-d</b> <br>
   |            <b>--debug</b>
   |            <blockquote>
   |               Produce extra output useful when debugging the <i>mkinstaller</i>
   |               script itself.
   |            </blockquote>
   |
   |            <b>--follow</b>
   |            <blockquote>
   |               Follow symbolic links for directory pathnames to will be
   |               embedded as tarballs within the generated installer script.
   |               By default such symbolic links are not permitted.
   |            </blockquote>
   |            <blockquote>
   |               Note that Windows-like systems do not support symbolic-links.
   |            </blockquote>
   |
   |            <b>--fortran=</b><i>string</i>
   |            <blockquote>
   |               The FORTRAN compiler name and version number that had been used
   |               in building the software being installed. Note that the string
   |               is expected to a blank separated pair: the name and version
   |               number. The default is the string "- -" (meaning "unknown"
   |               or "don't care").
   |            </blockquote>
   |
   |            <blockquote>
   |               Example:
   |               <blockquote>
   |                  --fortran="gfortran 4.5.1"
   |               </blockquote>
   |            </blockquote>
   |
   |            <b>--intermediate-dir=</b><i>name</i> <br>
   |            <b>version-dir=</b><i>name</i>
   |            <blockquote>
   |               Use the given simple name as an intermediate directory name
   |               (aka. a version directory name) to be added under the PREFIX
   |               directory pathname as given to the installer at installation
   |               time in to which the directories will be installed. The
   |               default is no such intermediate directory, the installations
   |               will be done in the PREFIX directory as given at installation
   |               time.
   |            </blockquote>
   |
   |            <b>--nofollow</b>
   |            <blockquote>
   |               Don't follow symbolic links for directory pathnames to will be
   |               embedded as tarballs within the generated installer script.
   |               When such symbolic-links are detected and error message will
   |               be produced and the script will terminate (after cleaning-up).
   |               This is the default behavior.
   |            </blockquote>
   |            <blockquote>
   |               Note that Windows-like systems do not support symbolic-links.
   |            </blockquote>
   |
   |            <b>--nosha</b>
   |            <blockquote>
   |               Don't generate a SHA hash file for the generated script. This
   |               is the default behaviour.
   |            </blockquote>
   |
   |            <b>--nonstd</b>
   |            <blockquote>
   |               Don't bother with any search for standard directory names such
   |               as <b><big><code>bin</code></big></b>, <b><big><code>lib</code></big></b>, or <b><big><code>include</code></big></b>, (see the <b><big><code>--std</code></big></b> option). Instead just
   |               simply use the directory pathname as given. Note that such a
   |               search would only done when the given directory pathnames don't
   |               include those with standard base names as <b><big><code>bin</code></big></b>, <b><big><code>lib</code></big></b>, or <b><big><code>include</code></big></b>.
   |            </blockquote>
   |
   |            <b>--os=</b><i>string</i>
   |            <blockquote>
   |               The OS on the system on which the installer is being generated.
   |               This string is encoded in the installer script as an aid in
   |               determining if the generated script is applicable to the
   |               system where it is run. The default is to use <b><big><code>uname -s</code></big></b> and
   |               <b><big><code>uname -r</code></big></b> to determine this string.
   |            </blockquote>
   |
   |            <b>--preinstall-binary=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a binary executable which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |
   |            <b>--preinstall-perl=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Perl script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such pre-install Perl scripts are not generally supported
   |               on Windows systems as Perl is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--preinstall-python=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Python script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such pre-install Python scripts are not generally supported
   |               on Windows systems as Python is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--preinstall-sh=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Bourne-shell script which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer before all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such pre-install Bourne-shell scripts are not generally
   |               supported on Windows systems as the Bourne-shell is not
   |               generally found on Windows systems.
   |            </blockquote>
   |
   |            <b>--postinstall-binary=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a binary executable which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |
   |            <b>--postinstall-perl=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Perl script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such post-install Perl scripts are not generally supported
   |               on Windows systems as Perl is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--postinstall-python=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Python script which is to be included with
   |               the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such post-install Python scripts are not generally supported
   |               on Windows systems as Python is not generally found on Windows
   |               systems.
   |            </blockquote>
   |
   |            <b>--postinstall-sh=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a Bourne-shell script which is to be included
   |               with the installer's payload. It will be run by the generated
   |               installer after all of the payload directories have been
   |               extracted and installed.
   |            </blockquote>
   |            <blockquote>
   |               Such post-install Bourne-shell scripts are not generally
   |               supported on Windows systems as the Bourne-shell is not
   |               generally found on Windows systems.
   |            </blockquote>
   |
   |            <b>--prjnam=</b><i>name</i> <br>
   |            <b>--project-name=</b><i>name</i>
   |            <blockquote>
   |               The name of the project to be installed by the generated
   |               installer script. There is no default project name.
   |            </blockquote>
   |
   |            <b>--prjver=</b><i>A</i><b>.</b><i>B</i>[<b>.</b><i>C</i>[<b>.</b><i>D</i>]][<i>suffix</i>] <br>
   |            <b>--project-version=</b><i>A</i><b>.</b><i>B</i>[<b>.</b><i>C</i>[<b>.</b><i>D</i>]][<i>suffix</i>]
   |            <blockquote>
   |               The version number of the project to be installed by the
   |               generated installer script. Note that the given version number
   |               is expected to have 2, 3, or 4 dot-separated numeric components
   |               and an optional suffix. If the <b><big><code>--project-version</code></big></b> option is used
   |               then the <b><big><code>--project-name</code></big></b> option must also be used. There is
   |               no default project version number.
   |            </blockquote>
   |
   |            <b>--sha-1</b> <br>
   |            <b>--sha-160</b> <br>
   |            <b>--sha-256</b> <br>
   |            <b>--sha-384</b> <br>
   |            <b>--sha-512</b>
   |            <blockquote>
   |               Generate a SHA hash of the generated script. The hash file
   |               will have the same name as the generated script but with an
   |               added <b><big><code>.sha-</code></big></b><i>nnn</i>" suffix (where <i>nnn</i> is one of 1, 256,
   |               384, or 512). Note that <b><big><code>--sha-1</code></big></b> and <b><big><code>--sha-160</code></big></b> are synonymous.
   |            </blockquote>
   |
   |            <b>--std</b>
   |            <blockquote>
   |               If <b>none</b> of the given directory pathnames have basenames such
   |               as <b><big><code>bin</code></big></b>, <b><big><code>lib</code></big></b>, or <b><big><code>include</code></big></b> then look for immediate subdirectories
   |               of the given directory pathnames with such basenames. If <b>any</b>
   |               have such standard base names then replace the given directory
   |               pathname with all of the immediate subdirectory pathnames. See
   |               the <b><big><code>--nonstd</code></big></b> option.
   |            </blockquote>
   |
   |            <b>-v</b>[<i>digit</i>] <br>
   |            <b>--verbose</b>[<i>digit</i>]
   |            <blockquote>
   |               Operate in a "verbose" mode.
   |            </blockquote>
   |            <blockquote>
   |               Repeating this option increases the amount of output produced.
   |               Note that the option may end with an optional digit which
   |               indicates a repetition count. Thus the option: <br>
   |               <p>
   |<p>
   |<pre>
   |   -v3
   |</pre>
   |<p>
   |               is equavalent to: <br>
   |               <p>
   |<p>
   |<pre>
   |   -v -v -v
   |</pre>
   |            </blockquote>
   |
   |            <b>-w</b> <i>pathname</i> <br>
   |            <b>--with-notice=</b><i>pathname</i>
   |            <blockquote>
   |               The pathname of a textfile which contains the copyright
   |               notice that is to be output by the generated installer script
   |               when the installer's <b><big><code>--copyright</code></big></b> option is used. By default
   |               the generated installer doesn't support a <b><big><code>--copyright</code></big></b> option.
   |            </blockquote>
   |
   |            <b>--with-payload</b>
   |            <blockquote>
   |               Include the payload with the generated script. This results
   |               in a useful installer script that will actually install the
   |               supplied directories under the indicated prefix directory (see
   |               the <b><big><code>--prefix=</code></big></b><i>...</i> and the <b><big><code>--intermediate-dir=</code></big></b><i>...</i> options. This
   |               is the default behavior.
   |            </blockquote>
   |
   |            <b>--without-payload</b>
   |            <blockquote>
   |               Don't include the payload with the generated script. This
   |               results in an ineffective installer script that won't actually
   |               install anything. It does however go through much of the other
   |               parts of the process and so may be an aid when debugging the
   |               generated installer.
   |            </blockquote>
   |
   |            <i>pathname</i>
   |            <blockquote>
   |               The pathnames of one or more directories which will be
   |               embedded as tarballs within the generated installer script.
   |               Typical directory basenames are: bin, include, lib, ... Note
   |               that at least one such directory pathname is required.
   |            </blockquote>
   |
   |            <blockquote>
   |               The basename of this pathname may not contain any spaces or
   |               tabs however the directory component (if any) may.
   |            </blockquote>
   |
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         RETURNS
   |      </h3>
   |      <blockquote>
   |         "mkinstaller" returns the standard exit codes:
   |         <blockquote>
   |            <table border=0><smaller>
   |               <tr>
   |                  <td align=right>0</td>
   |                  <td align=left>--</td>
   |                  <td align=left>success</td>
   |               </tr>
   |               <tr>
   |                  <td align=right>1</td>
   |                  <td align=left>--</td>
   |                  <td align=left>failure</td>
   |               </tr>
   |            </table>
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         ENVIRONMENT
   |      </h3>
   |      <blockquote>
   |         <i>mkinstaller</i> refers to the following environment variables:
   |         <blockquote>
   |
   |            DEBUG_mkinstaller
   |            <blockquote>
   |               Generate extra output which is only usefull when debugging the
   |               <i>mkinstaller</i> script itself.
   |            </blockquote>
   |
   |            INEFFECTIVE_mkinstaller
   |            <blockquote>
   |               If this environment variable has been set then the generated
   |               script will lack a payload and may not even be runable. Note
   |               that this feature is almost never used except when debugging
   |               the script generation process.
   |            </blockquote>
   |
   |            MKINSTALLER_TMPDIR
   |            <blockquote>
   |               Consider this pathname before considering TMPDIR (see
   |               step (0) in the <b>NOTES</b> section below).
   |            </blockquote>
   |
   |         </blockquote>
   |      </blockquote>
   |
   |      <h3>
   |         IMPLEMENTATION
   |      </h3>
   |      <blockquote>
EOF1
   if ($OSclass eq "Windows-like") {
      print HTML "         <i>mkinstaller</i> is implemented as a Perl script that is wrapped in\n";
      print HTML "         a binary executable to avoid any Windows registry entanglements.\n";
   }
   else {
      print HTML "         <i>mkinstaller</i> is implemented as a Perl script.\n";
   }
   print HTML fixIndentStuff(<<"EOF2");
   |      </blockquote>
   |
   |      <h3>
   |         SEE&nbsp;ALSO
   |      </h3>
   |      <blockquote>
   |         <a href="http://nsis.sourceforge.net/Docs/Chapter3.html#">makensis</a>(1), <br>
   |         <a href="http://nsis.sourceforge.net/Main_Page">NSIS</a>, <br>
   |         <a href="../html1/pshaw$TBG_HTML_EXT">pshaw</a>(<a href="../html1/index$TBG_HTML_EXT">1x</a>), <br>
   |         sh(1), <br>
   |         sha1sum(1), <br>
   |         sha256sum(1), <br>
   |         sha384sum(1), <br>
   |         sha512sum(1), <br>
   |         tar(1)
   |      </blockquote>
   |
   |      <h3>
   |         NOTES
   |      </h3>
   |      <blockquote>
   |         The directory where temporary files are to be placed is determined
   |         as follows:
   |         <blockquote>
   |            <ol start="0">
   |               <li>If <b><big><code>MKINSTALLER_TMPDIR</code></big></b> is defined and is not empty then
   |                   consider its value as a directory pathname. If this pathname
   |                   exists and is a directory and is writable then temporary
   |                   files will be placed in this directory. Otherwise...
   |               <li>If <b><big><code>TMPDIR</code></big></b> is defined and is not empty then consider its
   |                   value as a directory pathname. If this pathname exists
   |                   and is a directory and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>TMP</code></big></b> is defined and is not empty then consider its
   |                   value as a directory pathname. If this pathname exists
   |                   and is a directory and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>TEMP</code></big></b> is defined and is not empty then consider its
   |                   value as a directory pathname. If this pathname exists
   |                   and is a directory and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If the user's home directory can be determined and if
   |                   this home directory contains a subdirectory named <b><big><code>tmp</code></big></b>
   |                   that is itself writable then temporary files will be
   |                   placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>C:</code></big></b><i>userProfile</i><b><big><code>\\AppData\\Local\\temp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>/tmp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>/var/tmp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>C:\\Temp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If <b><big><code>C:\\Windows\\Temp</code></big></b> exists and is writable then temporary files
   |                   will be placed in this directory. Otherwise...
   |               </li>
   |               <li>If the current directory is writable then temporary
   |                   files will be placed in the current directory.
   |                   Otherwise...
   |               </li>
   |               <li>A fatal error message will be sent to <i>stderr</i> and
   |                   the script will exit with a non-zero exit code.
   |               </li>
   |            </ol>
   |         </blockquote>
   |         Note that 5, 8, and 9 are only applicable on Windows-like hosts.
   |      </blockquote>
   |
   |      <h3>
   |         AUTHOR
   |      </h3>
   |      <blockquote>
   |         <a href="mailto:jim.reus\@gmail.com?subject=mkinstaller">Jim Reus</a> <br>
   |      </blockquote>
   |
   |      <h3>
   |         CONTACT
   |      </h3>
   |      <blockquote>
   |         Please contact: <br>
   |         <blockquote>
   |            <a href="mailto:totebag.help\@gmail.com?subject=Help: mkinstaller">totebag.help</a> with questions. <br>
   |            <br>
   |            <a href="mailto:totebag.bugs\@gmail.com?subject=Bug: mkinstaller">totebag.bugs</a> to report problems. <br>
   |            <br>
   |            <a href="mailto:totebag.more\@gmail.com?subject=Enhance: mkinstaller">totebag.more</a> to request enhancements. <br>
   |            <br>
   |         </blockquote>
   |         Be sure to provide as much information as possible.
   |      </blockquote>
   |
   |      <h3>
   |         <center>
   |            <nobr>
   |               mkinstaller (rev. $mkinstaller_ver_name)
   |            </nobr>
   |         </center>
   |      </h3>
   |
   |      <i>This man page was generated by mkinstaller $mkinstaller_ver_name using the <code>--html</code> option. Revised $mkinstaller_ver_time</i>
   |   </body>
   |</html>
EOF2
   close(HTML);
}

