L1    # abs d2, d1
L2    0x22 0xb8 0xe0 0x5e
L2    0x00000000: 22 b8 e0 5e               ?? abs      d2, d1                                   ; absolute value
L3    
L4    # adc w3, w2, w1
L5    0x43 0x00 0x01 0x1a
L5    0x00000000: 43 00 01 1a               ?? adc      w3, w2, w1                               ; add with carry
L6    
L7    # adc x3, x2, x1
L8    0x43 0x00 0x01 0x9a
L8    0x00000000: 43 00 01 9a               ?? adc      x3, x2, x1                               ; add with carry
L9    
L10   # adcs w3, w2, w1
L11   0x43 0x00 0x01 0x3a
L11   0x00000000: 43 00 01 3a               ?? adcs     w3, w2, w1                               ; add with carry
L12   
L13   # adcs x3, x2, x1
L14   0x43 0x00 0x01 0xba
L14   0x00000000: 43 00 01 ba               ?? adcs     x3, x2, x1                               ; add with carry
L15   
L16   # add w3, w2, w1, uxtb #2
L17   0x43 0x08 0x21 0x0b
L17   0x00000000: 43 08 21 0b               ?? add      w3, w2, uext(trunc(w1, 8), 32) << 2      ; add
L18   
L19   # add x3, x2, w1, uxtb #2
L20   0x43 0x08 0x21 0x8b
L20   0x00000000: 43 08 21 8b               ?? add      x3, x2, uext(trunc(w1, 8), 32) << 2      ; add
L21   
L22   # add x3, x2, x1, sxtx #2
L23   0x43 0xe8 0x21 0x8b
L23   0x00000000: 43 e8 21 8b               ?? add      x3, x2, x1 << 2                          ; add
L24   
L25   # add sp, x2, x1, sxtx #2
L26   0x5f 0xe8 0x21 0x8b
L26   0x00000000: 5f e8 21 8b               ?? add      sp, x2, x1 << 2                          ; add
L27   
L28   # add w2, w1, #0xfff
L29   0x22 0xfc 0x3f 0x11
L29   0x00000000: 22 fc 3f 11               ?? add      w2, w1, 0x0000000000000fff<4095>         ; add
L30   
L31   # add x2, x1, #0xfff
L32   0x22 0xfc 0x3f 0x91
L32   0x00000000: 22 fc 3f 91               ?? add      x2, x1, 0x0000000000000fff<4095>         ; add
L33   
L34   # add w2, w1, #0xfff, lsl #12
L35   0x22 0xfc 0x7f 0x11
L35   0x00000000: 22 fc 7f 11               ?? add      w2, w1, 0x0000000000000fff<4095> << 12   ; add
L36   
L37   # add w3, w2, w1, lsl #31
L38   0x43 0x7c 0x01 0x0b
L38   0x00000000: 43 7c 01 0b               ?? add      w3, w2, w1 << 0x1f<31>                   ; add
L39   
L40   # add x3, x2, x1, lsl #63
L41   0x43 0xfc 0x01 0x8b
L41   0x00000000: 43 fc 01 8b               ?? add      x3, x2, x1 << 0x3f<63>                   ; add
L42   
L43   # add d3, d2, d1
L44   0x43 0x84 0xe1 0x5e
L44   0x00000000: 43 84 e1 5e               ?? add      d3, d2, d1                               ; add
L45   
L46   # add v3.2d, v2.2d, v1.2d
L47   0x43 0x84 0xe1 0x4e
L47   0x00000000: 43 84 e1 4e               ?? add      v3.2d, v2.2d, v1.2d                      ; add
L48   
L49   # add v3.4s, v2.4s, v1.4s
L50   0x43 0x84 0xa1 0x4e
L50   0x00000000: 43 84 a1 4e               ?? add      v3.4s, v2.4s, v1.4s                      ; add
L51   
L52   # add v3.2d, v2.2d, v1.2d
L53   0x43 0x84 0xe1 0x4e
L53   0x00000000: 43 84 e1 4e               ?? add      v3.2d, v2.2d, v1.2d                      ; add
L54   
L55   # add v3.8b, v2.8b, v1.8b
L56   0x43 0x84 0x21 0x0e
L56   0x00000000: 43 84 21 0e               ?? add      v3.8b, v2.8b, v1.8b                      ; add
L57   
L58   # add v3.4h, v2.4h, v1.4h
L59   0x43 0x84 0x61 0x0e
L59   0x00000000: 43 84 61 0e               ?? add      v3.4h, v2.4h, v1.4h                      ; add
L60   
L61   # add v3.2s, v2.2s, v1.2s
L62   0x43 0x84 0xa1 0x0e
L62   0x00000000: 43 84 a1 0e               ?? add      v3.2s, v2.2s, v1.2s                      ; add
L63   
L64   # addg x2, x1, #16, #0
L65   # only valid for ARMv8.5 and later
L66   # 0x22 0x00 0x81 0x91
L67   
L68   # addhn v3.8b, v2.8h, v1.8h
L69   0x43 0x40 0x21 0x0e
L69   0x00000000: 43 40 21 0e               ?? addhn    v3.8b, v2.8h, v1.8h                      ; add returning high narrow to lower
L70   
L71   # addhn v3.4h, v2.4s, v1.4s
L72   0x43 0x40 0x61 0x0e
L72   0x00000000: 43 40 61 0e               ?? addhn    v3.4h, v2.4s, v1.4s                      ; add returning high narrow to lower
L73   
L74   # addhn v3.2s, v2.2d, v1.2d
L75   0x43 0x40 0xa1 0x0e
L75   0x00000000: 43 40 a1 0e               ?? addhn    v3.2s, v2.2d, v1.2d                      ; add returning high narrow to lower
L76   
L77   # addhn2 v3.16b, v2.8h, v1.8h
L78   0x43 0x40 0x21 0x4e
L78   0x00000000: 43 40 21 4e               ?? addhn2   v3.16b, v2.8h, v1.8h                     ; add returning high narrow to upper
L79   
L80   # addhn2 v3.8h, v2.4s, v1.4s
L81   0x43 0x40 0x61 0x4e
L81   0x00000000: 43 40 61 4e               ?? addhn2   v3.8h, v2.4s, v1.4s                      ; add returning high narrow to upper
L82   
L83   # addhn2 v3.4s, v2.2d, v1.2d
L84   0x43 0x40 0xa1 0x4e
L84   0x00000000: 43 40 a1 4e               ?? addhn2   v3.4s, v2.2d, v1.2d                      ; add returning high narrow to upper
L85   
L86   # addp d2, v1.2d
L87   0x22 0xb8 0xf1 0x5e
L87   0x00000000: 22 b8 f1 5e               ?? addp     d2, v1.2d                                ; add pair of elements
L88   
L89   # addp v3.8b, v2.8b, v1.8b
L90   0x43 0xbc 0x21 0x0e
L90   0x00000000: 43 bc 21 0e               ?? addp     v3.8b, v2.8b, v1.8b                      ; add pair of elements
L91   
L92   # addp v3.4h, v2.4h, v1.4h
L93   0x43 0xbc 0x61 0x0e
L93   0x00000000: 43 bc 61 0e               ?? addp     v3.4h, v2.4h, v1.4h                      ; add pair of elements
L94   
L95   # addp v3.2s, v2.2s, v1.2s
L96   0x43 0xbc 0xa1 0x0e
L96   0x00000000: 43 bc a1 0e               ?? addp     v3.2s, v2.2s, v1.2s                      ; add pair of elements
L97   
L98   # addp v3.16b, v2.16b, v1.16b
L99   0x43 0xbc 0x21 0x4e
L99   0x00000000: 43 bc 21 4e               ?? addp     v3.16b, v2.16b, v1.16b                   ; add pair of elements
L100  
L101  # addp v3.8h, v2.8h, v1.8h
L102  0x43 0xbc 0x61 0x4e
L102  0x00000000: 43 bc 61 4e               ?? addp     v3.8h, v2.8h, v1.8h                      ; add pair of elements
L103  
L104  # addp v3.4s, v2.4s, v1.4s
L105  0x43 0xbc 0xa1 0x4e
L105  0x00000000: 43 bc a1 4e               ?? addp     v3.4s, v2.4s, v1.4s                      ; add pair of elements
L106  
L107  # addp v3.2d, v2.2d, v1.2d
L108  0x43 0xbc 0xe1 0x4e
L108  0x00000000: 43 bc e1 4e               ?? addp     v3.2d, v2.2d, v1.2d                      ; add pair of elements
L109  
L110  # adds w3, w2, w1, uxtb #4
L111  0x43 0x10 0x21 0x2b
L111  0x00000000: 43 10 21 2b               ?? adds     w3, w2, uext(trunc(w1, 8), 32) << 4      ; add
L112  
L113  # adds x3, x2, w1, uxtb #4
L114  0x43 0x10 0x21 0xab
L114  0x00000000: 43 10 21 ab               ?? adds     x3, x2, uext(trunc(w1, 8), 32) << 4      ; add
L115  
L116  # adds w2, w1, #0xfff, lsl #12
L117  0x22 0xfc 0x7f 0x31
L117  0x00000000: 22 fc 7f 31               ?? adds     w2, w1, 0x0000000000000fff<4095> << 12   ; add
L118  
L119  # adds x2, x1, #0xfff, lsl #12
L120  0x22 0xfc 0x7f 0xb1
L120  0x00000000: 22 fc 7f b1               ?? adds     x2, x1, 0x0000000000000fff<4095> << 12   ; add
L121  
L122  # adds w3, w2, w1, asr #31
L123  0x43 0x7c 0x81 0x2b
L123  0x00000000: 43 7c 81 2b               ?? adds     w3, w2, asr(w1, 0x1f<31>)                ; add
L124  
L125  # adds x3, x2, x1, asr #63
L126  0x43 0xfc 0x81 0xab
L126  0x00000000: 43 fc 81 ab               ?? adds     x3, x2, asr(x1, 0x3f<63>)                ; add
L127  
L128  # addv b2, v1.8b
L129  0x22 0xb8 0x31 0x0e
L129  0x00000000: 22 b8 31 0e               ?? addv     b2, v1.8b                                ; add across vector
L130  
L131  # addv h2, v1.4h
L132  0x22 0xb8 0x71 0x0e
L132  0x00000000: 22 b8 71 0e               ?? addv     h2, v1.4h                                ; add across vector
L133  
L134  # addv b2, v1.16b
L135  0x22 0xb8 0x31 0x4e
L135  0x00000000: 22 b8 31 4e               ?? addv     b2, v1.16b                               ; add across vector
L136  
L137  # addv h2, v1.8h
L138  0x22 0xb8 0x71 0x4e
L138  0x00000000: 22 b8 71 4e               ?? addv     h2, v1.8h                                ; add across vector
L139  
L140  # addv s2, v1.4s
L141  0x22 0xb8 0xb1 0x4e
L141  0x00000000: 22 b8 b1 4e               ?? addv     s2, v1.4s                                ; add across vector
L142  
L143  # adr x1, #0xffffffffffffffff
L144  0xe1 0xff 0xff 0x70
L144  0x00000000: e1 ff ff 70               ?? adr      x1, 0xffffffffffffffff<18446744073709551615,-1> ; form pc-relative address
L145  
L146  # adrp x1, #0xfffffffffffff000
L147  0xe1 0xff 0xff 0xf0
L147  0x00000000: e1 ff ff f0               ?? adrp     x1, 0xfffffffffffff000<18446744073709547520,-4096> ; form pc-relative address to 4kB page
L148  
L149  # aesd v2.16b, v1.16b
L150  0x22 0x58 0x28 0x4e
L150  0x00000000: 22 58 28 4e               ?? aesd     v2.16b, v1.16b                           ; AES single round decryption
L151  
L152  # aese v2.16b, v1.16b
L153  0x22 0x48 0x28 0x4e
L153  0x00000000: 22 48 28 4e               ?? aese     v2.16b, v1.16b                           ; AES single round encryption
L154  
L155  # aesimc v2.16b, v1.16b
L156  0x22 0x78 0x28 0x4e
L156  0x00000000: 22 78 28 4e               ?? aesimc   v2.16b, v1.16b                           ; AES inverse mix columns
L157  
L158  # aesmc v2.16b, v1.16b
L159  0x22 0x68 0x28 0x4e
L159  0x00000000: 22 68 28 4e               ?? aesmc    v2.16b, v1.16b                           ; AES mix columns
L160  
L161  # and v3.8b, v2.8b, v1.8b
L162  0x43 0x1c 0x21 0x0e
L162  0x00000000: 43 1c 21 0e               ?? and      v3.8b, v2.8b, v1.8b                      ; bitwise AND
L163  
L164  # and v3.16b, v2.16b, v1.16b
L165  0x43 0x1c 0x21 0x4e
L165  0x00000000: 43 1c 21 4e               ?? and      v3.16b, v2.16b, v1.16b                   ; bitwise AND
L166  
L167  # and w2, w1, #1
L168  0x22 0x00 0x00 0x12
L168  0x00000000: 22 00 00 12               ?? and      w2, w1, 1                                ; bitwise AND
L169  
L170  # and x2, x1, #0x100000001
L171  0x22 0x00 0x00 0x92
L171  0x00000000: 22 00 00 92               ?? and      x2, x1, 0x0000000100000001               ; bitwise AND
L172  
L173  # and w3, w2, w1, asr #31
L174  0x43 0x7c 0x81 0x0a
L174  0x00000000: 43 7c 81 0a               ?? and      w3, w2, asr(w1, 0x1f<31>)                ; bitwise AND
L175  
L176  # and x3, x2, x1, asr #63
L177  0x43 0xfc 0x81 0x8a
L177  0x00000000: 43 fc 81 8a               ?? and      x3, x2, asr(x1, 0x3f<63>)                ; bitwise AND
L178  
L179  # ands w2, w1, #1
L180  0x22 0x00 0x00 0x72
L180  0x00000000: 22 00 00 72               ?? ands     w2, w1, 1                                ; bitwise AND
L181  
L182  # ands x2, x1, #0x100000001
L183  0x22 0x00 0x00 0xf2
L183  0x00000000: 22 00 00 f2               ?? ands     x2, x1, 0x0000000100000001               ; bitwise AND
L184  
L185  # ands w3, w2, w1, lsl #31
L186  0x43 0x7c 0x01 0x6a
L186  0x00000000: 43 7c 01 6a               ?? ands     w3, w2, w1 << 0x1f<31>                   ; bitwise AND
L187  
L188  # ands x3, x2, x1, lsl #63
L189  0x43 0xfc 0x01 0xea
L189  0x00000000: 43 fc 01 ea               ?? ands     x3, x2, x1 << 0x3f<63>                   ; bitwise AND
L190  
L191  # asr w3, w2, w1
L192  0x43 0x28 0xc1 0x1a
L192  0x00000000: 43 28 c1 1a               ?? asr      w3, w2, w1                               ; arithmetic shift right
L193  
L194  # asr x3, x2, x1
L195  0x43 0x28 0xc1 0x9a
L195  0x00000000: 43 28 c1 9a               ?? asr      x3, x2, x1                               ; arithmetic shift right
L196  
L197  # asr w2, w1, #0xf
L198  0x22 0x7c 0x0f 0x13
L198  0x00000000: 22 7c 0f 13               ?? asr      w2, w1, 15                               ; arithmetic shift right
L199  
L200  # asr x2, x1, #0x3f
L201  0x22 0xfc 0x7f 0x93
L201  0x00000000: 22 fc 7f 93               ?? asr      x2, x1, 0x000000000000003f<63>           ; arithmetic shift right
L202  
L203  # at s1e1r, x1
L204  0x01 0x78 0x08 0xd5
L204  0x00000000: 01 78 08 d5               ?? at       s1e1r, x1                                ; address translate
L205  
L206  # autda x2, x1
L207  # only for ARMv8p3
L208  # 0x22 0x18 0xc1 0xda
L209  
L210  # autdza x1
L211  # only for ARMv8p3
L212  #0xe2 0x3b 0xc1 0xda
L213  
L214  # autdb x2, sp
L215  # only for ARMv8p3
L216  #0xe2 0x1f 0xc1 0xda
L217  
L218  # autdzb x2
L219  # only for ARMv8p3
L220  #0xe2 0x3f 0xc1 0xda
L221  
L222  # autia...
L223  # only for ARMv8p3
L224  
L225  # autia1716...
L226  # only for ARMv8p3
L227  
L228  # autiasp...
L229  # only for ARMv8p3
L230  
L231  # autiaz...
L232  # only for ARMv8p3
L233  
L234  # autiza...
L235  # only for ARMv8p3
L236  
L237  # autib...
L238  # only for ARMv8p3
L239  
L240  # autib1716...
L241  # only for ARMv8p3
L242  
L243  # autibsp...
L244  # only for ARMv8p3
L245  
L246  # autibz...
L247  # only for ARMv8p3
L248  
L249  # autizb...
L250  # only for ARMv8p3
L251  
L252  # AXFlag
L253  # internal version only
L254  # 0x5f 0x40 0x00 0xd5
L255  
L256  # b.eq #0xfffffffffffffffc
L257  0xe0 0xff 0xff 0x54
L257  0x00000000: e0 ff ff 54               ?? b.eq     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L258  
L259  # b.ne #0xfffffffffffffffc
L260  0xe1 0xff 0xff 0x54
L260  0x00000000: e1 ff ff 54               ?? b.ne     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L261  
L262  # b.hs #0xfffffffffffffffc
L263  0xe2 0xff 0xff 0x54
L263  0x00000000: e2 ff ff 54               ?? b.hs     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L264  
L265  # b.lo #0xfffffffffffffffc
L266  0xe3 0xff 0xff 0x54
L266  0x00000000: e3 ff ff 54               ?? b.lo     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L267  
L268  # b.mi #0xfffffffffffffffc
L269  0xe4 0xff 0xff 0x54
L269  0x00000000: e4 ff ff 54               ?? b.mi     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L270  
L271  # b.pl #0xfffffffffffffffc
L272  0xe5 0xff 0xff 0x54
L272  0x00000000: e5 ff ff 54               ?? b.pl     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L273  
L274  # b.vs #0xfffffffffffffffc
L275  0xe6 0xff 0xff 0x54
L275  0x00000000: e6 ff ff 54               ?? b.vs     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L276  
L277  # b.vc #0xfffffffffffffffc
L278  0xe7 0xff 0xff 0x54
L278  0x00000000: e7 ff ff 54               ?? b.vc     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L279  
L280  # b.hi #0xfffffffffffffffc
L281  0xe8 0xff 0xff 0x54
L281  0x00000000: e8 ff ff 54               ?? b.hi     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L282  
L283  # b.ls #0xfffffffffffffffc
L284  0xe9 0xff 0xff 0x54
L284  0x00000000: e9 ff ff 54               ?? b.ls     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L285  
L286  # b.ge #0xfffffffffffffffc
L287  0xea 0xff 0xff 0x54
L287  0x00000000: ea ff ff 54               ?? b.ge     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L288  
L289  # b.lt #0xfffffffffffffffc
L290  0xeb 0xff 0xff 0x54
L290  0x00000000: eb ff ff 54               ?? b.lt     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L291  
L292  # b.gt #0xfffffffffffffffc
L293  0xec 0xff 0xff 0x54
L293  0x00000000: ec ff ff 54               ?? b.gt     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L294  
L295  # b.le #0xfffffffffffffffc
L296  0xed 0xff 0xff 0x54
L296  0x00000000: ed ff ff 54               ?? b.le     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L297  
L298  # b.al #0xfffffffffffffffc
L299  0xee 0xff 0xff 0x54
L299  0x00000000: ee ff ff 54               ?? b.al     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L300  
L301  # b.nv #0xfffffffffffffffc
L302  0xef 0xff 0xff 0x54
L302  0x00000000: ef ff ff 54               ?? b.nv     0xfffffffffffffffc<18446744073709551612,-4> ; branch
L303  
L304  # b #0xfffffffffffffffc
L305  0xff 0xff 0xff 0x17
L305  0x00000000: ff ff ff 17               ?? b        0xfffffffffffffffc<18446744073709551612,-4> ; branch
L306  
L307  # bcax...
L308  # only for ARMv8.2-SHA
L309  # 0x64 0x08 0x21 0xce
L310  
L311  # bfxil w2, w1, #0, #1
L312  0x22 0x00 0x00 0x33
L312  0x00000000: 22 00 00 33               ?? bfxil    w2, w1, 0, 1                             ; bifield extract and insert low
L313  
L314  # bic v0.4h, #0xff
L315  0xe0 0x97 0x07 0x2f
L315  0x00000000: e0 97 07 2f               ?? bic      v0.4h, 0x00000000000000ff<255>           ; bitwise bit clear
L316  
L317  # bic v3.16b, v2.16b, v1.16b
L318  0x43 0x1c 0x61 0x4e
L318  0x00000000: 43 1c 61 4e               ?? bic      v3.16b, v2.16b, v1.16b                   ; bitwise bit clear
L319  
L320  # bic w3, w2, w1, lsr #7
L321  0x43 0x1c 0x61 0x0a
L321  0x00000000: 43 1c 61 0a               ?? bic      w3, w2, w1 >> 7                          ; bitwise bit clear
L322  
L323  # bics w3, w2, w1, lsr #7
L324  0x43 0x1c 0x61 0x6a
L324  0x00000000: 43 1c 61 6a               ?? bics     w3, w2, w1 >> 7                          ; bitwise bit clear
L325  
L326  # blr x1
L327  0x20 0x00 0x3f 0xd6
L327  0x00000000: 20 00 3f d6               ?? blr      x1                                       ; branch with link to register
L328  
L329  # br x1
L330  0x20 0x00 0x1f 0xd6
L330  0x00000000: 20 00 1f d6               ?? br       x1                                       ; branch to register
L331  
L332  # cbnz x1, #0xfffffffffffffffc
L333  0xe1 0xff 0xff 0xb5
L333  0x00000000: e1 ff ff b5               ?? cbnz     x1, 0xfffffffffffffffc<18446744073709551612,-4> ; compare and branch on nonzero
L334  
L335  #cbz x1, #0xfffffffffffffffc
L336  0xe1 0xff 0xff 0xb4
L336  0x00000000: e1 ff ff b4               ?? cbz      x1, 0xfffffffffffffffc<18446744073709551612,-4> ; compare and branch on zero
L337  
L338  # ccmp x2, #0x1f, #4, eq
L339  0x44 0x08 0x5f 0xfa
L339  0x00000000: 44 08 5f fa               ?? ccmp.eq  x2, 0x000000000000001f<31>, 4            ; conditional compare
L340  
L341  # ccmp w2, w1, #4, eq
L342  0x44 0x00 0x41 0x7a
L342  0x00000000: 44 00 41 7a               ?? ccmp.eq  w2, w1, 4                                ; conditional compare
L343  
L344  # ccmn w2, w1, #0xf, eq
L345  0x4f 0x00 0x41 0x3a
L345  0x00000000: 4f 00 41 3a               ?? ccmn.eq  w2, w1, 15                               ; conditional compare negative
L346  
L347  # cmn x2, w1, uxtb #1
L348  0x5f 0x04 0x21 0xab
L348  0x00000000: 5f 04 21 ab               ?? cmn      x2, uext(trunc(w1, 8), 32) << 1          ; compare negative
L349  
L350  # cmn x2, w1, uxtw #1
L351  0x5f 0x44 0x21 0xab
L351  0x00000000: 5f 44 21 ab               ?? cmn      x2, w1 << 1                              ; compare negative
L352  
L353  # cmn sp, w1, uxtw #1
L354  0xff 0x47 0x21 0xab
L354  0x00000000: ff 47 21 ab               ?? cmn      sp, w1 << 1                              ; compare negative
L355  
L356  # cmn x2, #0xfff
L357  0x5f 0xfc 0x3f 0xb1
L357  0x00000000: 5f fc 3f b1               ?? cmn      x2, 0x0000000000000fff<4095>             ; compare negative
L358  
L359  # cmn x2, #0xfff, lsl #12
L360  0x5f 0xfc 0x7f 0xb1
L360  0x00000000: 5f fc 7f b1               ?? cmn      x2, 0x0000000000000fff<4095> << 12       ; compare negative
L361  
L362  # cmn x2, x1, asr #63
L363  0x5f 0xfc 0x81 0xab
L363  0x00000000: 5f fc 81 ab               ?? cmn      x2, asr(x1, 0x3f<63>)                    ; compare negative
L364  
L365  # cmp x2, x1, uxtx #3
L366  0x5f 0x6c 0x21 0xeb
L366  0x00000000: 5f 6c 21 eb               ?? cmp      x2, x1 << 3                              ; compare
L367  
L368  # cmp wsp, #0xfc7, lsl #12
L369  0xff 0x1f 0x7f 0x71
L369  0x00000000: ff 1f 7f 71               ?? cmp      wsp, 0x0000000000000fc7<4039> << 12      ; compare
L370  
L371  # cmp w2, w1, lsr #31
L372  0x5f 0x7c 0x41 0x6b
L372  0x00000000: 5f 7c 41 6b               ?? cmp      w2, w1 >> 0x1f<31>                       ; compare
L373  
L374  # cmp w2, w1, asr #31
L375  0x5f 0x7c 0x81 0x6b
L375  0x00000000: 5f 7c 81 6b               ?? cmp      w2, asr(w1, 0x1f<31>)                    ; compare
L376  
L377  # csel x3, x2, x1, eq
L378  0x43 0x00 0x81 0x9a
L378  0x00000000: 43 00 81 9a               ?? csel.eq  x3, x2, x1                               ; conditional select
L379  
L380  # cset w1, ne
L381  0xe1 0x07 0x9f 0x1a
L381  0x00000000: e1 07 9f 1a               ?? cset.ne  w1                                       ; conditional set
L382  
L383  # csetm x1, ne
L384  0xe1 0x03 0x9f 0xda
L384  0x00000000: e1 03 9f da               ?? csetm.ne x1                                       ; conditional set mask
L385  
L386  # eor v3.16b, v2.16b, v1.16b
L387  0x43 0x1c 0x21 0x6e
L387  0x00000000: 43 1c 21 6e               ?? eor      v3.16b, v2.16b, v1.16b                   ; bitwise exclusive OR
L388  
L389  # eor x3, x2, #0x1e
L390  0x43 0x0c 0x7f 0xd2
L390  0x00000000: 43 0c 7f d2               ?? eor      x3, x2, 0x000000000000001e<30>           ; bitwise exclusive OR
L391  
L392  # eor x3, x2, x1, lsl #63
L393  0x43 0xfc 0x01 0xca
L393  0x00000000: 43 fc 01 ca               ?? eor      x3, x2, x1 << 0x3f<63>                   ; bitwise exclusive OR
L394  
L395  # eor x3, x2, x1, lsr #63
L396  0x43 0xfc 0x41 0xca
L396  0x00000000: 43 fc 41 ca               ?? eor      x3, x2, x1 >> 0x3f<63>                   ; bitwise exclusive OR
L397  
L398  # eor x3, x2, x1, asr #63
L399  0x43 0xfc 0x81 0xca
L399  0x00000000: 43 fc 81 ca               ?? eor      x3, x2, asr(x1, 0x3f<63>)                ; bitwise exclusive OR
L400  
L401  # eor x3, x2, x1, ror #63
L402  0x43 0xfc 0xc1 0xca
L402  0x00000000: 43 fc c1 ca               ?? eor      x3, x2, ror(x1, 0x3f<63>)                ; bitwise exclusive OR
L403  
L404  # ldar w2, [x1]
L405  0x22 0xfc 0xdf 0x88
L405  0x00000000: 22 fc df 88               ?? ldar     w2, u32 [x1]                             ; load-acquire register
L406  
L407  # ldarb w2, [x1]
L408  0x22 0xfc 0xdf 0x08
L408  0x00000000: 22 fc df 08               ?? ldarb    w2, u8 [x1]                              ; load-acquire register byte
L409  
L410  # ldarh w2, [x1]
L411  0x22 0xfc 0xdf 0x48
L411  0x00000000: 22 fc df 48               ?? ldarh    w2, u16 [x1]                             ; load-acquire register halfword
L412  
L413  # ldaxr w2, [x1]
L414  0x22 0xfc 0x5f 0x88
L414  0x00000000: 22 fc 5f 88               ?? ldaxr    w2, u32 [x1]                             ; load-acquire exclusive register
L415  
L416  # ldaxrb w2, [x1]
L417  0x22 0xfc 0x5f 0x08
L417  0x00000000: 22 fc 5f 08               ?? ldaxrb   w2, u8 [x1]                              ; load-acquire exclusive register byte
L418  
L419  # ldaxrh w2, [x1]
L420  0x22 0xfc 0x5f 0x48
L420  0x00000000: 22 fc 5f 48               ?? ldaxrh   w2, u16 [x1]                             ; load-acquire exclusive register halfword
L421  
L422  # ldp q3, q1, [x2], #-0x10
L423  0x43 0x84 0xff 0xac
L423  0x00000000: 43 84 ff ac               ?? ldp      q3, q1, u256 [x2 then x2 += 0xfffffffffffffff0<18446744073709551600,-16>] ; load pair of registers
L424  
L425  # ldp s12, s11, [x3, #0x78]!
L426  0x6c 0x2c 0xcf 0x2d
L426  0x00000000: 6c 2c cf 2d               ?? ldp      s12, s11, u64 [x3 += 0x0000000000000078<120>] ; load pair of registers
L427  
L428  # ldr x17, [x16, #3632]
L429  0x11 0x1a 0x47 0xf9
L429  0x00000000: 11 1a 47 f9               ?? ldr      x17, u64 [x16 + 0x0000000000000e30<3632>] ; load register
L430  
L431  # ldrb w2, [x1, #-1]!
L432  0x22 0xfc 0x5f 0x38
L432  0x00000000: 22 fc 5f 38               ?? ldrb     w2, u8 [x1 += 0xffffffffffffffff<18446744073709551615,-1>] ; load register byte
L433  
L434  # ldrb w3, [x2, w1, uxtw]
L435  0x43 0x48 0x61 0x38
L435  0x00000000: 43 48 61 38               ?? ldrb     w3, u8 [uext(trunc(x2 + w1, 32), 64)]    ; load register byte
L436  
L437  # ldrh w3, [x2, #0x1ffe]
L438  0x43 0xfc 0x7f 0x79
L438  0x00000000: 43 fc 7f 79               ?? ldrh     w3, u16 [x2 + 0x0000000000001ffe<8190>]  ; load register halfword
L439  
L440  # ldrh w3, [x2, x1, lsl #1]
L441  0x43 0x78 0x61 0x78
L441  0x00000000: 43 78 61 78               ?? ldrh     w3, u16 [x2 + x1 << 1]                   ; load register halfword
L442  
L443  # ldrsb x3, [x2, #0xfff]
L444  0x43 0xfc 0xbf 0x39
L444  0x00000000: 43 fc bf 39               ?? ldrsb    x3, u8 [x2 + 0x0000000000000fff<4095>]   ; load signed byte
L445  
L446  # ldrsb x3, [x2, x1, sxtx #0]
L447  0x43 0xf8 0xa1 0x38
L447  0x00000000: 43 f8 a1 38               ?? ldrsb    x3, u8 [x2 + x1]                         ; load signed byte
L448  
L449  # ldrsh w3, [x2], #0xffffffffffffffff
L450  0x43 0xf4 0xdf 0x78
L450  0x00000000: 43 f4 df 78               ?? ldrsh    w3, u16 [x2 then x2 += 0xffffffffffffffff<18446744073709551615,-1>] ; load signed halfword
L451  
L452  # ldrsh w3, [x2, x1, lsl #1]
L453  0x43 0x78 0xe1 0x78
L453  0x00000000: 43 78 e1 78               ?? ldrsh    w3, u16 [x2 + x1 << 1]                   ; load signed halfword
L454  
L455  # ldrsw x3, [x2], #0xffffffffffffffff
L456  0x43 0xf4 0x9f 0xb8
L456  0x00000000: 43 f4 9f b8               ?? ldrsw    x3, u32 [x2 then x2 += 0xffffffffffffffff<18446744073709551615,-1>] ; load register signed word
L457  
L458  # ldrsw x1, #0xfffffffffffffffc
L459  # Note that the second argument should be 32-bit memory reference, not
L460  # an immediate value.
L461  0xe1 0xff 0xff 0x98
L461  0x00000000: e1 ff ff 98               ?? ldrsw    x1, u32 [0xfffffffffffffffc<18446744073709551612,-4>] ; load register signed word
L462  
L463  # ldrsw x3, [x2, w1, uxtw #2]
L464  0x43 0x58 0xa1 0xb8
L464  0x00000000: 43 58 a1 b8               ?? ldrsw    x3, u32 [uext(trunc(x2 + w1, 32), 64) << 2] ; load register signed word
L465  
L466  # ldur w3, [x2, #-1]
L467  0x43 0xf0 0x5f 0xb8
L467  0x00000000: 43 f0 5f b8               ?? ldur     w3, u32 [x2 + 0xffffffffffffffff<18446744073709551615,-1>] ; load register
L468  
L469  # ldurb w3, [x2, #-1]
L470  0x43 0xf0 0x5f 0x38
L470  0x00000000: 43 f0 5f 38               ?? ldurb    w3, u8 [x2 + 0xffffffffffffffff<18446744073709551615,-1>] ; load register byte
L471  
L472  # ldurh w3, [x2, #-1]
L473  0x43 0xf0 0x5f 0x78
L473  0x00000000: 43 f0 5f 78               ?? ldurh    w3, u16 [x2 + 0xffffffffffffffff<18446744073709551615,-1>] ; load register halfword
L474  
L475  # ldursb w3, [x2, #-1]
L476  0x43 0xf0 0xdf 0x38
L476  0x00000000: 43 f0 df 38               ?? ldursb   w3, u8 [x2 + 0xffffffffffffffff<18446744073709551615,-1>] ; load register signed byte
L477  
L478  # ldursh w3, [x2, #-1]
L479  0x43 0xf0 0xdf 0x78
L479  0x00000000: 43 f0 df 78               ?? ldursh   w3, u16 [x2 + 0xffffffffffffffff<18446744073709551615,-1>] ; load register signed halfword
L480  
L481  # ldursw x3, [x2, #-1]
L482  0x43 0xf0 0x9f 0xb8
L482  0x00000000: 43 f0 9f b8               ?? ldursw   x3, u32 [x2 + 0xffffffffffffffff<18446744073709551615,-1>] ; load register signed word
L483  
L484  # ldxr w2, [x1]
L485  0x22 0x7c 0x5f 0x88
L485  0x00000000: 22 7c 5f 88               ?? ldxr     w2, u32 [x1]                             ; load exclusive register
L486  
L487  # ldxrb w2, [x1]
L488  0x22 0x7c 0x5f 0x08
L488  0x00000000: 22 7c 5f 08               ?? ldxrb    w2, u8 [x1]                              ; load exclusive register byte
L489  
L490  # ldxrh w2, [x1]
L491  0x22 0x7c 0x5f 0x48
L491  0x00000000: 22 7c 5f 48               ?? ldxrh    w2, u16 [x1]                             ; load exclusive register halfword
L492  
L493  # lsl w3, w2, w1
L494  0x43 0x20 0xc1 0x1a
L494  0x00000000: 43 20 c1 1a               ?? lsl      w3, w2, w1                               ; logical shift left
L495  
L496  # lsr x3, x2, x1
L497  0x43 0x24 0xc1 0x9a
L497  0x00000000: 43 24 c1 9a               ?? lsr      x3, x2, x1                               ; logical shift right
L498  
L499  # lsr w3, w2, #7
L500  0x43 0x7c 0x07 0x53
L500  0x00000000: 43 7c 07 53               ?? lsr      w3, w2, 7                                ; logical shift right
L501  
L502  # movk x1, #0xffff, lsl #16
L503  0xe1 0xff 0xbf 0xf2
L503  0x00000000: e1 ff bf f2               ?? movk     x1, 0x0000ffff << 0x10<16>               ; move wide with keep
L504  
L505  # movk w1, #0xffff, lsl #16
L506  0xe1 0xff 0xbf 0x72
L506  0x00000000: e1 ff bf 72               ?? movk     w1, 0x0000ffff << 0x10<16>               ; move wide with keep
L507  
L508  # movk w1, #0xffff
L509  0xe1 0xff 0x9f 0x72
L509  0x00000000: e1 ff 9f 72               ?? movk     w1, 0x0000ffff                           ; move wide with keep
L510  
L511  # mrs x23, s3_0_c15_c12_5
L512  0xb7 0xfc 0x38 0xd5
L512  0x00000000: b7 fc 38 d5               ?? mrs      x23, s3_0_c15_c12_5                      ; move from system register
L513  
L514  # mrs x1, s2_0_c0_c0_0
L515  # This seems to be disassembled incorrectly by Capstone. Capstone
L516  # emits "mrs x1, s3_0_c0_c0_0"
L517  0x01 0x00 0x30 0xd5
L517  0x00000000: 01 00 30 d5               ?? mrs      x1, s2_0_c0_c0_0                         ; move from system register
L518  
L519  # mrs x1, s3_0_c0_c0_0
L520  # This seems to be disassembled incorrectly by Capstone. Capstone
L521  # emits "mrs x1, midr_el1"
L522  0x01 0x00 0x38 0xd5
L522  0x00000000: 01 00 38 d5               ?? mrs      x1, s3_0_c0_c0_0                         ; move from system register
L523  
L524  # msr s3_2_c3_c8_1, x21
L525  0x35 0x38 0x1a 0xd5
L525  0x00000000: 35 38 1a d5               ?? msr      s3_2_c3_c8_1, x21                        ; move to system register
L526  
L527  # msub w4, w3, w1, w2
L528  0x64 0x88 0x01 0x1b
L528  0x00000000: 64 88 01 1b               ?? msub     w4, w3, w1, w2                           ; multiply-subtract
L529  
L530  # mul w3, w2, w1
L531  0x43 0x7c 0x01 0x1b
L531  0x00000000: 43 7c 01 1b               ?? mul      w3, w2, w1                               ; multiply
L532  
L533  # mul v3.8b, v2.8b, v1.8b
L534  0x43 0x9c 0x21 0x0e
L534  0x00000000: 43 9c 21 0e               ?? mul      v3.8b, v2.8b, v1.8b                      ; multiply
L535  
L536  # mul v3.2s, v2.2s, v1.s[1]
L537  0x43 0x80 0xa1 0x0f
L537  0x00000000: 43 80 a1 0f               ?? mul      v3.2s, v2.2s, v1.s[1]                    ; multiply
L538  
L539  # mvn v3.8b, v2.8b
L540  0x43 0x58 0x20 0x2e
L540  0x00000000: 43 58 20 2e               ?? mvn      q3, q2                                   ; bitwise NOT
L541  
L542  # neg x3, x1, lsl #63
L543  0xe3 0xff 0x01 0xcb
L543  0x00000000: e3 ff 01 cb               ?? neg      x3, x1 << 0x3f<63>                       ; negate
L544  
L545  # neg v3.2d, v2.2d
L546  0x43 0xb8 0xe0 0x6e
L546  0x00000000: 43 b8 e0 6e               ?? neg      v3.2d, v2.2d                             ; negate
L547  
L548  # negs x3, x1
L549  0xe3 0x03 0x01 0xeb
L549  0x00000000: e3 03 01 eb               ?? negs     x3, x1                                   ; negate, setting flags
L550  
L551  # ngc x3, x1
L552  0xe3 0x03 0x01 0xda
L552  0x00000000: e3 03 01 da               ?? ngc      x3, x1                                   ; negate with carry
L553  
L554  # ngcs x3, x1
L555  0xe3 0x03 0x01 0xfa
L555  0x00000000: e3 03 01 fa               ?? ngcs     x3, x1                                   ; negate with carry, setting flags
L556  
L557  # nop
L558  0x1f 0x20 0x03 0xd5
L558  0x00000000: 1f 20 03 d5               ?? nop                                               ; no operation
L559  
L560  # orn v3.16b, v2.16b, v1.16b
L561  0x43 0x1c 0xe1 0x4e
L561  0x00000000: 43 1c e1 4e               ?? orn      v3.16b, v2.16b, v1.16b                   ; bitwise OR NOT
L562  
L563  # orn x3, x2, x1, ror #63
L564  0x43 0xfc 0xe1 0xaa
L564  0x00000000: 43 fc e1 aa               ?? orn      x3, x2, ror(x1, 0x3f<63>)                ; bitwise OR NOT
L565  
L566  # orr v3.8h, #0xff
L567  0xe3 0x97 0x07 0x4f
L567  0x00000000: e3 97 07 4f               ?? orr      v3.8h, 0x00000000000000ff<255>           ; bitwise OR
L568  
L569  # prfum plil2keep, [x13, #0xf4]
L570  0xaa 0x41 0x8f 0xf8
L570  0x00000000: aa 41 8f f8               ?? prfum    plil2keep, u8 [x13 + 0x00000000000000f4<244>] ; prefetch memory
L571  
L572  # ret x1
L573  0x20 0x00 0x5f 0xd6
L573  0x00000000: 20 00 5f d6               ?? ret      x1                                       ; return from subroutine
L574  
L575  # ret
L576  0xc0 0x03 0x5f 0xd6
L576  0x00000000: c0 03 5f d6               ?? ret                                               ; return from subroutine
L577  
L578  # rev w2, w1
L579  0x22 0x08 0xc0 0x5a
L579  0x00000000: 22 08 c0 5a               ?? rev      w2, w1                                   ; reverse bytes
L580  
L581  # rev16 w2, w1
L582  0x22 0x04 0xc0 0x5a
L582  0x00000000: 22 04 c0 5a               ?? rev16    w2, w1                                   ; reverse bytes in 16-bit halfwords
L583  
L584  # rev16 v2.8b, v1.8b
L585  0x22 0x18 0x20 0x0e
L585  0x00000000: 22 18 20 0e               ?? rev16    v2.8b, v1.8b                             ; reverse bytes in 16-bit halfwords
L586  
L587  # sbfiz w2, w1, #4, #4
L588  0x22 0x0c 0x1c 0x13
L588  0x00000000: 22 0c 1c 13               ?? sbfiz    w2, w1, 4, 4                             ; signed bitfield insert in zeros
L589  
L590  # sbfx w2, w1, #4, #4
L591  0x22 0x1c 0x04 0x13
L591  0x00000000: 22 1c 04 13               ?? sbfx     w2, w1, 4, 4                             ; signed bitfield extract
L592  
L593  # sdiv w3, w2, w1
L594  0x43 0x0c 0xc1 0x1a
L594  0x00000000: 43 0c c1 1a               ?? sdiv     w3, w2, w1                               ; signed divide
L595  
L596  # stp q3, q1, [x2, #-0x10]!
L597  0x43 0x84 0xbf 0xad
L597  0x00000000: 43 84 bf ad               ?? stp      q3, q1, u256 [x2 += 0xfffffffffffffff0<18446744073709551600,-16>] ; store pair of registers
L598  
L599  # stp x3, x1, [x2, #-8]
L600  0x43 0x84 0x3f 0xa9
L600  0x00000000: 43 84 3f a9               ?? stp      x3, x1, u128 [x2 + 0xfffffffffffffff8<18446744073709551608,-8>] ; store pair of registers
L601  
L602  # strb w3, [x2], #0xffffffffffffffff
L603  0x43 0xf4 0x1f 0x38
L603  0x00000000: 43 f4 1f 38               ?? strb     w3, u8 [x2 then x2 += 0xffffffffffffffff<18446744073709551615,-1>] ; store register byte
L604  
L605  #strb w3, [x2, x1, lsl #0]
L606  0x43 0x78 0x21 0x38
L606  0x00000000: 43 78 21 38               ?? strb     w3, u8 [x2 + x1]                         ; store register byte
L607  
L608  # strh w3, [x2, w1, uxtw #1]
L609  0x43 0x58 0x21 0x78
L609  0x00000000: 43 58 21 78               ?? strh     w3, u16 [uext(trunc(x2 + w1, 32), 64) << 1] ; store register halfword
L610  
L611  # strh w3, [x2, x1, sxtx #1]
L612  0x43 0xf8 0x21 0x78
L612  0x00000000: 43 f8 21 78               ?? strh     w3, u16 [x2 + x1 << 1]                   ; store register halfword
L613  
L614  # strh w3, [x2, x1, lsl #1]
L615  0x43 0x78 0x21 0x78
L615  0x00000000: 43 78 21 78               ?? strh     w3, u16 [x2 + x1 << 1]                   ; store register halfword
L616  
L617  # stur w2, [x1, #-1]
L618  0x22 0xf0 0x1f 0xb8
L618  0x00000000: 22 f0 1f b8               ?? stur     w2, u32 [x1 + 0xffffffffffffffff<18446744073709551615,-1>] ; store register
L619  
L620  # stur b2, [x1, #-1]
L621  0x22 0xf0 0x1f 0x3c
L621  0x00000000: 22 f0 1f 3c               ?? stur     b2, u8 [x1 + 0xffffffffffffffff<18446744073709551615,-1>] ; store register
L622  
L623  # sturb w2, [x1, #-1]
L624  0x22 0xf0 0x1f 0x38
L624  0x00000000: 22 f0 1f 38               ?? sturb    w2, u8 [x1 + 0xffffffffffffffff<18446744073709551615,-1>] ; store register byte
L625  
L626  # sturh w2, [x1, #-1]
L627  0x22 0xf0 0x1f 0x78
L627  0x00000000: 22 f0 1f 78               ?? sturh    w2, u16 [x1 + 0xffffffffffffffff<18446744073709551615,-1>] ; store register halfword
L628  
L629  # stxr w1, w3, [x2]
L630  0x43 0x7c 0x01 0x88
L630  0x00000000: 43 7c 01 88               ?? stxr     w1, w3, u32 [x2]                         ; store exclusive register
L631  
L632  # stxrb w1, w3, [x2]
L633  0x43 0x7c 0x01 0x08
L633  0x00000000: 43 7c 01 08               ?? stxrb    w1, w3, u8 [x2]                          ; store exclusive register byte
L634  
L635  # stxrh w1, w3, [x2]
L636  0x43 0x7c 0x01 0x48
L636  0x00000000: 43 7c 01 48               ?? stxrh    w1, w3, u16 [x2]                         ; store exclusive register halfword
L637  
L638  # sub w3, w2, w1, uxtw #3
L639  0x43 0x4c 0x21 0x4b
L639  0x00000000: 43 4c 21 4b               ?? sub      w3, w2, w1 << 3                          ; subtract
L640  
L641  # sub wsp, w2, w1, lsl #3
L642  0x5f 0x4c 0x21 0x4b
L642  0x00000000: 5f 4c 21 4b               ?? sub      wsp, w2, w1 << 3                         ; subtract
L643  
L644  # sub x3, x2, #0xfff, lsl #12
L645  0x43 0xfc 0x7f 0xd1
L645  0x00000000: 43 fc 7f d1               ?? sub      x3, x2, 0x0000000000000fff<4095> << 12   ; subtract
L646  
L647  # sub x3, x2, x1, lsr #63
L648  0x43 0xfc 0x41 0xcb
L648  0x00000000: 43 fc 41 cb               ?? sub      x3, x2, x1 >> 0x3f<63>                   ; subtract
L649  
L650  # sub d3, d2, d1
L651  0x43 0x84 0xe1 0x7e
L651  0x00000000: 43 84 e1 7e               ?? sub      d3, d2, d1                               ; subtract
L652  
L653  # sub v3.2d, v2.2d, v1.2d
L654  0x43 0x84 0xe1 0x6e
L654  0x00000000: 43 84 e1 6e               ?? sub      v3.2d, v2.2d, v1.2d                      ; subtract
L655  
L656  # subs x3, x2, w1, uxtb
L657  0x43 0x00 0x21 0xeb
L657  0x00000000: 43 00 21 eb               ?? subs     x3, x2, uext(trunc(w1, 8), 32)           ; subtract
L658  
L659  # subs x3, x2, #0xfff, lsl #12
L660  0x43 0xfc 0x7f 0xf1
L660  0x00000000: 43 fc 7f f1               ?? subs     x3, x2, 0x0000000000000fff<4095> << 12   ; subtract
L661  
L662  # sxtb x3, w2
L663  0x43 0x1c 0x40 0x93
L663  0x00000000: 43 1c 40 93               ?? sxtb     x3, w2                                   ; signed extend byte
L664  
L665  # sxth x3, w2
L666  0x43 0x3c 0x40 0x93
L666  0x00000000: 43 3c 40 93               ?? sxth     x3, w2                                   ; signed extend halfword
L667  
L668  # sxtw x3, w2
L669  0x43 0x7c 0x40 0x93
L669  0x00000000: 43 7c 40 93               ?? sxtw     x3, w2                                   ; sign extend word
L670  
L671  # sys #6, c10, c1, #1, x13
L672  0x2d 0xa1 0x0e 0xd5
L672  0x00000000: 2d a1 0e d5               ?? sys      6, c10, c1, 1, x13                       ; system instruction
L673  
L674  # tbnz w3, #0x1f, #0xfffffffffffffffc
L675  0xe3 0xff 0xff 0x37
L675  0x00000000: e3 ff ff 37               ?? tbnz     w3, 0x000000000000001f<31>, 0xfffffffffffffffc<18446744073709551612,-4> ; test bit and branch if nonzero
L676  
L677  # tbz w3, #0x1f, #0xfffffffffffffffc
L678  0xe3 0xff 0xff 0x36
L678  0x00000000: e3 ff ff 36               ?? tbz      w3, 0x000000000000001f<31>, 0xfffffffffffffffc<18446744073709551612,-4> ; test bit and branch if zero
L679  
L680  # tst w1, #7
L681  0x3f 0x08 0x00 0x72
L681  0x00000000: 3f 08 00 72               ?? tst      w1, 7                                    ; test bits
L682  
L683  # tst x2, x1, asr #63
L684  0x5f 0xfc 0x81 0xea
L684  0x00000000: 5f fc 81 ea               ?? tst      x2, asr(x1, 0x3f<63>)                    ; test bits
L685  
L686  # ubfiz w2, w1, #0x10, #4
L687  0x22 0x0c 0x10 0x53
L687  0x00000000: 22 0c 10 53               ?? ubfiz    w2, w1, 0x0000000000000010<16>, 4        ; unsigned bitfield insert in zeros
L688  
L689  # ubfx w2, w1, #0, #1
L690  0x22 0x00 0x00 0x53
L690  0x00000000: 22 00 00 53               ?? ubfx     w2, w1, 0, 1                             ; unsigned bitfield extract
L691  
L692  # ubfx w2, w1, #1, #4
L693  0x22 0x10 0x01 0x53
L693  0x00000000: 22 10 01 53               ?? ubfx     w2, w1, 1, 4                             ; unsigned bitfield extract
L694  
L695  # udiv x3, x2, x1
L696  0x43 0x08 0xc1 0x9a
L696  0x00000000: 43 08 c1 9a               ?? udiv     x3, x2, x1                               ; unsigned divide
